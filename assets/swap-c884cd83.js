import{m as d,aO as ge,aP as be,a as Ze,q as P,b8 as Ce,b9 as Ne,ba as ut,bb as lt,bc as r,bd as h,n as x,be as pt,S as Se,R as w,s as dt,u as mt,t as ft,w as kt,x as yt,y as ht,z as wt,v as St,K as Ke,P as At,G as D,A as Re,B as gt,bf as Oe,W as bt,H as vt,C as B,aq as he,I as we,J as Tt,bg as Bt,bh as Mt,ag as qe,a7 as Ft,aC as K,Q as Et,bi as R}from"./index-8a22f477.js";import{b as E,d as Xe,A as Ye,N as Le,g as Ue,T as Ge,a as Je,c as $e}from"./associatedTokenAccount-0df006f8.js";var L;(function(t){t[t.InitializeMint=0]="InitializeMint",t[t.InitializeAccount=1]="InitializeAccount",t[t.InitializeMultisig=2]="InitializeMultisig",t[t.Transfer=3]="Transfer",t[t.Approve=4]="Approve",t[t.Revoke=5]="Revoke",t[t.SetAuthority=6]="SetAuthority",t[t.MintTo=7]="MintTo",t[t.Burn=8]="Burn",t[t.CloseAccount=9]="CloseAccount",t[t.FreezeAccount=10]="FreezeAccount",t[t.ThawAccount=11]="ThawAccount",t[t.TransferChecked=12]="TransferChecked",t[t.ApproveChecked=13]="ApproveChecked",t[t.MintToChecked=14]="MintToChecked",t[t.BurnChecked=15]="BurnChecked",t[t.InitializeAccount2=16]="InitializeAccount2",t[t.SyncNative=17]="SyncNative",t[t.InitializeAccount3=18]="InitializeAccount3",t[t.InitializeMultisig2=19]="InitializeMultisig2",t[t.InitializeMint2=20]="InitializeMint2",t[t.GetAccountDataSize=21]="GetAccountDataSize",t[t.InitializeImmutableOwner=22]="InitializeImmutableOwner",t[t.AmountToUiAmount=23]="AmountToUiAmount",t[t.UiAmountToAmount=24]="UiAmountToAmount",t[t.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",t[t.TransferFeeExtension=26]="TransferFeeExtension",t[t.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",t[t.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",t[t.Reallocate=29]="Reallocate",t[t.MemoTransferExtension=30]="MemoTransferExtension",t[t.CreateNativeMint=31]="CreateNativeMint",t[t.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",t[t.InterestBearingMintExtension=33]="InterestBearingMintExtension",t[t.CpiGuardExtension=34]="CpiGuardExtension",t[t.InitializePermanentDelegate=35]="InitializePermanentDelegate",t[t.TransferHookExtension=36]="TransferHookExtension",t[t.MetadataPointerExtension=39]="MetadataPointerExtension"})(L||(L={}));function Pt(t,e,o){if(o.length){t.push({pubkey:e,isSigner:!1,isWritable:!1});for(const n of o)t.push({pubkey:n instanceof d?n:n.publicKey,isSigner:!0,isWritable:!1})}else t.push({pubkey:e,isSigner:!0,isWritable:!1});return t}const Ve=ge([be("instruction")]);function Wt(t,e,o,n=[],a=E){const l=Pt([{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0}],o,n),y=Ze.Buffer.alloc(Ve.span);return Ve.encode({instruction:L.CloseAccount},y),new P({keys:l,programId:a,data:y})}const xt=ge([Ce("mintAuthorityOption"),Ne("mintAuthority"),ut("supply"),be("decimals"),lt("isInitialized"),Ce("freezeAuthorityOption"),Ne("freezeAuthority")]);xt.span;async function zt(t,e,o=!1,n=E,a=Ye){if(!o&&!d.isOnCurve(e.toBuffer()))throw new Xe;const[l]=await d.findProgramAddress([e.toBuffer(),n.toBuffer(),t.toBuffer()],a);return l}function He(t,e,o=!1,n=E,a=Ye){if(!o&&!d.isOnCurve(e.toBuffer()))throw new Xe;const[l]=d.findProgramAddressSync([e.toBuffer(),n.toBuffer(),t.toBuffer()],a);return l}const je=ge([be("instruction")]);function It(t,e=E){const o=[{pubkey:t,isSigner:!1,isWritable:!0}],n=Ze.Buffer.alloc(je.span);return je.encode({instruction:L.SyncNative},n),new P({keys:o,programId:e,data:n})}var Dt=Object.defineProperty,Ct=(t,e,o)=>e in t?Dt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,s=(t,e,o)=>(Ct(t,typeof e!="symbol"?e+"":e,o),o);const ve=new r.BeetArgsStruct([["tradeFeeNumerator",r.u64],["tradeFeeDenominator",r.u64],["ownerTradeFeeNumerator",r.u64],["ownerTradeFeeDenominator",r.u64],["ownerWithdrawFeeNumerator",r.u64],["ownerWithdrawFeeDenominator",r.u64],["hostFeeNumerator",r.u64],["hostFeeDenominator",r.u64]],"FeesInfo"),Te=new r.BeetArgsStruct([["curveType",r.u8],["curveParameters",r.uniformFixedSizeArray(r.u8,32)]],"CurveInfo"),Ae=[135,144,215,161,140,125,41,96];class F{constructor(e,o,n,a,l,y,T,S,A,v,u,W,I,i){this.isInitialized=e,this.bumpSeed=o,this.tokenProgramId=n,this.tokenA=a,this.tokenB=l,this.poolMint=y,this.tokenAMint=T,this.tokenBMint=S,this.poolFeeAccount=A,this.fees=v,this.curve=u,this.swapPolicy=W,this.addLiquidityPolicy=I,this.reserved=i}static fromArgs(e){return new F(e.isInitialized,e.bumpSeed,e.tokenProgramId,e.tokenA,e.tokenB,e.poolMint,e.tokenAMint,e.tokenBMint,e.poolFeeAccount,e.fees,e.curve,e.swapPolicy,e.addLiquidityPolicy,e.reserved)}static fromAccountInfo(e,o=0){return F.deserialize(e.data,o)}static async fromAccountAddress(e,o,n){const a=await e.getAccountInfo(o,n);if(a==null)throw new Error(`Unable to find TokenSwap account at ${o}`);return F.fromAccountInfo(a,0)[0]}static gpaBuilder(e=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return h.GpaBuilder.fromStruct(e,O)}static deserialize(e,o=0){return O.deserialize(e,o)}serialize(){return O.serialize({accountDiscriminator:Ae,...this})}static byteSize(e){const o=F.fromArgs(e);return O.toFixedFromValue({accountDiscriminator:Ae,...o}).byteSize}static async getMinimumBalanceForRentExemption(e,o,n){return o.getMinimumBalanceForRentExemption(F.byteSize(e),n)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,swapPolicy:this.swapPolicy,addLiquidityPolicy:this.addLiquidityPolicy,reserved:this.reserved}}}const O=new r.FixableBeetStruct([["accountDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["isInitialized",r.bool],["bumpSeed",r.u8],["tokenProgramId",h.publicKey],["tokenA",h.publicKey],["tokenB",h.publicKey],["poolMint",h.publicKey],["tokenAMint",h.publicKey],["tokenBMint",h.publicKey],["poolFeeAccount",h.publicKey],["fees",ve],["curve",Te],["swapPolicy",r.coption(h.publicKey)],["addLiquidityPolicy",r.coption(h.publicKey)],["reserved",r.uniformFixedSizeArray(r.u8,64)]],F.fromArgs,"TokenSwap"),f=new Map,k=new Map;class U extends Error{constructor(){super("Swap account already in use"),s(this,"code",6e3),s(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,U)}}f.set(6e3,()=>new U);k.set("AlreadyInUse",()=>new U);class G extends Error{constructor(){super("Invalid program address generated from bump seed and key"),s(this,"code",6001),s(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G)}}f.set(6001,()=>new G);k.set("InvalidProgramAddress",()=>new G);class J extends Error{constructor(){super("Input account owner is not the program address"),s(this,"code",6002),s(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,J)}}f.set(6002,()=>new J);k.set("InvalidOwner",()=>new J);class $ extends Error{constructor(){super("Output pool account owner cannot be the program address"),s(this,"code",6003),s(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$)}}f.set(6003,()=>new $);k.set("InvalidOutputOwner",()=>new $);class V extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),s(this,"code",6004),s(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,V)}}f.set(6004,()=>new V);k.set("ExpectedMint",()=>new V);class H extends Error{constructor(){super("Deserialized account is not an SPL Token account"),s(this,"code",6005),s(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,H)}}f.set(6005,()=>new H);k.set("ExpectedAccount",()=>new H);class j extends Error{constructor(){super("Input token account empty"),s(this,"code",6006),s(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,j)}}f.set(6006,()=>new j);k.set("EmptySupply",()=>new j);class Q extends Error{constructor(){super("Pool token mint has a non-zero supply"),s(this,"code",6007),s(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Q)}}f.set(6007,()=>new Q);k.set("InvalidSupply",()=>new Q);class Z extends Error{constructor(){super("Token account has a delegate"),s(this,"code",6008),s(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Z)}}f.set(6008,()=>new Z);k.set("InvalidDelegate",()=>new Z);class X extends Error{constructor(){super("InvalidInput"),s(this,"code",6009),s(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,X)}}f.set(6009,()=>new X);k.set("InvalidInput",()=>new X);class Y extends Error{constructor(){super("Address of the provided swap token account is incorrect"),s(this,"code",6010),s(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Y)}}f.set(6010,()=>new Y);k.set("IncorrectSwapAccount",()=>new Y);class _ extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),s(this,"code",6011),s(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_)}}f.set(6011,()=>new _);k.set("IncorrectPoolMint",()=>new _);class ee extends Error{constructor(){super("InvalidOutput"),s(this,"code",6012),s(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ee)}}f.set(6012,()=>new ee);k.set("InvalidOutput",()=>new ee);class te extends Error{constructor(){super("General calculation failure due to overflow or underflow"),s(this,"code",6013),s(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,te)}}f.set(6013,()=>new te);k.set("CalculationFailure",()=>new te);class oe extends Error{constructor(){super("Invalid instruction"),s(this,"code",6014),s(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,oe)}}f.set(6014,()=>new oe);k.set("InvalidInstruction",()=>new oe);class ne extends Error{constructor(){super("Swap input token accounts have the same mint"),s(this,"code",6015),s(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ne)}}f.set(6015,()=>new ne);k.set("RepeatedMint",()=>new ne);class ie extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),s(this,"code",6016),s(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ie)}}f.set(6016,()=>new ie);k.set("ExceededSlippage",()=>new ie);class re extends Error{constructor(){super("Token account has a close authority"),s(this,"code",6017),s(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,re)}}f.set(6017,()=>new re);k.set("InvalidCloseAuthority",()=>new re);class ae extends Error{constructor(){super("Pool token mint has a freeze authority"),s(this,"code",6018),s(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ae)}}f.set(6018,()=>new ae);k.set("InvalidFreezeAuthority",()=>new ae);class se extends Error{constructor(){super("Pool fee token account incorrect"),s(this,"code",6019),s(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,se)}}f.set(6019,()=>new se);k.set("IncorrectFeeAccount",()=>new se);class ce extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),s(this,"code",6020),s(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ce)}}f.set(6020,()=>new ce);k.set("ZeroTradingTokens",()=>new ce);class ue extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),s(this,"code",6021),s(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ue)}}f.set(6021,()=>new ue);k.set("FeeCalculationFailure",()=>new ue);class le extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),s(this,"code",6022),s(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,le)}}f.set(6022,()=>new le);k.set("ConversionFailure",()=>new le);class pe extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),s(this,"code",6023),s(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pe)}}f.set(6023,()=>new pe);k.set("InvalidFee",()=>new pe);class de extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),s(this,"code",6024),s(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,de)}}f.set(6024,()=>new de);k.set("IncorrectTokenProgramId",()=>new de);class me extends Error{constructor(){super("The provided curve type is not supported by the program owner"),s(this,"code",6025),s(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,me)}}f.set(6025,()=>new me);k.set("UnsupportedCurveType",()=>new me);class fe extends Error{constructor(){super("The provided curve parameters are invalid"),s(this,"code",6026),s(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,fe)}}f.set(6026,()=>new fe);k.set("InvalidCurve",()=>new fe);class ke extends Error{constructor(){super("The operation cannot be performed on the given curve"),s(this,"code",6027),s(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ke)}}f.set(6027,()=>new ke);k.set("UnsupportedCurveOperation",()=>new ke);const Nt=new r.BeetArgsStruct([["instructionDiscriminator",r.uniformFixedSizeArray(r.u8,8)]],"CloseInstructionArgs"),Kt=[98,165,201,177,108,65,206,96];function Rt(t,e=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=Nt.serialize({instructionDiscriminator:Kt}),n=[{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destTokenA,isWritable:!0,isSigner:!1},{pubkey:t.destTokenB,isWritable:!0,isSigner:!1},{pubkey:t.payer,isWritable:!0,isSigner:!0},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1},{pubkey:t.systemProgram??Se.programId,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const a of t.anchorRemainingAccounts)n.push(a);return new P({programId:e,keys:n,data:o})}const Ot=new r.BeetArgsStruct([["instructionDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["poolTokenAmount",r.u64],["maximumTokenAAmount",r.u64],["maximumTokenBAmount",r.u64]],"DepositAllTokenTypesInstructionArgs"),qt=[32,95,69,60,75,79,205,238];function Lt(t,e,o=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=Ot.serialize({instructionDiscriminator:qt,...e}),a=[{pubkey:t.proofRequest??o,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userTokenA,isWritable:!0,isSigner:!1},{pubkey:t.userTokenB,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)a.push(l);return new P({programId:o,keys:a,data:n})}const Ut=new r.BeetArgsStruct([["instructionDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["sourceTokenAmount",r.u64],["minimumPoolTokenAmount",r.u64]],"DepositSingleTokenTypeInstructionArgs"),Gt=[175,0,152,41,199,0,148,43];function Jt(t,e,o=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=Ut.serialize({instructionDiscriminator:Gt,...e}),a=[{pubkey:t.proofRequest??o,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)a.push(l);return new P({programId:o,keys:a,data:n})}const $t=new r.FixableBeetArgsStruct([["instructionDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["feesInput",ve],["curveInput",Te],["swapPolicy",r.coption(h.publicKey)],["addLiquidityPolicy",r.coption(h.publicKey)]],"InitializeInstructionArgs"),Vt=[175,175,109,31,13,152,155,237];function Ht(t,e,o=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=$t.serialize({instructionDiscriminator:Vt,...e}),a=[{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.tokenA,isWritable:!0,isSigner:!1},{pubkey:t.tokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)a.push(l);return new P({programId:o,keys:a,data:n})}const jt=new r.BeetArgsStruct([["instructionDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["amountIn",r.u64],["minimumAmountOut",r.u64]],"SwapInstructionArgs"),Qt=[248,198,158,145,225,117,135,200];function Zt(t,e,o=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=jt.serialize({instructionDiscriminator:Qt,...e}),a=[{pubkey:t.proofRequest??o,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userSource,isWritable:!0,isSigner:!1},{pubkey:t.userDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolSource,isWritable:!0,isSigner:!1},{pubkey:t.poolDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.hostFeeAccount??o,isWritable:!1,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)a.push(l);return new P({programId:o,keys:a,data:n})}const Xt=new r.BeetArgsStruct([["instructionDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["poolTokenAmount",r.u64],["minimumTokenAAmount",r.u64],["minimumTokenBAmount",r.u64]],"WithdrawAllTokenTypesInstructionArgs"),Yt=[189,254,156,174,210,9,164,216];function _t(t,e,o=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=Xt.serialize({instructionDiscriminator:Yt,...e}),a=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destTokenA,isWritable:!0,isSigner:!1},{pubkey:t.destTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)a.push(l);return new P({programId:o,keys:a,data:n})}const eo=new r.BeetArgsStruct([["instructionDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["destinationTokenAmount",r.u64],["maximumPoolTokenAmount",r.u64]],"WithdrawSingleTokenTypeInstructionArgs"),to=[111,171,21,77,237,181,241,56];function oo(t,e,o=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=eo.serialize({instructionDiscriminator:to,...e}),a=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)a.push(l);return new P({programId:o,keys:a,data:n})}var _e=(t=>(t[t.ConstantProduct=0]="ConstantProduct",t[t.ConstantPrice=1]="ConstantPrice",t[t.Offset=2]="Offset",t))(_e||{});r.fixedScalarEnum(_e);var et=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(et||{});r.fixedScalarEnum(et);var tt=(t=>(t[t.AtoB=0]="AtoB",t[t.BtoA=1]="BtoA",t))(tt||{});r.fixedScalarEnum(tt);const no="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",io=new d(no);class ro{constructor(e){s(this,"programId",io),this.provider=e}get connection(){return this.provider.connection}swapAuthority(e){return d.findProgramAddressSync([e.toBuffer()],this.programId)[0]}async closeTokenSwap(e,o){const n=new x,a=this.provider.publicKey,l=this.swapAuthority(e.tokenSwap),y=await this.load(e.tokenSwap),T=He(y.tokenAMint,a),S=He(y.tokenBMint,a);return await this.handleMissingTokenAccount(n,T,y.tokenAMint),await this.handleMissingTokenAccount(n,S,y.tokenBMint),n.add(Rt({payer:a,tokenSwap:e.tokenSwap,authority:l,destTokenA:T,destTokenB:S,swapTokenA:y.tokenA,swapTokenB:y.tokenB})),{signature:await this.provider.sendAndConfirm(n,[],o)}}async createTokenSwap(e,o){const n=new x,a=e.tokenSwap??pt.generate(),l=Array.from({length:32}),y=Array.from(e.curveParameters??[]);for(let u=0;u<y.length;u++)l[u]=y[u];const T={curveType:e.curveType,curveParameters:l},S=this.getTokenSwapSpace(T),A=await this.connection.getMinimumBalanceForRentExemption(S);n.add(Se.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:a.publicKey,programId:this.programId,lamports:A,space:S})),n.add(Ht({authority:this.swapAuthority(a.publicKey),tokenSwap:a.publicKey,destination:e.destination,poolMint:e.poolMint,poolFee:e.poolFee,tokenA:e.tokenA,tokenB:e.tokenB},{feesInput:{tradeFeeNumerator:new w(e.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new w(e.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new w(e.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new w(e.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new w(e.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new w(e.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new w(e.fees.hostFeeNumerator.toString()),hostFeeDenominator:new w(e.fees.hostFeeDenominator.toString())},curveInput:T,swapPolicy:e.swapPolicy??null,addLiquidityPolicy:e.addLiquidityPolicy??null}));const v=await this.provider.sendAndConfirm(n,[a],o);return{tokenSwap:a.publicKey,signature:v}}getTokenSwapSpace(e){return F.byteSize({bumpSeed:0,curve:e,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,poolFeeAccount:d.default,poolMint:d.default,tokenA:d.default,tokenAMint:d.default,tokenB:d.default,tokenBMint:d.default,tokenProgramId:d.default,swapPolicy:d.default,addLiquidityPolicy:d.default,reserved:[]})}async swap(e,o){const n=new x;return await this.handleMissingTokenAccount(n,e.userDestination,e.destinationTokenMint),await this.handleWrappedSol({tx:n,amount:e.amountIn,userSource:e.userSource,sourceTokenMint:e.sourceTokenMint}),n.add(Zt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:e.userSource,userDestination:e.userDestination,tokenSwap:e.tokenSwap,poolFee:e.poolFee,poolMint:e.poolMint,poolSource:e.poolSource,poolDestination:e.poolDestination,hostFeeAccount:e.hostFeeAccount,proofRequest:e.proofRequest},{amountIn:new w(e.amountIn.toString()),minimumAmountOut:new w(e.minimumAmountOut.toString())})),this.unwrapSol(n,e.userDestination,e.destinationTokenMint),this.provider.sendAndConfirm(n,[],o)}async depositAllTokenTypes(e,o){const n=new x;return await this.handleMissingTokenAccount(n,e.destination,e.poolMint),await this.handleWrappedSol({tx:n,amount:e.maximumTokenA,userSource:e.userTokenA,sourceTokenMint:e.tokenAMint}),await this.handleWrappedSol({tx:n,amount:e.maximumTokenB,userSource:e.userTokenB,sourceTokenMint:e.tokenBMint}),n.add(Lt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,destination:e.destination,userTokenA:e.userTokenA,userTokenB:e.userTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB,proofRequest:e.proofRequest},{poolTokenAmount:new w(e.poolTokenAmount.toString()),maximumTokenAAmount:new w(e.maximumTokenA.toString()),maximumTokenBAmount:new w(e.maximumTokenB.toString())})),this.provider.sendAndConfirm(n,[],o)}async withdrawAllTokenTypes(e,o){const n=new x;return await this.handleMissingTokenAccount(n,e.destTokenA,e.tokenAMint),await this.handleMissingTokenAccount(n,e.destTokenB,e.tokenBMint),n.add(_t({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destTokenA:e.destTokenA,destTokenB:e.destTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new w(e.poolTokenAmount.toString()),minimumTokenAAmount:new w(e.minimumTokenA.toString()),minimumTokenBAmount:new w(e.minimumTokenB.toString())})),this.unwrapSol(n,e.destTokenA,e.tokenAMint),this.unwrapSol(n,e.destTokenB,e.tokenBMint),this.provider.sendAndConfirm(n,[],o)}async depositSingleTokenTypeExactAmountIn(e,o){const n=new x;return await this.handleMissingTokenAccount(n,e.destination,e.poolMint),await this.handleWrappedSol({tx:n,amount:e.sourceTokenAmount,userSource:e.source,sourceTokenMint:e.sourceTokenMint}),n.add(Jt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB,proofRequest:e.proofRequest},{sourceTokenAmount:new w(e.sourceTokenAmount.toString()),minimumPoolTokenAmount:new w(e.minimumPoolTokenAmount.toString())})),this.provider.sendAndConfirm(n,[],o)}async withdrawSingleTokenTypeExactAmountOut(e,o){const n=new x;return await this.handleMissingTokenAccount(n,e.destination,e.destinationTokenMint),n.add(oo({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{destinationTokenAmount:new w(e.destinationTokenAmount.toString()),maximumPoolTokenAmount:new w(e.maximumPoolTokenAmount.toString())})),this.unwrapSol(n,e.destination,e.destinationTokenMint),this.provider.sendAndConfirm(n,[],o)}async load(e,o){return F.fromAccountAddress(this.provider.connection,new d(e),o)}async loadAll(e={}){const o=F.gpaBuilder().addFilter("accountDiscriminator",Ae);return e.noData&&(o.config.dataSlice={offset:0,length:0}),e.tokenProgramId&&o.addFilter("tokenProgramId",new d(e.tokenProgramId)),e.poolMint&&o.addFilter("poolMint",new d(e.poolMint)),e.tokenAMint&&o.addFilter("tokenAMint",new d(e.tokenAMint)),e.tokenBMint&&o.addFilter("tokenBMint",new d(e.tokenBMint)),(await o.run(this.provider.connection)).map(({pubkey:n,account:a})=>({pubkey:n,data:e.noData?null:F.fromAccountInfo(a)[0]}))}unwrapSol(e,o,n){n&&n.toBase58()===Le.toBase58()&&e.add(Wt(o,this.provider.publicKey,this.provider.publicKey))}async handleMissingTokenAccount(e,o,n){try{await Ue(this.connection,o)}catch(a){(a instanceof Ge||a instanceof Je)&&n&&e.add($e(this.provider.publicKey,o,this.provider.publicKey,n))}}async handleWrappedSol(e){var o;if(e.sourceTokenMint&&((o=e.sourceTokenMint)==null?void 0:o.toBase58())===Le.toBase58()){let n=0;try{if((await zt(e.sourceTokenMint,this.provider.publicKey)).toBase58()!==e.userSource.toBase58())return;const l=await Ue(this.connection,e.userSource);n=Number(l.amount)}catch(l){(l instanceof Ge||l instanceof Je)&&e.tx.add($e(this.provider.publicKey,e.userSource,this.provider.publicKey,e.sourceTokenMint))}const a=Number(e.amount);e.amount>n&&e.tx.add(Se.transfer({fromPubkey:this.provider.publicKey,toPubkey:e.userSource,lamports:a-n}),It(e.userSource))}}}const Qe=[135,144,215,161,140,125,41,96];class z{constructor(e,o,n,a,l,y,T,S,A,v,u,W){this.isInitialized=e,this.bumpSeed=o,this.tokenProgramId=n,this.tokenA=a,this.tokenB=l,this.poolMint=y,this.tokenAMint=T,this.tokenBMint=S,this.poolFeeAccount=A,this.fees=v,this.curve=u,this.policy=W}static fromArgs(e){return new z(e.isInitialized,e.bumpSeed,e.tokenProgramId,e.tokenA,e.tokenB,e.poolMint,e.tokenAMint,e.tokenBMint,e.poolFeeAccount,e.fees,e.curve,e.policy)}static fromAccountInfo(e,o=0){return z.deserialize(e.data,o)}static async fromAccountAddress(e,o,n){const a=await e.getAccountInfo(o,n);if(a==null)throw new Error(`Unable to find TokenSwap account at ${o}`);return z.fromAccountInfo(a,0)[0]}static gpaBuilder(e=new d("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return h.GpaBuilder.fromStruct(e,q)}static deserialize(e,o=0){return q.deserialize(e,o)}serialize(){return q.serialize({accountDiscriminator:Qe,...this})}static byteSize(e){const o=z.fromArgs(e);return q.toFixedFromValue({accountDiscriminator:Qe,...o}).byteSize}static async getMinimumBalanceForRentExemption(e,o,n){return o.getMinimumBalanceForRentExemption(z.byteSize(e),n)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const q=new r.FixableBeetStruct([["accountDiscriminator",r.uniformFixedSizeArray(r.u8,8)],["isInitialized",r.bool],["bumpSeed",r.u8],["tokenProgramId",h.publicKey],["tokenA",h.publicKey],["tokenB",h.publicKey],["poolMint",h.publicKey],["tokenAMint",h.publicKey],["tokenBMint",h.publicKey],["poolFeeAccount",h.publicKey],["fees",ve],["curve",Te],["policy",r.coption(h.publicKey)]],z.fromArgs,"TokenSwap");var ao=(t=>(t[t.ASC=0]="ASC",t[t.DESC=1]="DESC",t))(ao||{});const lo=dt("swap",()=>{const t=mt(),e=ft(),o=kt(),n=yt(),{publicKey:a}=ht(),{notify:l}=wt(),y=St(()=>new ro(new Ke(t.connection,n.value??{publicKey:At.default},Ke.defaultOptions()))),T=D({}),S=D([]),A=D([]),v=D([]),u=D(),W=Re("token-a",""),I=Re("token-b",""),i=gt({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:Oe,to:Oe,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:ot,tokens:M}=bt();ot(vt),B(M,()=>{if(M.value.length>=2){const c=M.value.find(m=>m.mint===W.value)??M.value[0];let p=M.value.find(m=>m.mint===I.value)??M.value[1];if(i.from=M.value.find(m=>m.mint===W.value)??M.value[0],i.to=M.value.find(m=>m.mint===I.value)??M.value[1],c===p){const m=M.value.find(g=>g.mint!==c.mint);m&&(p=m)}i.from=c,i.to=p}},{immediate:!0}),B(()=>i.from,()=>{i.from&&(W.value=i.from.mint)}),B(()=>i.to,()=>{i.to&&(I.value=i.to.mint)});const Be=he(async()=>{i.loading=!0;try{console.log("swapClient ================: ",y.value),S.value=await y.value.loadAll(),console.log("swaps ================: ",S.value)}catch(c){console.log(c),S.value=[]}finally{i.loading=!1}},400);B([n,()=>t.cluster],async c=>{Be()?.then(),c||it()},{immediate:!0});const Me=he(async()=>{if(a.value&&A.value.length>0){const c={};for(const p of A.value)try{const m=await we(p.data.poolMint,a.value),g=await Tt(t.connection,m);c[p.data.poolMint.toBase58()]=Number(g.amount),console.log("userAcc === ",g)}catch{}T.value=c}},500);B([a,A],Me,{immediate:!0});const ye=D(!1),C=he(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!u.value){ye.value=!0;try{const c=await Bt(t.connection,y.value.swapAuthority(u.value.pubkey)),p={};for(const g of c)p[`${g.mint}`]=g.amount;i.poolBalance=p;const m=await Mt(t.connection,u.value.data.poolMint);i.poolTokenSupply=Number(m.supply),console.log("[Pool Balance] poolMint",m),console.log("[Pool Balance]",i.poolBalance),console.log("[Pool Balance] poolTokenSupply",i.poolTokenSupply)}catch(c){console.log("[Pool Balance] error",c)}finally{ye.value=!1}}},500);setInterval(C,6e4);function nt(c){u.value=c,console.log("setTokenSwap: ",u.value)}B([S,()=>o.servicePolicy],async()=>{console.log("tokenSwapsAll: ",S.value),A.value=S.value.filter(c=>!!o.servicePolicy.find(p=>p.pubkey.toBase58()===c.data.swapPolicy?.toBase58())&&!!o.servicePolicy.find(p=>p.pubkey.toBase58()===c.data.addLiquidityPolicy?.toBase58())&&!!e.tokenByMint(c.data.tokenAMint.toBase58())&&!!e.tokenByMint(c.data.tokenBMint.toBase58()))},{immediate:!0}),B([A,()=>i.from?.mint,()=>i.to?.mint,()=>o.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",A.value),A.value&&i.from?.mint&&i.to?.mint&&i.from.mint!==i.to.mint&&o.servicePolicy.length)if(v.value=A.value.filter(c=>{const p=c.data?.tokenAMint.toBase58(),m=c.data?.tokenBMint.toBase58();return p===i.from.mint&&m===i.to.mint||p===i.to.mint&&m===i.from.mint}),v.value.length){if(v.value.length>1){const c=v.value.find(p=>o.state.certificates?.find(m=>m.data?.policy.toBase58()===p.data.swapPolicy?.toBase58()||m.data?.policy.toBase58()===p.data.addLiquidityPolicy?.toBase58()));c&&(u.value=c)}u.value=v.value[0]}else u.value=void 0;else v.value=[],u.value=void 0,o.setContractPolicy("","swap"),o.setContractPolicy("","liquidity"),i.poolBalance={}},{immediate:!0}),B([u],async()=>{console.log("Token SWAP: ",u.value),o.setContractPolicy(u.value?.data.swapPolicy?.toBase58()??"","swap"),o.setContractPolicy(u.value?.data.addLiquidityPolicy?.toBase58()??"","liquidity"),u.value&&(C(),u.value.data.tokenAMint.toBase58()===i.from.mint?i.direction=0:i.direction=1)},{immediate:!0});function it(){i.loading=!1,i.slippageDialog=!1,i.poolBalance={},i.poolTokenSupply=0}B([()=>i.direction,()=>i.from.amount,()=>i.poolBalance],async()=>{const c=Number(i.from.amount??0),p=qe(Number(i.poolBalance[i.from.mint]??0),i.from.decimals),m=qe(Number(i.poolBalance[i.to.mint]??0),i.to.decimals),g=1-i.fees.ownerTrade-i.fees.trade;if(c===0||Number.isNaN(c)){i.to.amount=0,i.rate=Number(m)/Number(p)*g,i.impact=0,i.minimumReceived=0;return}const b=m-p*m/(p+c*g);i.rate=c?b/c:m/p,i.to.amount=b?Number(Ft(b,i.to.decimals)):0,i.impact=c?1-b/c/g/(m/p):0,i.minimumReceived=K(i.to.amount-i.to.amount*i.slippage,i.to.decimals)},{immediate:!0});async function rt(){if(!o.certificateValid)return Et();if(!u.value||!a.value){console.log("Pool is not selected...");return}n.value.publicKey||l({type:"info",message:"Please connect your wallet first"});const p=Number(K(i.from.amount??0,i.from.decimals)),m=Number(K(o.tokenBalance(i.from.mint)??0,i.from.decimals)),g=Number(K(i.to.amount??0,i.to.decimals));if(p>m){l({type:"negative",message:"Insufficient balance."});return}try{i.swapping=!0;const b=i.direction===0?u.value.data.tokenAMint:u.value.data.tokenBMint,N=i.direction===0?u.value.data.tokenBMint:u.value.data.tokenAMint,Pe=i.direction===0?u.value.data.tokenA:u.value.data.tokenB,We=i.direction===0?u.value.data.tokenB:u.value.data.tokenA;console.log("userSourceMint = ",b.toBase58()),console.log("userDestinationMint = ",N.toBase58()),console.log("userSourceMint = ",b.toBase58()),console.log("userDestinationMint = ",N.toBase58());const xe=await we(b,n.value.publicKey),ze=await we(N,n.value.publicKey),Ie=p;console.log("toAmount = ",g),console.log("slippage = ",i.slippage),console.log("slippage 2 = ",g*i.slippage);const De=y.value.swapAuthority(u.value.pubkey);console.log("proofRequest = ",o.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",De),console.log("tokenSwap = ",u.value.pubkey.toBase58()),console.log("userSource = ",xe.toBase58()),console.log("userDestination = ",ze.toBase58()),console.log("poolSource = ",Pe.toBase58()),console.log("poolDestination = ",We.toBase58()),console.log("poolMint = ",u.value.data.poolMint.toBase58()),console.log("poolFee = ",u.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",Ie),console.log("minimumAmountOut = ",i.minimumReceived);const ct=await y.value.swap({proofRequest:o.certificate?.pubkey,authority:De,tokenSwap:u.value.pubkey,userSource:xe,userDestination:ze,poolSource:Pe,poolDestination:We,poolMint:u.value.data.poolMint,poolFee:u.value.data.poolFeeAccount,amountIn:Ie,minimumAmountOut:i.minimumReceived,sourceTokenMint:b,destinationTokenMint:N},{commitment:"confirmed"});l({message:"Transaction confirmed",type:"positive",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${ct}?cluster=${t.cluster}`,onClick:()=>!1}]}),Fe()}catch(b){console.log(b),console.error(b.logs),`${b}`.includes("User rejected the request")||l({type:"negative",message:`${b}`})}finally{i.swapping=!1}}function at(){const{from:c,to:p}=i;i.rate=0,i.to={...c,amount:void 0},i.from={...p,amount:void 0},i.direction=i.direction===0?1:0}function st(){i.slippageDialog=!1}function Fe(){C(),i.from.amount=void 0,i.to.amount=void 0}B(()=>n.value?.publicKey,c=>{c||Fe()}),B(()=>i.to,c=>{c.amount&&(c.amount=void 0)});function Ee(c){return{host:R(c.fees.hostFeeNumerator,c.fees.hostFeeDenominator),trade:R(c.fees.tradeFeeNumerator,c.fees.tradeFeeDenominator),ownerTrade:R(c.fees.ownerTradeFeeNumerator,c.fees.ownerTradeFeeDenominator),ownerWithdraw:R(c.fees.ownerWithdrawFeeNumerator,c.fees.ownerWithdrawFeeDenominator)}}return B(u,c=>{if(!c)return;const p=Ee(c.data);i.fees.host=p.host,i.fees.trade=p.trade,i.fees.ownerTrade=p.ownerTrade,i.fees.ownerWithdraw=p.ownerWithdraw,console.log("fees ==== ",i.fees)}),{state:i,tokenSwapsAllFiltered:A,tokenSwaps:v,tokenSwap:u,swapClient:y,loadingPoolTokens:ye,loadPoolTokenAccounts:C,setTokenSwap:nt,closeSlippage:st,changeDirection:at,swapSubmit:rt,getPoolFee:Ee,init:Be,tokenAMint:W,tokenBMint:I,userPoolsTokens:T,reloadUserLP:Me}});export{ao as S,_e as k,lo as u};
