import{m as A,ao as wt,ap as kt,a as H,q as V,bq as Wt,b8 as Ct,aq as Fi,br as xi,bs as q,av as N,bt as Mi,bu as Pi,bv as ai,bw as v,n as te,bx as _i,S as ct,R as F,s as $i,u as Di,t as Wi,w as Ci,x as Ki,y as Ii,z as Ni,v as Ri,K as Kt,P as Oi,G as ce,A as It,B as Gi,by as Nt,W as qi,H as Ui,C as D,aG as ot,I as rt,J as Li,bz as ji,bA as Vi,ax as Rt,a6 as Yi,aS as Se,Q as Ji,bB as be}from"./index-67f1fef1.js";import{b as I,d as si,A as ci,N as Ot,g as Gt,T as qt,a as Ut,c as Lt}from"./associatedTokenAccount-aa192fd2.js";var Be;(function(e){e[e.InitializeMint=0]="InitializeMint",e[e.InitializeAccount=1]="InitializeAccount",e[e.InitializeMultisig=2]="InitializeMultisig",e[e.Transfer=3]="Transfer",e[e.Approve=4]="Approve",e[e.Revoke=5]="Revoke",e[e.SetAuthority=6]="SetAuthority",e[e.MintTo=7]="MintTo",e[e.Burn=8]="Burn",e[e.CloseAccount=9]="CloseAccount",e[e.FreezeAccount=10]="FreezeAccount",e[e.ThawAccount=11]="ThawAccount",e[e.TransferChecked=12]="TransferChecked",e[e.ApproveChecked=13]="ApproveChecked",e[e.MintToChecked=14]="MintToChecked",e[e.BurnChecked=15]="BurnChecked",e[e.InitializeAccount2=16]="InitializeAccount2",e[e.SyncNative=17]="SyncNative",e[e.InitializeAccount3=18]="InitializeAccount3",e[e.InitializeMultisig2=19]="InitializeMultisig2",e[e.InitializeMint2=20]="InitializeMint2",e[e.GetAccountDataSize=21]="GetAccountDataSize",e[e.InitializeImmutableOwner=22]="InitializeImmutableOwner",e[e.AmountToUiAmount=23]="AmountToUiAmount",e[e.UiAmountToAmount=24]="UiAmountToAmount",e[e.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",e[e.TransferFeeExtension=26]="TransferFeeExtension",e[e.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",e[e.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",e[e.Reallocate=29]="Reallocate",e[e.MemoTransferExtension=30]="MemoTransferExtension",e[e.CreateNativeMint=31]="CreateNativeMint",e[e.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",e[e.InterestBearingMintExtension=33]="InterestBearingMintExtension",e[e.CpiGuardExtension=34]="CpiGuardExtension",e[e.InitializePermanentDelegate=35]="InitializePermanentDelegate",e[e.TransferHookExtension=36]="TransferHookExtension",e[e.MetadataPointerExtension=39]="MetadataPointerExtension"})(Be||(Be={}));function Hi(e,t,i){if(i.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const o of i)e.push({pubkey:o instanceof A?o:o.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}const jt=wt([kt("instruction")]);function Qi(e,t,i,o=[],r=I){const a=Hi([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}],i,o),n=H.Buffer.alloc(jt.span);return jt.encode({instruction:Be.CloseAccount},n),new V({keys:a,programId:r,data:n})}const Zi=wt([Wt("mintAuthorityOption"),Ct("mintAuthority"),Fi("supply"),kt("decimals"),xi("isInitialized"),Wt("freezeAuthorityOption"),Ct("freezeAuthority")]);Zi.span;async function Xi(e,t,i=!1,o=I,r=ci){if(!i&&!A.isOnCurve(t.toBuffer()))throw new si;const[a]=await A.findProgramAddress([t.toBuffer(),o.toBuffer(),e.toBuffer()],r);return a}function Vt(e,t,i=!1,o=I,r=ci){if(!i&&!A.isOnCurve(t.toBuffer()))throw new si;const[a]=A.findProgramAddressSync([t.toBuffer(),o.toBuffer(),e.toBuffer()],r);return a}const Yt=wt([kt("instruction")]);function eo(e,t=I){const i=[{pubkey:e,isSigner:!1,isWritable:!0}],o=H.Buffer.alloc(Yt.span);return Yt.encode({instruction:Be.SyncNative},o),new V({keys:i,programId:t,data:o})}var f={},x={},w={};Object.defineProperty(w,"__esModule",{value:!0});w.isElementCollectionFixedSizeBeet=w.isFixableBeet=w.assertFixedSizeBeet=w.isFixedSizeBeet=w.BEET_TYPE_ARG_INNER=w.BEET_TYPE_ARG_LEN=w.BEET_PACKAGE=void 0;const to=q();w.BEET_PACKAGE="@metaplex-foundation/beet";w.BEET_TYPE_ARG_LEN="len";w.BEET_TYPE_ARG_INNER="Beet<{innner}>";function ui(e){return Object.keys(e).includes("byteSize")}w.isFixedSizeBeet=ui;function io(e,t=`${e} should have been a fixed beet`){(0,to.strict)(ui(e),t)}w.assertFixedSizeBeet=io;function oo(e){return typeof e.toFixedFromData=="function"&&typeof e.toFixedFromValue=="function"}w.isFixableBeet=oo;function ro(e){const t=Object.keys(e);return t.includes("length")&&t.includes("elementByteSize")&&t.includes("lenPrefixByteSize")}w.isElementCollectionFixedSizeBeet=ro;var Q={};(function(e){var t=N&&N.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0}),e.numbersTypeMap=e.bool=e.i512=e.i256=e.i128=e.i64=e.i32=e.i16=e.i8=e.u512=e.u256=e.u128=e.u64=e.u32=e.u16=e.u8=void 0;const i=t(Mi),o=w;e.u8={write:function(n,s,u){n.writeUInt8(u,s)},read:function(n,s){return n.readUInt8(s)},byteSize:1,description:"u8"},e.u16={write:function(n,s,u){n.writeUInt16LE(u,s)},read:function(n,s){return n.readUInt16LE(s)},byteSize:2,description:"u16"},e.u32={write:function(n,s,u){n.writeUInt32LE(u,s)},read:function(n,s){return n.readUInt32LE(s)},byteSize:4,description:"u32"};function r(n,s){return{write:function(u,l,p){const S=(i.default.isBN(p)?p:new i.default(p)).toArray("le",this.byteSize);H.Buffer.from(S).copy(u,l,0,this.byteSize)},read:function(u,l){const p=u.slice(l,l+this.byteSize);return new i.default(p,"le")},byteSize:n,description:s}}e.u64=r(8,"u64"),e.u128=r(16,"u128"),e.u256=r(32,"u256"),e.u512=r(64,"u512"),e.i8={write:function(n,s,u){n.writeInt8(u,s)},read:function(n,s){return n.readInt8(s)},byteSize:1,description:"i8"},e.i16={write:function(n,s,u){n.writeInt16LE(u,s)},read:function(n,s){return n.readInt16LE(s)},byteSize:2,description:"i16"},e.i32={write:function(n,s,u){n.writeInt32LE(u,s)},read:function(n,s){return n.readInt32LE(s)},byteSize:4,description:"i32"};function a(n,s){const u=n*8;return{write:function(l,p,d){const b=(i.default.isBN(d)?d:new i.default(d)).toTwos(u).toArray("le",this.byteSize);H.Buffer.from(b).copy(l,p,0,this.byteSize)},read:function(l,p){const d=l.slice(p,p+this.byteSize);return new i.default(d,"le").fromTwos(u)},byteSize:n,description:s}}e.i64=a(8,"i64"),e.i128=a(16,"i128"),e.i256=a(32,"i256"),e.i512=a(64,"i512"),e.bool={write:function(n,s,u){const l=u?1:0;e.u8.write(n,s,l)},read:function(n,s){return e.u8.read(n,s)===1},byteSize:1,description:"bool"},e.numbersTypeMap={u8:{beet:"u8",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"number"},u16:{beet:"u16",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"number"},u32:{beet:"u32",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"number"},i8:{beet:"i8",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"number"},i16:{beet:"i16",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"number"},i32:{beet:"i32",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"number"},bool:{beet:"bool",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"boolean"},u64:{beet:"u64",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE},u128:{beet:"u128",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE},u256:{beet:"u256",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE},u512:{beet:"u512",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE},i64:{beet:"i64",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE},i128:{beet:"i128",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE},i256:{beet:"i256",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE},i512:{beet:"i512",isFixable:!1,sourcePack:o.BEET_PACKAGE,ts:"bignum",pack:o.BEET_PACKAGE}}})(Q);var E={},li=N&&N.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(E,"__esModule",{value:!0});E.UnreachableCaseError=E.stringify=E.bytes=E.beetBytes=E.logTrace=E.logDebug=E.logInfo=E.logError=void 0;const Ee=li(Pi),no=li(ai),Jt=w,{brightBlack:di}=no.default;E.logError=(0,Ee.default)("beet:error");E.logInfo=(0,Ee.default)("beet:info");E.logDebug=(0,Ee.default)("beet:debug");E.logTrace=(0,Ee.default)("beet:trace");function ao(e,t=!1){let i;if((0,Jt.isFixableBeet)(e))i="? B";else if((0,Jt.isElementCollectionFixedSizeBeet)(e)){const o=t?"length":e.length,r=e.lenPrefixByteSize;i=r>0?`${r} + (${e.elementByteSize} * ${o}) B  (${e.byteSize} B)`:`(${e.elementByteSize} * ${o}) B (${e.byteSize} B)`}else i=`${e.byteSize} B`;return di(i)}E.beetBytes=ao;function so(e){return di(`${e} B`)}E.bytes=so;function co(e){return e.toString==="function"?e.toString():e}E.stringify=co;class uo extends Error{constructor(t){super(`Unreachable case: ${t}`)}}E.UnreachableCaseError=uo;var G={};Object.defineProperty(G,"__esModule",{value:!0});G.fixBeetFromValue=G.fixBeetFromData=void 0;const Te=w,pi=E;function lo(e,t,i){if((0,Te.isFixedSizeBeet)(e))return e;if((0,Te.isFixableBeet)(e))return e.toFixedFromData(t,i);throw new pi.UnreachableCaseError(e)}G.fixBeetFromData=lo;function po(e,t){if((0,Te.isFixedSizeBeet)(e))return e;if((0,Te.isFixableBeet)(e))return e.toFixedFromValue(t);throw new pi.UnreachableCaseError(e)}G.fixBeetFromValue=po;Object.defineProperty(x,"__esModule",{value:!0});x.collectionsTypeMap=x.uint8Array=x.fixedSizeUint8Array=x.fixedSizeBuffer=x.array=x.fixedSizeArray=x.uniformFixedSizeArray=void 0;const ue=w,oe=q(),Z=Q,le=w,fi=E,Ht=G;function fo(e,t,i=!1){const o=e.byteSize*t,r=i?4+o:o;return{write:function(a,n,s){oe.strict.equal(s.length,t,`array length ${s.length} should match len ${t}`),i&&(Z.u32.write(a,n,t),n+=4);for(let u=0;u<t;u++)e.write(a,n+u*e.byteSize,s[u])},read:function(a,n){if(i){const u=Z.u32.read(a,n);oe.strict.equal(u,t,"invalid byte size"),n+=4}const s=new Array(t);for(let u=0;u<t;u++)s[u]=e.read(a,n+u*e.byteSize);return s},byteSize:r,length:t,elementByteSize:e.byteSize,lenPrefixByteSize:4,description:`Array<${e.description}>(${t})`}}x.uniformFixedSizeArray=fo;function ut(e,t){const i=e.length,o=i===0?"<EMPTY>":e[0].description;return{write:function(r,a,n){oe.strict.equal(n.length,i,`array length ${n.length} should match len ${i}`),Z.u32.write(r,a,i);let s=a+4;for(let u=0;u<i;u++){const l=e[u];l.write(r,s,n[u]),s+=l.byteSize}},read:function(r,a){const n=Z.u32.read(r,a);oe.strict.equal(n,i,"invalid byte size");let s=a+4;const u=new Array(i);for(let l=0;l<i;l++){const p=e[l];u[l]=p.read(r,s),s+=p.byteSize}return u},byteSize:4+t,length:i,description:`Array<${o}>(${i})[ 4 + ${t} ]`}}x.fixedSizeArray=ut;function yo(e){return{toFixedFromData(t,i){const o=Z.u32.read(t,i);(0,fi.logTrace)(`${this.description}[${o}]`);const r=i+4;let a=r;const n=new Array(o);for(let s=0;s<o;s++){const u=(0,Ht.fixBeetFromData)(e,t,a);n[s]=u,a+=u.byteSize}return ut(n,a-r)},toFixedFromValue(t){(0,oe.strict)(Array.isArray(t),`${t} should be an array`);let i=0;const o=new Array(t.length);for(let r=0;r<t.length;r++){const a=(0,Ht.fixBeetFromValue)(e,t[r]);o[r]=a,i+=a.byteSize}return ut(o,i)},description:"array"}}x.array=yo;function yi(e){return{write:function(t,i,o){o.copy(t,i,0,e)},read:function(t,i){return t.slice(i,i+e)},byteSize:e,description:`Buffer(${e})`}}x.fixedSizeBuffer=yi;function lt(e,t=!1){const i=yi(e),o=t?e+4:e;return{write:function(r,a,n){oe.strict.equal(n.byteLength,e,`Uint8Array length ${n.byteLength} should match len ${e}`),t&&(Z.u32.write(r,a,e),a+=4);const s=H.Buffer.from(n);i.write(r,a,s)},read:function(r,a){if(t){const s=Z.u32.read(r,a);oe.strict.equal(s,e,"invalid byte size"),a+=4}const n=i.read(r,a);return Uint8Array.from(n)},byteSize:o,description:`Uint8Array(${e})`}}x.fixedSizeUint8Array=lt;x.uint8Array={toFixedFromData(e,t){const i=Z.u32.read(e,t);return(0,fi.logTrace)(`${this.description}[${i}]`),lt(i,!0)},toFixedFromValue(e){const t=e.byteLength;return lt(t,!0)},description:"Uint8Array"};x.collectionsTypeMap={Array:{beet:"array",isFixable:!0,sourcePack:le.BEET_PACKAGE,ts:"Array",arg:ue.BEET_TYPE_ARG_LEN},FixedSizeArray:{beet:"fixedSizeArray",isFixable:!1,sourcePack:le.BEET_PACKAGE,ts:"Array",arg:ue.BEET_TYPE_ARG_LEN},UniformFixedSizeArray:{beet:"uniformFixedSizeArray",isFixable:!1,sourcePack:le.BEET_PACKAGE,ts:"Array",arg:ue.BEET_TYPE_ARG_LEN},Buffer:{beet:"fixedSizeBuffer",isFixable:!1,sourcePack:le.BEET_PACKAGE,ts:"Buffer",arg:ue.BEET_TYPE_ARG_LEN},FixedSizeUint8Array:{beet:"fixedSizeUint8Array",isFixable:!1,sourcePack:le.BEET_PACKAGE,ts:"Uint8Array",arg:ue.BEET_TYPE_ARG_LEN},Uint8Array:{beet:"uint8Array",isFixable:!0,sourcePack:le.BEET_PACKAGE,ts:"Uint8Array",arg:ue.BEET_TYPE_ARG_LEN}};var P={};Object.defineProperty(P,"__esModule",{value:!0});P.compositesTypeMap=P.coption=P.coptionSome=P.coptionNone=P.isNoneBuffer=P.isSomeBuffer=void 0;const pe=q(),dt=w,Qt=w,mi=E,Zt=G,Si=0,bi=1;function gt(e,t){return e[t]===bi}P.isSomeBuffer=gt;function Bt(e,t){return e[t]===Si}P.isNoneBuffer=Bt;function pt(e){return(0,mi.logTrace)(`coptionNone(${e})`),{write:function(t,i,o){(0,pe.strict)(o==null,"coptionNone can only handle `null` values"),t[i]=Si},read:function(t,i){return(0,pe.strict)(Bt(t,i),"coptionNone can only handle `NONE` data"),null},byteSize:1,description:`COption<None(${e})>`}}P.coptionNone=pt;function ft(e){const t=1+e.byteSize,i={write:function(o,r,a){(0,dt.assertFixedSizeBeet)(e,`coption inner type ${e.description} needs to be fixed before calling write`),(0,pe.strict)(a!=null,"coptionSome cannot handle `null` values"),o[r]=bi,e.write(o,r+1,a)},read:function(o,r){return(0,dt.assertFixedSizeBeet)(e,`coption inner type ${e.description} needs to be fixed before calling read`),(0,pe.strict)(gt(o,r),"coptionSome can only handle `SOME` data"),e.read(o,r+1)},description:`COption<${e.description}>[1 + ${e.byteSize}]`,byteSize:t,inner:e};return(0,mi.logTrace)(i.description),i}P.coptionSome=ft;function mo(e){return{toFixedFromData(t,i){if(gt(t,i)){const o=(0,Zt.fixBeetFromData)(e,t,i+1);return ft(o)}else return(0,pe.strict)(Bt(t,i),`Expected ${t} to hold a COption`),pt(e.description)},toFixedFromValue(t){return t==null?pt(e.description):ft((0,Zt.fixBeetFromValue)(e,t))},description:`COption<${e.description}>`}}P.coption=mo;P.compositesTypeMap={option:{beet:"coption",isFixable:!0,sourcePack:Qt.BEET_PACKAGE,ts:"COption<Inner>",arg:dt.BEET_TYPE_ARG_INNER,pack:Qt.BEET_PACKAGE}};var yt={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.stringTypeMap=e.utf8String=e.fixedSizeUtf8String=void 0;const t=w,i=q(),o=Q,r=E,a=n=>({write:function(s,u,l){const p=H.Buffer.from(l,"utf8");i.strict.equal(p.byteLength,n,`${l} has invalid byte size`),o.u32.write(s,u,n),p.copy(s,u+4,0,n)},read:function(s,u){const l=o.u32.read(s,u);return i.strict.equal(l,n,"invalid byte size"),s.slice(u+4,u+4+n).toString("utf8")},elementByteSize:1,length:n,lenPrefixByteSize:4,byteSize:4+n,description:`Utf8String(4 + ${n})`});e.fixedSizeUtf8String=a,e.utf8String={toFixedFromData(n,s){const u=o.u32.read(n,s);return(0,r.logTrace)(`${this.description}[${u}]`),(0,e.fixedSizeUtf8String)(u)},toFixedFromValue(n){const s=H.Buffer.from(n).byteLength;return(0,e.fixedSizeUtf8String)(s)},description:"Utf8String"},e.stringTypeMap={fixedSizeString:{beet:"fixedSizeUtf8String",isFixable:!1,sourcePack:t.BEET_PACKAGE,ts:"string",arg:t.BEET_TYPE_ARG_LEN},string:{beet:"utf8String",isFixable:!0,sourcePack:t.BEET_PACKAGE,ts:"string"}}})(yt);var C={},O={},re={};Object.defineProperty(re,"__esModule",{value:!0});re.BeetReader=re.BeetWriter=void 0;const So=q();class bo{constructor(t){this.buf=H.Buffer.alloc(t),this._offset=0}get buffer(){return this.buf}get offset(){return this._offset}maybeResize(t){this._offset+t>this.buf.length&&So.strict.fail(`We shouldn't ever need to resize, but ${this._offset+t} > ${this.buf.length}`)}write(t,i){this.maybeResize(t.byteSize),t.write(this.buf,this._offset,i),this._offset+=t.byteSize}writeStruct(t,i){for(const[o,r]of i){const a=t[o];this.write(r,a)}}}re.BeetWriter=bo;class ho{constructor(t,i=0){this.buffer=t,this._offset=i}get offset(){return this._offset}read(t){const i=t.read(this.buffer,this._offset);return this._offset+=t.byteSize,i}readStruct(t){const i={};for(const[o,r]of t)i[o]=this.read(r);return i}}re.BeetReader=ho;Object.defineProperty(O,"__esModule",{value:!0});O.BeetArgsStruct=O.isBeetStruct=O.BeetStruct=void 0;const Xt=re,U=E;class X{constructor(t,i,o=X.description){if(this.fields=t,this.construct=i,this.description=o,this.byteSize=this.getByteSize(),U.logDebug.enabled){const r=t.map(([a,n])=>`${String(a)}: ${n.description} ${(0,U.beetBytes)(n)}`).join(`
  `);(0,U.logDebug)(`struct ${o} {
  ${r}
} ${(0,U.beetBytes)(this)}`)}}read(t,i){const[o]=this.deserialize(t,i);return o}write(t,i,o){const[r,a]=this.serialize(o);r.copy(t,i,0,a)}deserialize(t,i=0){U.logTrace.enabled&&((0,U.logTrace)("deserializing [%s] from %d bytes buffer",this.description,t.byteLength),(0,U.logTrace)(t),(0,U.logTrace)(t.toJSON().data));const o=new Xt.BeetReader(t,i),r=o.readStruct(this.fields);return[this.construct(r),o.offset]}serialize(t,i=this.byteSize){(0,U.logTrace)("serializing [%s] %o to %d bytes buffer",this.description,t,i);const o=new Xt.BeetWriter(i);return o.writeStruct(t,this.fields),[o.buffer,o.offset]}getByteSize(){return this.fields.reduce((t,[i,o])=>t+o.byteSize,0)}get type(){return X.TYPE}}O.BeetStruct=X;X.description="BeetStruct";X.TYPE="BeetStruct";function Ao(e){return e.type===X.TYPE}O.isBeetStruct=Ao;class ve extends X{constructor(t,i=ve.description){super(t,o=>o,i)}}O.BeetArgsStruct=ve;ve.description="BeetArgsStruct";var L={},wo=N&&N.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(L,"__esModule",{value:!0});L.FixableBeetArgsStruct=L.isFixableBeetStruct=L.FixableBeetStruct=void 0;const ei=G,he=O,ko=w,go=q(),nt=E,Bo=wo(ai),{brightBlack:To}=Bo.default;class R{constructor(t,i,o=R.description){this.fields=t,this.construct=i,this.description=o;let r=0;if(nt.logDebug.enabled){const a=t.map(([s,u])=>((0,ko.isFixedSizeBeet)(u)&&(r+=u.byteSize),`${s}: ${u.description} ${(0,nt.beetBytes)(u)}`)).join(`
  `),n=`> ${r} B`;(0,nt.logDebug)(`struct ${o} {
  ${a}
} ${To(n)}`)}}deserialize(t,i=0){return this.toFixedFromData(t,i).deserialize(t,i)}serialize(t,i){return this.toFixedFromValue(t).serialize(t,i)}toFixedFromData(t,i){let o=i;const r=new Array(this.fields.length);for(let a=0;a<this.fields.length;a++){const[n,s]=this.fields[a],u=(0,ei.fixBeetFromData)(s,t,o);r[a]=[n,u],o+=u.byteSize}return this.description!==R.description?new he.BeetStruct(r,this.construct,this.description):new he.BeetStruct(r,this.construct)}toFixedFromValue(t){const i=Object.keys(t),o=new Array(this.fields.length);for(let r=0;r<this.fields.length;r++){const[a,n]=this.fields[r];(0,go.strict)(i.includes(a),`Value with keys [ ${i} ] should include struct key '${a}' but doesn't.`);const s=t[a],u=(0,ei.fixBeetFromValue)(n,s);o[r]=[a,u]}return this.description!==R.description?new he.BeetStruct(o,this.construct,this.description):new he.BeetStruct(o,this.construct)}get type(){return R.TYPE}}L.FixableBeetStruct=R;R.description="FixableBeetStruct";R.TYPE="FixableBeetStruct";function Eo(e){return e.type===R.TYPE}L.isFixableBeetStruct=Eo;class ze extends R{constructor(t,i=ze.description){super(t,o=>o,i)}}L.FixableBeetArgsStruct=ze;ze.description="FixableBeetArgsStruct";var ee={};Object.defineProperty(ee,"__esModule",{value:!0});ee.unitTypeMap=ee.unit=void 0;const vo=w;ee.unit={write:function(e,t,i){},read:function(e,t){},byteSize:0,description:"unit"};ee.unitTypeMap={unit:{beet:"unit",isFixable:!1,sourcePack:vo.BEET_PACKAGE,ts:"void"}};Object.defineProperty(C,"__esModule",{value:!0});C.enumsTypeMap=C.dataEnum=C.uniformDataEnum=C.fixedScalarEnum=void 0;const J=w,K=Q,de=q(),zo=O,Fo=L,xo=ee;function ti(e,t){return t?`${e}`:e}function Mo(e){const t=Object.keys(e);return{write(i,o,r){const a=typeof r=="number",n=ti(r,a);if(t.includes(n)||de.strict.fail(`${r} should be a variant of the provided enum type, i.e. [ ${Object.values(e).join(", ")} ], but isn't`),a)K.u8.write(i,o,r);else{const s=e[n];K.u8.write(i,o,s)}},read(i,o){const r=K.u8.read(i,o),a=typeof r=="number",n=ti(r,a);return t.includes(n)||de.strict.fail(`${r} should be a of a variant of the provided enum type, i.e. [ ${Object.values(e).join(", ")} ], but isn't`),a?r:e[n]},byteSize:K.u8.byteSize,description:"Enum"}}C.fixedScalarEnum=Mo;function Po(e){return{write:function(t,i,o){K.u8.write(t,i,o.kind),e.write(t,i+1,o.data)},read:function(t,i){const o=K.u8.read(t,i),r=e.read(t,i+1);return{kind:o,data:r}},byteSize:1+e.byteSize,description:`UniformDataEnum<${e.description}>`}}C.uniformDataEnum=Po;function ii(e,t,i){return{write(o,r,a){K.u8.write(o,r,t),e.write(o,r+K.u8.byteSize,a)},read(o,r){const a=e.read(o,r+K.u8.byteSize);return{__kind:i,...a}},byteSize:e.byteSize+K.u8.byteSize,description:`EnumData<${e.description}>`}}function _o(e){for(const[t,i]of e)(0,de.strict)((0,zo.isBeetStruct)(i)||(0,Fo.isFixableBeetStruct)(i)||i===xo.unit,"dataEnum: variants must be a data beet struct or a scalar unit");return{toFixedFromData(t,i){const o=K.u8.read(t,i),r=e[o];(0,de.strict)(r!=null,`Discriminant ${o} out of range for ${e.length} variants`);const[a,n]=r,s=(0,J.isFixedSizeBeet)(n)?n:n.toFixedFromData(t,i+1);return ii(s,o,a)},toFixedFromValue(t){if(t.__kind==null){const l=Object.keys(t).join(", "),p=e.map(([d])=>d).join(", ");de.strict.fail(`Value with fields [ ${l} ] is missing __kind, which needs to be set to one of [ ${p} ]`)}const i=e.findIndex(([l])=>l===t.__kind);if(i<0){const l=e.map(([p])=>p).join(", ");de.strict.fail(`${t.__kind} is not a valid kind, needs to be one of [ ${l} ]`)}const o=e[i],{__kind:r,...a}=t,[n,s]=o,u=(0,J.isFixedSizeBeet)(s)?s:s.toFixedFromValue(a);return ii(u,i,n)},description:`DataEnum<${e.length} variants>`}}C.dataEnum=_o;C.enumsTypeMap={fixedScalarEnum:{beet:"fixedScalarEnum",isFixable:!1,sourcePack:J.BEET_PACKAGE,ts:"<TypeName>",arg:J.BEET_TYPE_ARG_INNER,pack:J.BEET_PACKAGE},dataEnum:{beet:"dataEnum",isFixable:!1,sourcePack:J.BEET_PACKAGE,ts:"DataEnum<Kind, Inner>",arg:J.BEET_TYPE_ARG_INNER,pack:J.BEET_PACKAGE}};var ne={};Object.defineProperty(ne,"__esModule",{value:!0});ne.aliasesTypeMap=ne.bytes=void 0;const hi=x;ne.bytes=hi.uint8Array;ne.aliasesTypeMap={bytes:hi.collectionsTypeMap.Uint8Array};var j={};Object.defineProperty(j,"__esModule",{value:!0});j.tuplesTypeMap=j.tuple=j.fixedSizeTuple=void 0;const oi=w,mt=q(),ri=G;function St(e){const t=e.length,i=e.map(a=>a.description),o=e.map(a=>a.byteSize),r=o.reduce((a,n)=>a+n,0);return{write:function(a,n,s){mt.strict.equal(s.length,t,`tuple value element size ${s.length} should match len ${t}`);let u=n;for(let l=0;l<t;l++){const p=s[l],d=e[l];d.write(a,u,p),u+=d.byteSize}},read:function(a,n){const s=[];let u=n;for(let l=0;l<t;l++){const p=e[l];s[l]=p.read(a,u),u+=p.byteSize}return s},byteSize:r,length:t,description:`FixedSizeTuple<${i.join(",")}>[ ${o.join(", ")} ]`}}j.fixedSizeTuple=St;function $o(e){const t=e.length,i=e.map(o=>o.description);return{toFixedFromData(o,r){let a=r;const n=new Array(t);for(let s=0;s<t;s++){const u=(0,ri.fixBeetFromData)(e[s],o,a);n[s]=u,a+=u.byteSize}return St(n)},toFixedFromValue(o){(0,mt.strict)(Array.isArray(o),`${o} should be an array of tuple values`),mt.strict.equal(o.length,t,`There should be ${t} tuple values, but there are ${o.length}`);const r=new Array(t);for(let a=0;a<o.length;a++){const n=(0,ri.fixBeetFromValue)(e[a],o[a]);r[a]=n}return St(r)},description:`Tuple<${i.join(",")}>`}}j.tuple=$o;j.tuplesTypeMap={Tuple:{beet:"tuple",isFixable:!0,sourcePack:oi.BEET_PACKAGE,ts:"[__tuple_elements__]"},FixedSizeTuple:{beet:"fixedSizeTuple",isFixable:!1,sourcePack:oi.BEET_PACKAGE,ts:"[__tuple_elements__]"}};var ae={};Object.defineProperty(ae,"__esModule",{value:!0});ae.mapsTypeMap=ae.map=void 0;const fe=w,bt=Q,Do=E,at=q();function Ae(e,t,i,o){const r=(0,fe.isFixedSizeBeet)(e),a=(0,fe.isFixedSizeBeet)(t);function n(){if(r&&a){const l=e.byteSize+t.byteSize;return{elementByteSize:l,byteSize:4+o*l}}else if(r){let l=0;for(const[d,S]of i.values())l+=S.byteSize;return{elementByteSize:e.byteSize+Math.ceil(l/o),byteSize:4+e.byteSize*o+l}}else if(a){let l=0;for(const[d,S]of i.values())l+=d.byteSize;return{elementByteSize:Math.ceil(l/o)+t.byteSize,byteSize:4+l+t.byteSize*o}}else{let l=0,p=0;for(const[S,b]of i.values())l+=S.byteSize,p+=b.byteSize;return{elementByteSize:Math.ceil(l/o+p/o),byteSize:4+l+p}}}const{elementByteSize:s,byteSize:u}=n();return{write:function(l,p,d){let S=p+4,b=0;for(const[c,M]of d.entries()){let k=r?e:null,z=a?t:null;if(k==null||z==null){const Y=i.get(c);(0,at.strict)(Y!=null,`Should be able to find beet els for ${(0,Do.stringify)(c)}, but could not`),k??(k=Y[0]),z??(z=Y[1])}k.write(l,S,c),S+=k.byteSize,z.write(l,S,M),S+=z.byteSize,b++}bt.u32.write(l,p,b),at.strict.equal(b,o,`Expected map to have size ${o}, but has ${b}.`)},read:function(l,p){const d=bt.u32.read(l,p);at.strict.equal(d,o,`Expected map to have size ${o}, but has ${d}.`);let S=p+4;const b=new Map;for(let c=0;c<d;c++){const M=r?e:e.toFixedFromData(l,S),k=M.read(l,S);S+=M.byteSize;const z=a?t:t.toFixedFromData(l,S),Y=z.read(l,S);S+=z.byteSize,b.set(k,Y)}return b},elementByteSize:s,byteSize:u,length:o,lenPrefixByteSize:4,description:`Map<${e.description}, ${t.description}>`}}function Wo(e,t){const i=(0,fe.isFixedSizeBeet)(e),o=(0,fe.isFixedSizeBeet)(t);return{toFixedFromData(r,a){const n=bt.u32.read(r,a);let s=a+4;if(i&&o)return Ae(e,t,new Map,n);const u=new Map;for(let l=0;l<n;l++){const p=i?e:e.toFixedFromData(r,s),d=p.read(r,s);s+=p.byteSize;const S=o?t:t.toFixedFromData(r,s);s+=S.byteSize,u.set(d,[p,S])}return Ae(e,t,u,n)},toFixedFromValue(r){const a=r.size;if(i&&o)return Ae(e,t,new Map,a);const n=new Map;for(const[s,u]of r){const l=i?e:e.toFixedFromValue(s),p=o?t:t.toFixedFromValue(u);n.set(s,[l,p])}return Ae(e,t,n,a)},description:`FixableMap<${e.description}, ${t.description}>`}}ae.map=Wo;ae.mapsTypeMap={Map:{beet:"map",isFixable:!0,sourcePack:fe.BEET_PACKAGE,ts:"Map"}};var se={};Object.defineProperty(se,"__esModule",{value:!0});se.setsTypeMap=se.set=void 0;const Tt=w,ht=Q,Co=E,st=q();function we(e,t,i){const o=(0,Tt.isFixedSizeBeet)(e);function r(){if(o){const s=e.byteSize;return{elementByteSize:s,byteSize:4+i*s}}else{let s=0;for(const l of t.values())s+=l.byteSize;return{elementByteSize:Math.ceil(s/i),byteSize:4+s}}}const{elementByteSize:a,byteSize:n}=r();return{write:function(s,u,l){let p=u+4,d=0;for(const S of l.keys()){let b=o?e:null;if(b==null){const c=t.get(S);(0,st.strict)(c!=null,`Should be able to find beet el for ${(0,Co.stringify)(S)}, but could not`),b??(b=c)}b.write(s,p,S),p+=b.byteSize,d++}ht.u32.write(s,u,d),st.strict.equal(d,i,`Expected set to have size ${i}, but has ${d}.`)},read:function(s,u){const l=ht.u32.read(s,u);st.strict.equal(l,i,`Expected set to have size ${i}, but has ${l}.`);let p=u+4;const d=new Set;for(let S=0;S<l;S++){const b=o?e:e.toFixedFromData(s,p),c=b.read(s,p);p+=b.byteSize,d.add(c)}return d},elementByteSize:a,byteSize:n,length:i,lenPrefixByteSize:4,description:`Set<${e.description}>`}}function Ko(e){const t=(0,Tt.isFixedSizeBeet)(e);return{toFixedFromData(i,o){const r=ht.u32.read(i,o);let a=o+4;if(t)return we(e,new Map,r);const n=new Map;for(let s=0;s<r;s++){const u=t?e:e.toFixedFromData(i,a),l=u.read(i,a);a+=u.byteSize,n.set(l,u)}return we(e,n,r)},toFixedFromValue(i){const o=i.size;if(t)return we(e,new Map,o);const r=new Map;for(const a of i){const n=t?e:e.toFixedFromValue(a);r.set(a,n)}return we(e,r,o)},description:`FixableSet<${e.description}>`}}se.set=Ko;se.setsTypeMap={Set:{beet:"set",isFixable:!0,sourcePack:Tt.BEET_PACKAGE,ts:"Set"}};(function(e){var t=N&&N.__createBinding||(Object.create?function(b,c,M,k){k===void 0&&(k=M);var z=Object.getOwnPropertyDescriptor(c,M);(!z||("get"in z?!c.__esModule:z.writable||z.configurable))&&(z={enumerable:!0,get:function(){return c[M]}}),Object.defineProperty(b,k,z)}:function(b,c,M,k){k===void 0&&(k=M),b[k]=c[M]}),i=N&&N.__exportStar||function(b,c){for(var M in b)M!=="default"&&!Object.prototype.hasOwnProperty.call(c,M)&&t(c,b,M)};Object.defineProperty(e,"__esModule",{value:!0}),e.supportedTypeMap=void 0;const o=x,r=P,a=Q,n=yt,s=C,u=ne,l=j,p=ae,d=ee,S=se;i(ne,e),i(x,e),i(P,e),i(C,e),i(ae,e),i(Q,e),i(se,e),i(yt,e),i(j,e),i(ee,e),i(G,e),i(re,e),i(O,e),i(L,e),i(w,e),e.supportedTypeMap={...o.collectionsTypeMap,...n.stringTypeMap,...r.compositesTypeMap,...s.enumsTypeMap,...a.numbersTypeMap,...u.aliasesTypeMap,...l.tuplesTypeMap,...p.mapsTypeMap,...S.setsTypeMap,...d.unitTypeMap}})(f);var Io=Object.defineProperty,No=(e,t,i)=>t in e?Io(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,y=(e,t,i)=>(No(e,typeof t!="symbol"?t+"":t,i),i);const Et=new f.BeetArgsStruct([["tradeFeeNumerator",f.u64],["tradeFeeDenominator",f.u64],["ownerTradeFeeNumerator",f.u64],["ownerTradeFeeDenominator",f.u64],["ownerWithdrawFeeNumerator",f.u64],["ownerWithdrawFeeDenominator",f.u64],["hostFeeNumerator",f.u64],["hostFeeDenominator",f.u64]],"FeesInfo"),vt=new f.BeetArgsStruct([["curveType",f.u8],["curveParameters",f.uniformFixedSizeArray(f.u8,32)]],"CurveInfo"),At=[135,144,215,161,140,125,41,96];class W{constructor(t,i,o,r,a,n,s,u,l,p,d,S,b,c){this.isInitialized=t,this.bumpSeed=i,this.tokenProgramId=o,this.tokenA=r,this.tokenB=a,this.poolMint=n,this.tokenAMint=s,this.tokenBMint=u,this.poolFeeAccount=l,this.fees=p,this.curve=d,this.swapPolicy=S,this.addLiquidityPolicy=b,this.reserved=c}static fromArgs(t){return new W(t.isInitialized,t.bumpSeed,t.tokenProgramId,t.tokenA,t.tokenB,t.poolMint,t.tokenAMint,t.tokenBMint,t.poolFeeAccount,t.fees,t.curve,t.swapPolicy,t.addLiquidityPolicy,t.reserved)}static fromAccountInfo(t,i=0){return W.deserialize(t.data,i)}static async fromAccountAddress(t,i,o){const r=await t.getAccountInfo(i,o);if(r==null)throw new Error(`Unable to find TokenSwap account at ${i}`);return W.fromAccountInfo(r,0)[0]}static gpaBuilder(t=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return v.GpaBuilder.fromStruct(t,ke)}static deserialize(t,i=0){return ke.deserialize(t,i)}serialize(){return ke.serialize({accountDiscriminator:At,...this})}static byteSize(t){const i=W.fromArgs(t);return ke.toFixedFromValue({accountDiscriminator:At,...i}).byteSize}static async getMinimumBalanceForRentExemption(t,i,o){return i.getMinimumBalanceForRentExemption(W.byteSize(t),o)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,swapPolicy:this.swapPolicy,addLiquidityPolicy:this.addLiquidityPolicy,reserved:this.reserved}}}const ke=new f.FixableBeetStruct([["accountDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["isInitialized",f.bool],["bumpSeed",f.u8],["tokenProgramId",v.publicKey],["tokenA",v.publicKey],["tokenB",v.publicKey],["poolMint",v.publicKey],["tokenAMint",v.publicKey],["tokenBMint",v.publicKey],["poolFeeAccount",v.publicKey],["fees",Et],["curve",vt],["swapPolicy",f.coption(v.publicKey)],["addLiquidityPolicy",f.coption(v.publicKey)],["reserved",f.uniformFixedSizeArray(f.u8,64)]],W.fromArgs,"TokenSwap"),B=new Map,T=new Map;class Fe extends Error{constructor(){super("Swap account already in use"),y(this,"code",6e3),y(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Fe)}}B.set(6e3,()=>new Fe);T.set("AlreadyInUse",()=>new Fe);class xe extends Error{constructor(){super("Invalid program address generated from bump seed and key"),y(this,"code",6001),y(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,xe)}}B.set(6001,()=>new xe);T.set("InvalidProgramAddress",()=>new xe);class Me extends Error{constructor(){super("Input account owner is not the program address"),y(this,"code",6002),y(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Me)}}B.set(6002,()=>new Me);T.set("InvalidOwner",()=>new Me);class Pe extends Error{constructor(){super("Output pool account owner cannot be the program address"),y(this,"code",6003),y(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Pe)}}B.set(6003,()=>new Pe);T.set("InvalidOutputOwner",()=>new Pe);class _e extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),y(this,"code",6004),y(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_e)}}B.set(6004,()=>new _e);T.set("ExpectedMint",()=>new _e);class $e extends Error{constructor(){super("Deserialized account is not an SPL Token account"),y(this,"code",6005),y(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$e)}}B.set(6005,()=>new $e);T.set("ExpectedAccount",()=>new $e);class De extends Error{constructor(){super("Input token account empty"),y(this,"code",6006),y(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,De)}}B.set(6006,()=>new De);T.set("EmptySupply",()=>new De);class We extends Error{constructor(){super("Pool token mint has a non-zero supply"),y(this,"code",6007),y(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,We)}}B.set(6007,()=>new We);T.set("InvalidSupply",()=>new We);class Ce extends Error{constructor(){super("Token account has a delegate"),y(this,"code",6008),y(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ce)}}B.set(6008,()=>new Ce);T.set("InvalidDelegate",()=>new Ce);class Ke extends Error{constructor(){super("InvalidInput"),y(this,"code",6009),y(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ke)}}B.set(6009,()=>new Ke);T.set("InvalidInput",()=>new Ke);class Ie extends Error{constructor(){super("Address of the provided swap token account is incorrect"),y(this,"code",6010),y(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ie)}}B.set(6010,()=>new Ie);T.set("IncorrectSwapAccount",()=>new Ie);class Ne extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),y(this,"code",6011),y(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ne)}}B.set(6011,()=>new Ne);T.set("IncorrectPoolMint",()=>new Ne);class Re extends Error{constructor(){super("InvalidOutput"),y(this,"code",6012),y(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Re)}}B.set(6012,()=>new Re);T.set("InvalidOutput",()=>new Re);class Oe extends Error{constructor(){super("General calculation failure due to overflow or underflow"),y(this,"code",6013),y(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Oe)}}B.set(6013,()=>new Oe);T.set("CalculationFailure",()=>new Oe);class Ge extends Error{constructor(){super("Invalid instruction"),y(this,"code",6014),y(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ge)}}B.set(6014,()=>new Ge);T.set("InvalidInstruction",()=>new Ge);class qe extends Error{constructor(){super("Swap input token accounts have the same mint"),y(this,"code",6015),y(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,qe)}}B.set(6015,()=>new qe);T.set("RepeatedMint",()=>new qe);class Ue extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),y(this,"code",6016),y(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ue)}}B.set(6016,()=>new Ue);T.set("ExceededSlippage",()=>new Ue);class Le extends Error{constructor(){super("Token account has a close authority"),y(this,"code",6017),y(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Le)}}B.set(6017,()=>new Le);T.set("InvalidCloseAuthority",()=>new Le);class je extends Error{constructor(){super("Pool token mint has a freeze authority"),y(this,"code",6018),y(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,je)}}B.set(6018,()=>new je);T.set("InvalidFreezeAuthority",()=>new je);class Ve extends Error{constructor(){super("Pool fee token account incorrect"),y(this,"code",6019),y(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ve)}}B.set(6019,()=>new Ve);T.set("IncorrectFeeAccount",()=>new Ve);class Ye extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),y(this,"code",6020),y(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ye)}}B.set(6020,()=>new Ye);T.set("ZeroTradingTokens",()=>new Ye);class Je extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),y(this,"code",6021),y(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Je)}}B.set(6021,()=>new Je);T.set("FeeCalculationFailure",()=>new Je);class He extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),y(this,"code",6022),y(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,He)}}B.set(6022,()=>new He);T.set("ConversionFailure",()=>new He);class Qe extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),y(this,"code",6023),y(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Qe)}}B.set(6023,()=>new Qe);T.set("InvalidFee",()=>new Qe);class Ze extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),y(this,"code",6024),y(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ze)}}B.set(6024,()=>new Ze);T.set("IncorrectTokenProgramId",()=>new Ze);class Xe extends Error{constructor(){super("The provided curve type is not supported by the program owner"),y(this,"code",6025),y(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xe)}}B.set(6025,()=>new Xe);T.set("UnsupportedCurveType",()=>new Xe);class et extends Error{constructor(){super("The provided curve parameters are invalid"),y(this,"code",6026),y(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,et)}}B.set(6026,()=>new et);T.set("InvalidCurve",()=>new et);class tt extends Error{constructor(){super("The operation cannot be performed on the given curve"),y(this,"code",6027),y(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,tt)}}B.set(6027,()=>new tt);T.set("UnsupportedCurveOperation",()=>new tt);const Ro=new f.BeetArgsStruct([["instructionDiscriminator",f.uniformFixedSizeArray(f.u8,8)]],"CloseInstructionArgs"),Oo=[98,165,201,177,108,65,206,96];function Go(e,t=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[i]=Ro.serialize({instructionDiscriminator:Oo}),o=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.payer,isWritable:!0,isSigner:!0},{pubkey:e.tokenProgram??I,isWritable:!1,isSigner:!1},{pubkey:e.systemProgram??ct.programId,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const r of e.anchorRemainingAccounts)o.push(r);return new V({programId:t,keys:o,data:i})}const qo=new f.BeetArgsStruct([["instructionDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["poolTokenAmount",f.u64],["maximumTokenAAmount",f.u64],["maximumTokenBAmount",f.u64]],"DepositAllTokenTypesInstructionArgs"),Uo=[32,95,69,60,75,79,205,238];function Lo(e,t,i=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=qo.serialize({instructionDiscriminator:Uo,...t}),r=[{pubkey:e.proofRequest??i,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userTokenA,isWritable:!0,isSigner:!1},{pubkey:e.userTokenB,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??I,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const a of e.anchorRemainingAccounts)r.push(a);return new V({programId:i,keys:r,data:o})}const jo=new f.BeetArgsStruct([["instructionDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["sourceTokenAmount",f.u64],["minimumPoolTokenAmount",f.u64]],"DepositSingleTokenTypeInstructionArgs"),Vo=[175,0,152,41,199,0,148,43];function Yo(e,t,i=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=jo.serialize({instructionDiscriminator:Vo,...t}),r=[{pubkey:e.proofRequest??i,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??I,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const a of e.anchorRemainingAccounts)r.push(a);return new V({programId:i,keys:r,data:o})}const Jo=new f.FixableBeetArgsStruct([["instructionDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["feesInput",Et],["curveInput",vt],["swapPolicy",f.coption(v.publicKey)],["addLiquidityPolicy",f.coption(v.publicKey)]],"InitializeInstructionArgs"),Ho=[175,175,109,31,13,152,155,237];function Qo(e,t,i=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=Jo.serialize({instructionDiscriminator:Ho,...t}),r=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.tokenA,isWritable:!0,isSigner:!1},{pubkey:e.tokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??I,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const a of e.anchorRemainingAccounts)r.push(a);return new V({programId:i,keys:r,data:o})}const Zo=new f.BeetArgsStruct([["instructionDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["amountIn",f.u64],["minimumAmountOut",f.u64]],"SwapInstructionArgs"),Xo=[248,198,158,145,225,117,135,200];function er(e,t,i=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=Zo.serialize({instructionDiscriminator:Xo,...t}),r=[{pubkey:e.proofRequest??i,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userSource,isWritable:!0,isSigner:!1},{pubkey:e.userDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolSource,isWritable:!0,isSigner:!1},{pubkey:e.poolDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.hostFeeAccount??i,isWritable:!1,isSigner:!1},{pubkey:e.tokenProgram??I,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const a of e.anchorRemainingAccounts)r.push(a);return new V({programId:i,keys:r,data:o})}const tr=new f.BeetArgsStruct([["instructionDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["poolTokenAmount",f.u64],["minimumTokenAAmount",f.u64],["minimumTokenBAmount",f.u64]],"WithdrawAllTokenTypesInstructionArgs"),ir=[189,254,156,174,210,9,164,216];function or(e,t,i=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=tr.serialize({instructionDiscriminator:ir,...t}),r=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??I,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const a of e.anchorRemainingAccounts)r.push(a);return new V({programId:i,keys:r,data:o})}const rr=new f.BeetArgsStruct([["instructionDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["destinationTokenAmount",f.u64],["maximumPoolTokenAmount",f.u64]],"WithdrawSingleTokenTypeInstructionArgs"),nr=[111,171,21,77,237,181,241,56];function ar(e,t,i=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=rr.serialize({instructionDiscriminator:nr,...t}),r=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??I,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const a of e.anchorRemainingAccounts)r.push(a);return new V({programId:i,keys:r,data:o})}var Ai=(e=>(e[e.ConstantProduct=0]="ConstantProduct",e[e.ConstantPrice=1]="ConstantPrice",e[e.Offset=2]="Offset",e))(Ai||{});f.fixedScalarEnum(Ai);var wi=(e=>(e[e.Floor=0]="Floor",e[e.Ceiling=1]="Ceiling",e))(wi||{});f.fixedScalarEnum(wi);var ki=(e=>(e[e.AtoB=0]="AtoB",e[e.BtoA=1]="BtoA",e))(ki||{});f.fixedScalarEnum(ki);const sr="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",cr=new A(sr);class ur{constructor(t){y(this,"programId",cr),this.provider=t}get connection(){return this.provider.connection}swapAuthority(t){return A.findProgramAddressSync([t.toBuffer()],this.programId)[0]}async closeTokenSwap(t,i){const o=new te,r=this.provider.publicKey,a=this.swapAuthority(t.tokenSwap),n=await this.load(t.tokenSwap),s=Vt(n.tokenAMint,r),u=Vt(n.tokenBMint,r);return await this.handleMissingTokenAccount(o,s,n.tokenAMint),await this.handleMissingTokenAccount(o,u,n.tokenBMint),o.add(Go({payer:r,tokenSwap:t.tokenSwap,authority:a,destTokenA:s,destTokenB:u,swapTokenA:n.tokenA,swapTokenB:n.tokenB})),{signature:await this.provider.sendAndConfirm(o,[],i)}}async createTokenSwap(t,i){const o=new te,r=t.tokenSwap??_i.generate(),a=Array.from({length:32}),n=Array.from(t.curveParameters??[]);for(let d=0;d<n.length;d++)a[d]=n[d];const s={curveType:t.curveType,curveParameters:a},u=this.getTokenSwapSpace(s),l=await this.connection.getMinimumBalanceForRentExemption(u);o.add(ct.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:r.publicKey,programId:this.programId,lamports:l,space:u})),o.add(Qo({authority:this.swapAuthority(r.publicKey),tokenSwap:r.publicKey,destination:t.destination,poolMint:t.poolMint,poolFee:t.poolFee,tokenA:t.tokenA,tokenB:t.tokenB},{feesInput:{tradeFeeNumerator:new F(t.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new F(t.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new F(t.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new F(t.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new F(t.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new F(t.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new F(t.fees.hostFeeNumerator.toString()),hostFeeDenominator:new F(t.fees.hostFeeDenominator.toString())},curveInput:s,swapPolicy:t.swapPolicy??null,addLiquidityPolicy:t.addLiquidityPolicy??null}));const p=await this.provider.sendAndConfirm(o,[r],i);return{tokenSwap:r.publicKey,signature:p}}getTokenSwapSpace(t){return W.byteSize({bumpSeed:0,curve:t,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,poolFeeAccount:A.default,poolMint:A.default,tokenA:A.default,tokenAMint:A.default,tokenB:A.default,tokenBMint:A.default,tokenProgramId:A.default,swapPolicy:A.default,addLiquidityPolicy:A.default,reserved:[]})}async swap(t,i){const o=new te;return await this.handleMissingTokenAccount(o,t.userDestination,t.destinationTokenMint),await this.handleWrappedSol({tx:o,amount:t.amountIn,userSource:t.userSource,sourceTokenMint:t.sourceTokenMint}),o.add(er({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:t.userSource,userDestination:t.userDestination,tokenSwap:t.tokenSwap,poolFee:t.poolFee,poolMint:t.poolMint,poolSource:t.poolSource,poolDestination:t.poolDestination,hostFeeAccount:t.hostFeeAccount,proofRequest:t.proofRequest},{amountIn:new F(t.amountIn.toString()),minimumAmountOut:new F(t.minimumAmountOut.toString())})),this.unwrapSol(o,t.userDestination,t.destinationTokenMint),this.provider.sendAndConfirm(o,[],i)}async depositAllTokenTypes(t,i){const o=new te;return await this.handleMissingTokenAccount(o,t.destination,t.poolMint),await this.handleWrappedSol({tx:o,amount:t.maximumTokenA,userSource:t.userTokenA,sourceTokenMint:t.tokenAMint}),await this.handleWrappedSol({tx:o,amount:t.maximumTokenB,userSource:t.userTokenB,sourceTokenMint:t.tokenBMint}),o.add(Lo({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,destination:t.destination,userTokenA:t.userTokenA,userTokenB:t.userTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB,proofRequest:t.proofRequest},{poolTokenAmount:new F(t.poolTokenAmount.toString()),maximumTokenAAmount:new F(t.maximumTokenA.toString()),maximumTokenBAmount:new F(t.maximumTokenB.toString())})),this.provider.sendAndConfirm(o,[],i)}async withdrawAllTokenTypes(t,i){const o=new te;return await this.handleMissingTokenAccount(o,t.destTokenA,t.tokenAMint),await this.handleMissingTokenAccount(o,t.destTokenB,t.tokenBMint),o.add(or({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destTokenA:t.destTokenA,destTokenB:t.destTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new F(t.poolTokenAmount.toString()),minimumTokenAAmount:new F(t.minimumTokenA.toString()),minimumTokenBAmount:new F(t.minimumTokenB.toString())})),this.unwrapSol(o,t.destTokenA,t.tokenAMint),this.unwrapSol(o,t.destTokenB,t.tokenBMint),this.provider.sendAndConfirm(o,[],i)}async depositSingleTokenTypeExactAmountIn(t,i){const o=new te;return await this.handleMissingTokenAccount(o,t.destination,t.poolMint),await this.handleWrappedSol({tx:o,amount:t.sourceTokenAmount,userSource:t.source,sourceTokenMint:t.sourceTokenMint}),o.add(Yo({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB,proofRequest:t.proofRequest},{sourceTokenAmount:new F(t.sourceTokenAmount.toString()),minimumPoolTokenAmount:new F(t.minimumPoolTokenAmount.toString())})),this.provider.sendAndConfirm(o,[],i)}async withdrawSingleTokenTypeExactAmountOut(t,i){const o=new te;return await this.handleMissingTokenAccount(o,t.destination,t.destinationTokenMint),o.add(ar({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{destinationTokenAmount:new F(t.destinationTokenAmount.toString()),maximumPoolTokenAmount:new F(t.maximumPoolTokenAmount.toString())})),this.unwrapSol(o,t.destination,t.destinationTokenMint),this.provider.sendAndConfirm(o,[],i)}async load(t,i){return W.fromAccountAddress(this.provider.connection,new A(t),i)}async loadAll(t={}){const i=W.gpaBuilder().addFilter("accountDiscriminator",At);return t.noData&&(i.config.dataSlice={offset:0,length:0}),t.tokenProgramId&&i.addFilter("tokenProgramId",new A(t.tokenProgramId)),t.poolMint&&i.addFilter("poolMint",new A(t.poolMint)),t.tokenAMint&&i.addFilter("tokenAMint",new A(t.tokenAMint)),t.tokenBMint&&i.addFilter("tokenBMint",new A(t.tokenBMint)),(await i.run(this.provider.connection)).map(({pubkey:o,account:r})=>({pubkey:o,data:t.noData?null:W.fromAccountInfo(r)[0]}))}unwrapSol(t,i,o){o&&o.toBase58()===Ot.toBase58()&&t.add(Qi(i,this.provider.publicKey,this.provider.publicKey))}async handleMissingTokenAccount(t,i,o){try{await Gt(this.connection,i)}catch(r){(r instanceof qt||r instanceof Ut)&&o&&t.add(Lt(this.provider.publicKey,i,this.provider.publicKey,o))}}async handleWrappedSol(t){var i;if(t.sourceTokenMint&&((i=t.sourceTokenMint)==null?void 0:i.toBase58())===Ot.toBase58()){let o=0;try{if((await Xi(t.sourceTokenMint,this.provider.publicKey)).toBase58()!==t.userSource.toBase58())return;const a=await Gt(this.connection,t.userSource);o=Number(a.amount)}catch(a){(a instanceof qt||a instanceof Ut)&&t.tx.add(Lt(this.provider.publicKey,t.userSource,this.provider.publicKey,t.sourceTokenMint))}const r=Number(t.amount);t.amount>o&&t.tx.add(ct.transfer({fromPubkey:this.provider.publicKey,toPubkey:t.userSource,lamports:r-o}),eo(t.userSource))}}}const ni=[135,144,215,161,140,125,41,96];class ie{constructor(t,i,o,r,a,n,s,u,l,p,d,S){this.isInitialized=t,this.bumpSeed=i,this.tokenProgramId=o,this.tokenA=r,this.tokenB=a,this.poolMint=n,this.tokenAMint=s,this.tokenBMint=u,this.poolFeeAccount=l,this.fees=p,this.curve=d,this.policy=S}static fromArgs(t){return new ie(t.isInitialized,t.bumpSeed,t.tokenProgramId,t.tokenA,t.tokenB,t.poolMint,t.tokenAMint,t.tokenBMint,t.poolFeeAccount,t.fees,t.curve,t.policy)}static fromAccountInfo(t,i=0){return ie.deserialize(t.data,i)}static async fromAccountAddress(t,i,o){const r=await t.getAccountInfo(i,o);if(r==null)throw new Error(`Unable to find TokenSwap account at ${i}`);return ie.fromAccountInfo(r,0)[0]}static gpaBuilder(t=new A("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return v.GpaBuilder.fromStruct(t,ge)}static deserialize(t,i=0){return ge.deserialize(t,i)}serialize(){return ge.serialize({accountDiscriminator:ni,...this})}static byteSize(t){const i=ie.fromArgs(t);return ge.toFixedFromValue({accountDiscriminator:ni,...i}).byteSize}static async getMinimumBalanceForRentExemption(t,i,o){return i.getMinimumBalanceForRentExemption(ie.byteSize(t),o)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const ge=new f.FixableBeetStruct([["accountDiscriminator",f.uniformFixedSizeArray(f.u8,8)],["isInitialized",f.bool],["bumpSeed",f.u8],["tokenProgramId",v.publicKey],["tokenA",v.publicKey],["tokenB",v.publicKey],["poolMint",v.publicKey],["tokenAMint",v.publicKey],["tokenBMint",v.publicKey],["poolFeeAccount",v.publicKey],["fees",Et],["curve",vt],["policy",f.coption(v.publicKey)]],ie.fromArgs,"TokenSwap");var lr=(e=>(e[e.ASC=0]="ASC",e[e.DESC=1]="DESC",e))(lr||{});const yr=$i("swap",()=>{const e=Di(),t=Wi(),i=Ci(),o=Ki(),{publicKey:r}=Ii(),{notify:a}=Ni(),n=Ri(()=>new ur(new Kt(e.connection,o.value??{publicKey:Oi.default},Kt.defaultOptions()))),s=ce({}),u=ce([]),l=ce([]),p=ce([]),d=ce(),S=It("token-a",""),b=It("token-b",""),c=Gi({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:Nt,to:Nt,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:M,tokens:k}=qi();M(Ui),D(k,()=>{if(k.value.length>=2){const m=k.value.find(g=>g.mint===S.value)??k.value[0];let h=k.value.find(g=>g.mint===b.value)??k.value[1];if(c.from=k.value.find(g=>g.mint===S.value)??k.value[0],c.to=k.value.find(g=>g.mint===b.value)??k.value[1],m===h){const g=k.value.find(_=>_.mint!==m.mint);g&&(h=g)}c.from=m,c.to=h}},{immediate:!0}),D(()=>c.from,()=>{c.from&&(S.value=c.from.mint)}),D(()=>c.to,()=>{c.to&&(b.value=c.to.mint)});const z=ot(async()=>{c.loading=!0;try{console.log("swapClient ================: ",n.value),u.value=await n.value.loadAll(),console.log("swaps ================: ",u.value)}catch(m){console.log(m),u.value=[]}finally{c.loading=!1}},400);D([o,()=>e.cluster],async m=>{z()?.then(),m||Bi()},{immediate:!0});const Y=ot(async()=>{if(r.value&&l.value.length>0){const m={};for(const h of l.value)try{const g=await rt(h.data.poolMint,r.value),_=await Li(e.connection,g);m[h.data.poolMint.toBase58()]=Number(_.amount),console.log("userAcc === ",_)}catch{}s.value=m}},500);D([r,l],Y,{immediate:!0});const it=ce(!1),ye=ot(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!d.value){it.value=!0;try{const m=await ji(e.connection,n.value.swapAuthority(d.value.pubkey)),h={};for(const _ of m)h[`${_.mint}`]=_.amount;c.poolBalance=h;const g=await Vi(e.connection,d.value.data.poolMint);c.poolTokenSupply=Number(g.supply),console.log("[Pool Balance] poolMint",g),console.log("[Pool Balance]",c.poolBalance),console.log("[Pool Balance] poolTokenSupply",c.poolTokenSupply)}catch(m){console.log("[Pool Balance] error",m)}finally{it.value=!1}}},500);setInterval(ye,6e4);function gi(m){d.value=m,console.log("setTokenSwap: ",d.value)}D([u,()=>i.servicePolicy],async()=>{console.log("tokenSwapsAll: ",u.value),l.value=u.value.filter(m=>!!i.servicePolicy.find(h=>h.pubkey.toBase58()===m.data.swapPolicy?.toBase58())&&!!i.servicePolicy.find(h=>h.pubkey.toBase58()===m.data.addLiquidityPolicy?.toBase58())&&!!t.tokenByMint(m.data.tokenAMint.toBase58())&&!!t.tokenByMint(m.data.tokenBMint.toBase58()))},{immediate:!0}),D([l,()=>c.from?.mint,()=>c.to?.mint,()=>i.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",l.value),l.value&&c.from?.mint&&c.to?.mint&&c.from.mint!==c.to.mint&&i.servicePolicy.length)if(p.value=l.value.filter(m=>{const h=m.data?.tokenAMint.toBase58(),g=m.data?.tokenBMint.toBase58();return h===c.from.mint&&g===c.to.mint||h===c.to.mint&&g===c.from.mint}),p.value.length){if(p.value.length>1){const m=p.value.find(h=>i.state.certificates?.find(g=>g.data?.policy.toBase58()===h.data.swapPolicy?.toBase58()||g.data?.policy.toBase58()===h.data.addLiquidityPolicy?.toBase58()));m&&(d.value=m)}d.value=p.value[0]}else d.value=void 0;else p.value=[],d.value=void 0,i.setContractPolicy("","swap"),i.setContractPolicy("","liquidity"),c.poolBalance={}},{immediate:!0}),D([d],async()=>{console.log("Token SWAP: ",d.value),i.setContractPolicy(d.value?.data.swapPolicy?.toBase58()??"","swap"),i.setContractPolicy(d.value?.data.addLiquidityPolicy?.toBase58()??"","liquidity"),d.value&&(ye(),d.value.data.tokenAMint.toBase58()===c.from.mint?c.direction=0:c.direction=1)},{immediate:!0});function Bi(){c.loading=!1,c.slippageDialog=!1,c.poolBalance={},c.poolTokenSupply=0}D([()=>c.direction,()=>c.from.amount,()=>c.poolBalance],async()=>{const m=Number(c.from.amount??0),h=Rt(Number(c.poolBalance[c.from.mint]??0),c.from.decimals),g=Rt(Number(c.poolBalance[c.to.mint]??0),c.to.decimals),_=1-c.fees.ownerTrade-c.fees.trade;if(m===0||Number.isNaN(m)){c.to.amount=0,c.rate=Number(g)/Number(h)*_,c.impact=0,c.minimumReceived=0;return}const $=g-h*g/(h+m*_);c.rate=m?$/m:g/h,c.to.amount=$?Number(Yi($,c.to.decimals)):0,c.impact=m?1-$/m/_/(g/h):0,c.minimumReceived=Se(c.to.amount-c.to.amount*c.slippage,c.to.decimals)},{immediate:!0});async function Ti(){if(!i.certificateValid)return Ji();if(!d.value||!r.value){console.log("Pool is not selected...");return}o.value.publicKey||a({type:"info",message:"Please connect your wallet first"});const h=Number(Se(c.from.amount??0,c.from.decimals)),g=Number(Se(i.tokenBalance(c.from.mint)??0,c.from.decimals)),_=Number(Se(c.to.amount??0,c.to.decimals));if(h>g){a({type:"negative",message:"Insufficient balance."});return}try{c.swapping=!0;const $=c.direction===0?d.value.data.tokenAMint:d.value.data.tokenBMint,me=c.direction===0?d.value.data.tokenBMint:d.value.data.tokenAMint,xt=c.direction===0?d.value.data.tokenA:d.value.data.tokenB,Mt=c.direction===0?d.value.data.tokenB:d.value.data.tokenA;console.log("userSourceMint = ",$.toBase58()),console.log("userDestinationMint = ",me.toBase58()),console.log("userSourceMint = ",$.toBase58()),console.log("userDestinationMint = ",me.toBase58());const Pt=await rt($,o.value.publicKey),_t=await rt(me,o.value.publicKey),$t=h;console.log("toAmount = ",_),console.log("slippage = ",c.slippage),console.log("slippage 2 = ",_*c.slippage);const Dt=n.value.swapAuthority(d.value.pubkey);console.log("proofRequest = ",i.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",Dt),console.log("tokenSwap = ",d.value.pubkey.toBase58()),console.log("userSource = ",Pt.toBase58()),console.log("userDestination = ",_t.toBase58()),console.log("poolSource = ",xt.toBase58()),console.log("poolDestination = ",Mt.toBase58()),console.log("poolMint = ",d.value.data.poolMint.toBase58()),console.log("poolFee = ",d.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",$t),console.log("minimumAmountOut = ",c.minimumReceived);const zi=await n.value.swap({proofRequest:i.certificate?.pubkey,authority:Dt,tokenSwap:d.value.pubkey,userSource:Pt,userDestination:_t,poolSource:xt,poolDestination:Mt,poolMint:d.value.data.poolMint,poolFee:d.value.data.poolFeeAccount,amountIn:$t,minimumAmountOut:c.minimumReceived,sourceTokenMint:$,destinationTokenMint:me},{commitment:"confirmed"});a({message:"Transaction confirmed",type:"positive",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${zi}?cluster=${e.cluster}`,onClick:()=>!1}]}),zt()}catch($){console.log($),console.error($.logs),`${$}`.includes("User rejected the request")||a({type:"negative",message:`${$}`})}finally{c.swapping=!1}}function Ei(){const{from:m,to:h}=c;c.rate=0,c.to={...m,amount:void 0},c.from={...h,amount:void 0},c.direction=c.direction===0?1:0}function vi(){c.slippageDialog=!1}function zt(){ye(),c.from.amount=void 0,c.to.amount=void 0}D(()=>o.value?.publicKey,m=>{m||zt()}),D(()=>c.to,m=>{m.amount&&(m.amount=void 0)});function Ft(m){return{host:be(m.fees.hostFeeNumerator,m.fees.hostFeeDenominator),trade:be(m.fees.tradeFeeNumerator,m.fees.tradeFeeDenominator),ownerTrade:be(m.fees.ownerTradeFeeNumerator,m.fees.ownerTradeFeeDenominator),ownerWithdraw:be(m.fees.ownerWithdrawFeeNumerator,m.fees.ownerWithdrawFeeDenominator)}}return D(d,m=>{if(!m)return;const h=Ft(m.data);c.fees.host=h.host,c.fees.trade=h.trade,c.fees.ownerTrade=h.ownerTrade,c.fees.ownerWithdraw=h.ownerWithdraw,console.log("fees ==== ",c.fees)}),{state:c,tokenSwapsAllFiltered:l,tokenSwaps:p,tokenSwap:d,swapClient:n,loadingPoolTokens:it,loadPoolTokenAccounts:ye,setTokenSwap:gi,closeSlippage:vi,changeDirection:Ei,swapSubmit:Ti,getPoolFee:Ft,init:z,tokenAMint:S,tokenBMint:b,userPoolsTokens:s,reloadUserLP:Y}});export{lr as S,Ai as k,yr as u};
