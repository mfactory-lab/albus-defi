import{k as i,aT as T,P as m,m as B,aG as Oe,S as Re,N as k,n as E,q as F,Q as Ye,o as Ge,U as Ue,V as pe,j as Te,Y as Ae,X as Je,Z as M,a1 as D,W as Ve,s as qe,u as Le,w as Qe,x as je,y as Ze,z as Xe,v as be,H as ve,F as x,A as He,aU as $e,aV as _e,B as b,aW as et,aX as W,aY as N,aZ as tt,aj as ot,L as nt}from"./index-296f0727.js";import{g as rt,T as it,a as at,c as st,j as ct,b as Be}from"./AppDescriptionTop-75127029.js";var ut=Object.defineProperty,lt=(t,e,n)=>e in t?ut(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,r=(t,e,n)=>(lt(t,typeof e!="symbol"?e+"":e,n),n);const Ee=new i.BeetArgsStruct([["tradeFeeNumerator",i.u64],["tradeFeeDenominator",i.u64],["ownerTradeFeeNumerator",i.u64],["ownerTradeFeeDenominator",i.u64],["ownerWithdrawFeeNumerator",i.u64],["ownerWithdrawFeeDenominator",i.u64],["hostFeeNumerator",i.u64],["hostFeeDenominator",i.u64]],"FeesInfo"),Fe=new i.BeetArgsStruct([["curveType",i.u8],["curveParameters",i.uniformFixedSizeArray(i.u8,32)]],"CurveInfo"),de=[135,144,215,161,140,125,41,96];class S{constructor(e,n,c,a,d,w,h,u,o,I,g,v){this.isInitialized=e,this.bumpSeed=n,this.tokenProgramId=c,this.tokenA=a,this.tokenB=d,this.poolMint=w,this.tokenAMint=h,this.tokenBMint=u,this.poolFeeAccount=o,this.fees=I,this.curve=g,this.policy=v}static fromArgs(e){return new S(e.isInitialized,e.bumpSeed,e.tokenProgramId,e.tokenA,e.tokenB,e.poolMint,e.tokenAMint,e.tokenBMint,e.poolFeeAccount,e.fees,e.curve,e.policy)}static fromAccountInfo(e,n=0){return S.deserialize(e.data,n)}static async fromAccountAddress(e,n,c){const a=await e.getAccountInfo(n,c);if(a==null)throw new Error(`Unable to find TokenSwap account at ${n}`);return S.fromAccountInfo(a,0)[0]}static gpaBuilder(e=new m("J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea")){return T.GpaBuilder.fromStruct(e,P)}static deserialize(e,n=0){return P.deserialize(e,n)}serialize(){return P.serialize({accountDiscriminator:de,...this})}static byteSize(e){const n=S.fromArgs(e);return P.toFixedFromValue({accountDiscriminator:de,...n}).byteSize}static async getMinimumBalanceForRentExemption(e,n,c){return n.getMinimumBalanceForRentExemption(S.byteSize(e),c)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const P=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["isInitialized",i.bool],["bumpSeed",i.u8],["tokenProgramId",T.publicKey],["tokenA",T.publicKey],["tokenB",T.publicKey],["poolMint",T.publicKey],["tokenAMint",T.publicKey],["tokenBMint",T.publicKey],["poolFeeAccount",T.publicKey],["fees",Ee],["curve",Fe],["policy",i.coption(T.publicKey)]],S.fromArgs,"TokenSwap"),l=new Map,p=new Map;class z extends Error{constructor(){super("Swap account already in use"),r(this,"code",6e3),r(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,z)}}l.set(6e3,()=>new z);p.set("AlreadyInUse",()=>new z);class C extends Error{constructor(){super("Invalid program address generated from bump seed and key"),r(this,"code",6001),r(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,C)}}l.set(6001,()=>new C);p.set("InvalidProgramAddress",()=>new C);class K extends Error{constructor(){super("Input account owner is not the program address"),r(this,"code",6002),r(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,K)}}l.set(6002,()=>new K);p.set("InvalidOwner",()=>new K);class O extends Error{constructor(){super("Output pool account owner cannot be the program address"),r(this,"code",6003),r(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,O)}}l.set(6003,()=>new O);p.set("InvalidOutputOwner",()=>new O);class R extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),r(this,"code",6004),r(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,R)}}l.set(6004,()=>new R);p.set("ExpectedMint",()=>new R);class Y extends Error{constructor(){super("Deserialized account is not an SPL Token account"),r(this,"code",6005),r(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Y)}}l.set(6005,()=>new Y);p.set("ExpectedAccount",()=>new Y);class G extends Error{constructor(){super("Input token account empty"),r(this,"code",6006),r(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G)}}l.set(6006,()=>new G);p.set("EmptySupply",()=>new G);class U extends Error{constructor(){super("Pool token mint has a non-zero supply"),r(this,"code",6007),r(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,U)}}l.set(6007,()=>new U);p.set("InvalidSupply",()=>new U);class J extends Error{constructor(){super("Token account has a delegate"),r(this,"code",6008),r(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,J)}}l.set(6008,()=>new J);p.set("InvalidDelegate",()=>new J);class V extends Error{constructor(){super("InvalidInput"),r(this,"code",6009),r(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,V)}}l.set(6009,()=>new V);p.set("InvalidInput",()=>new V);class q extends Error{constructor(){super("Address of the provided swap token account is incorrect"),r(this,"code",6010),r(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,q)}}l.set(6010,()=>new q);p.set("IncorrectSwapAccount",()=>new q);class L extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),r(this,"code",6011),r(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,L)}}l.set(6011,()=>new L);p.set("IncorrectPoolMint",()=>new L);class Q extends Error{constructor(){super("InvalidOutput"),r(this,"code",6012),r(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Q)}}l.set(6012,()=>new Q);p.set("InvalidOutput",()=>new Q);class j extends Error{constructor(){super("General calculation failure due to overflow or underflow"),r(this,"code",6013),r(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,j)}}l.set(6013,()=>new j);p.set("CalculationFailure",()=>new j);class Z extends Error{constructor(){super("Invalid instruction"),r(this,"code",6014),r(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Z)}}l.set(6014,()=>new Z);p.set("InvalidInstruction",()=>new Z);class X extends Error{constructor(){super("Swap input token accounts have the same mint"),r(this,"code",6015),r(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,X)}}l.set(6015,()=>new X);p.set("RepeatedMint",()=>new X);class H extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),r(this,"code",6016),r(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,H)}}l.set(6016,()=>new H);p.set("ExceededSlippage",()=>new H);class $ extends Error{constructor(){super("Token account has a close authority"),r(this,"code",6017),r(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$)}}l.set(6017,()=>new $);p.set("InvalidCloseAuthority",()=>new $);class _ extends Error{constructor(){super("Pool token mint has a freeze authority"),r(this,"code",6018),r(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_)}}l.set(6018,()=>new _);p.set("InvalidFreezeAuthority",()=>new _);class ee extends Error{constructor(){super("Pool fee token account incorrect"),r(this,"code",6019),r(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ee)}}l.set(6019,()=>new ee);p.set("IncorrectFeeAccount",()=>new ee);class te extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),r(this,"code",6020),r(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,te)}}l.set(6020,()=>new te);p.set("ZeroTradingTokens",()=>new te);class oe extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),r(this,"code",6021),r(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,oe)}}l.set(6021,()=>new oe);p.set("FeeCalculationFailure",()=>new oe);class ne extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),r(this,"code",6022),r(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ne)}}l.set(6022,()=>new ne);p.set("ConversionFailure",()=>new ne);class re extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),r(this,"code",6023),r(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,re)}}l.set(6023,()=>new re);p.set("InvalidFee",()=>new re);class ie extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),r(this,"code",6024),r(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ie)}}l.set(6024,()=>new ie);p.set("IncorrectTokenProgramId",()=>new ie);class ae extends Error{constructor(){super("The provided curve type is not supported by the program owner"),r(this,"code",6025),r(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ae)}}l.set(6025,()=>new ae);p.set("UnsupportedCurveType",()=>new ae);class se extends Error{constructor(){super("The provided curve parameters are invalid"),r(this,"code",6026),r(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,se)}}l.set(6026,()=>new se);p.set("InvalidCurve",()=>new se);class ce extends Error{constructor(){super("The operation cannot be performed on the given curve"),r(this,"code",6027),r(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ce)}}l.set(6027,()=>new ce);p.set("UnsupportedCurveOperation",()=>new ce);const pt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["maximumTokenAAmount",i.u64],["maximumTokenBAmount",i.u64]],"DepositAllTokenTypesInstructionArgs"),dt=[32,95,69,60,75,79,205,238];function mt(t,e,n=new m("J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea")){const[c]=pt.serialize({instructionDiscriminator:dt,...e}),a=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userTokenA,isWritable:!0,isSigner:!1},{pubkey:t.userTokenB,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const d of t.anchorRemainingAccounts)a.push(d);return new F({programId:n,keys:a,data:c})}const kt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["sourceTokenAmount",i.u64],["minimumPoolTokenAmount",i.u64]],"DepositSingleTokenTypeInstructionArgs"),ft=[175,0,152,41,199,0,148,43];function wt(t,e,n=new m("J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea")){const[c]=kt.serialize({instructionDiscriminator:ft,...e}),a=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const d of t.anchorRemainingAccounts)a.push(d);return new F({programId:n,keys:a,data:c})}const yt=new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["feesInput",Ee],["curveInput",Fe],["policy",i.coption(T.publicKey)]],"InitializeInstructionArgs"),St=[175,175,109,31,13,152,155,237];function ht(t,e,n=new m("J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea")){const[c]=yt.serialize({instructionDiscriminator:St,...e}),a=[{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.tokenA,isWritable:!0,isSigner:!1},{pubkey:t.tokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const d of t.anchorRemainingAccounts)a.push(d);return new F({programId:n,keys:a,data:c})}const gt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["amountIn",i.u64],["minimumAmountOut",i.u64]],"SwapInstructionArgs"),Tt=[248,198,158,145,225,117,135,200];function At(t,e,n=new m("J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea")){const[c]=gt.serialize({instructionDiscriminator:Tt,...e}),a=[{pubkey:t.proofRequest??n,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userSource,isWritable:!0,isSigner:!1},{pubkey:t.userDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolSource,isWritable:!0,isSigner:!1},{pubkey:t.poolDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.hostFeeAccount??n,isWritable:!1,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const d of t.anchorRemainingAccounts)a.push(d);return new F({programId:n,keys:a,data:c})}const bt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["minimumTokenAAmount",i.u64],["minimumTokenBAmount",i.u64]],"WithdrawAllTokenTypesInstructionArgs"),vt=[189,254,156,174,210,9,164,216];function Bt(t,e,n=new m("J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea")){const[c]=bt.serialize({instructionDiscriminator:vt,...e}),a=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destTokenA,isWritable:!0,isSigner:!1},{pubkey:t.destTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const d of t.anchorRemainingAccounts)a.push(d);return new F({programId:n,keys:a,data:c})}const Et=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["destinationTokenAmount",i.u64],["maximumPoolTokenAmount",i.u64]],"WithdrawSingleTokenTypeInstructionArgs"),Ft=[111,171,21,77,237,181,241,56];function It(t,e,n=new m("J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea")){const[c]=Et.serialize({instructionDiscriminator:Ft,...e}),a=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??E,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const d of t.anchorRemainingAccounts)a.push(d);return new F({programId:n,keys:a,data:c})}var Ie=(t=>(t[t.ConstantProduct=0]="ConstantProduct",t[t.ConstantPrice=1]="ConstantPrice",t[t.Offset=2]="Offset",t))(Ie||{});i.fixedScalarEnum(Ie);var We=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(We||{});i.fixedScalarEnum(We);var Me=(t=>(t[t.AtoB=0]="AtoB",t[t.BtoA=1]="BtoA",t))(Me||{});i.fixedScalarEnum(Me);const Wt="J8YCNcS2xDvowMcSzWrDYNguk5y9NWfGStNT4YsiKuea",Mt=new m(Wt);class Dt{constructor(e){r(this,"programId",Mt),this.provider=e}get connection(){return this.provider.connection}swapAuthority(e){return m.findProgramAddressSync([e.toBuffer()],this.programId)[0]}async createTokenSwap(e,n){const c=new B,a=e.tokenSwap??Oe.generate(),d=Array.from({length:32}),w=Array.from(e.curveParameters??[]);for(let g=0;g<w.length;g++)d[g]=w[g];const h={curveType:e.curveType,curveParameters:d},u=S.byteSize({bumpSeed:0,curve:h,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:m.default,poolFeeAccount:m.default,poolMint:m.default,tokenA:m.default,tokenAMint:m.default,tokenB:m.default,tokenBMint:m.default,tokenProgramId:m.default}),o=await this.connection.getMinimumBalanceForRentExemption(u);c.add(Re.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:a.publicKey,programId:this.programId,lamports:o,space:u})),c.add(ht({authority:this.swapAuthority(a.publicKey),tokenSwap:a.publicKey,destination:e.destination,poolMint:e.poolMint,poolFee:e.poolFee,tokenA:e.tokenA,tokenB:e.tokenB},{feesInput:{tradeFeeNumerator:new k(e.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new k(e.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new k(e.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new k(e.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new k(e.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new k(e.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new k(e.fees.hostFeeNumerator.toString()),hostFeeDenominator:new k(e.fees.hostFeeDenominator.toString())},curveInput:h,policy:e.policy??null}));const I=await this.provider.sendAndConfirm(c,[a],n);return{tokenSwap:a.publicKey,signature:I}}async swap(e,n){const c=new B;try{await rt(this.connection,e.userDestination)}catch(a){(a instanceof it||a instanceof at)&&e.receiver&&e.destinationTokenMint&&c.add(st(this.provider.publicKey,e.userDestination,e.receiver,e.destinationTokenMint))}return c.add(At({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:e.userSource,userDestination:e.userDestination,tokenSwap:e.tokenSwap,poolFee:e.poolFee,poolMint:e.poolMint,poolSource:e.poolSource,poolDestination:e.poolDestination,proofRequest:e.proofRequest,hostFeeAccount:e.hostFeeAccount},{amountIn:new k(e.amountIn.toString()),minimumAmountOut:new k(e.minimumAmountOut.toString())})),this.provider.sendAndConfirm(c,[],n)}async depositAllTokenTypes(e,n){const c=mt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,destination:e.destination,userTokenA:e.userTokenA,userTokenB:e.userTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new k(e.poolTokenAmount.toString()),maximumTokenAAmount:new k(e.maximumTokenA.toString()),maximumTokenBAmount:new k(e.maximumTokenB.toString())}),a=new B().add(c);return this.provider.sendAndConfirm(a,[],n)}async withdrawAllTokenTypes(e,n){const c=Bt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destTokenA:e.destTokenA,destTokenB:e.destTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new k(e.poolTokenAmount.toString()),minimumTokenAAmount:new k(e.minimumTokenA.toString()),minimumTokenBAmount:new k(e.minimumTokenB.toString())}),a=new B().add(c);return this.provider.sendAndConfirm(a,[],n)}async depositSingleTokenTypeExactAmountIn(e,n){const c=wt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{sourceTokenAmount:new k(e.sourceTokenAmount.toString()),minimumPoolTokenAmount:new k(e.minimumPoolTokenAmount.toString())}),a=new B().add(c);return this.provider.sendAndConfirm(a,[],n)}async withdrawSingleTokenTypeExactAmountOut(e,n){const c=It({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{destinationTokenAmount:new k(e.destinationTokenAmount.toString()),maximumPoolTokenAmount:new k(e.maximumPoolTokenAmount.toString())}),a=new B().add(c);return this.provider.sendAndConfirm(a,[],n)}async load(e,n){return S.fromAccountAddress(this.provider.connection,new m(e),n)}async loadAll(e={}){const n=S.gpaBuilder().addFilter("accountDiscriminator",de);return e.noData&&(n.config.dataSlice={offset:0,length:0}),e.tokenProgramId&&n.addFilter("tokenProgramId",new m(e.tokenProgramId)),e.poolMint&&n.addFilter("poolMint",new m(e.poolMint)),e.tokenAMint&&n.addFilter("tokenAMint",new m(e.tokenAMint)),e.tokenBMint&&n.addFilter("tokenBMint",new m(e.tokenBMint)),(await n.run(this.provider.connection)).map(({pubkey:c,account:a})=>({pubkey:c,data:e.noData?null:S.fromAccountInfo(a)[0]}))}}const zt=Ye({__name:"PoolsListItem",props:{pubkey:String,data:S},setup(t){return(e,n)=>(Ge(),Ue(Ve,{class:"swap-widget"},{default:pe(()=>[Te(Ae,{class:"swap-card__header"},{default:pe(()=>[Je(" Pool ")]),_:1}),Te(Ae,{class:"swap-card__body"},{default:pe(()=>[M("div",null,"address: "+D(t.pubkey),1),M("div",null,"mint A: "+D(t.data.tokenAMint.toBase58()),1),M("div",null,"mint B: "+D(t.data.tokenBMint.toBase58()),1),M("div",null,"policy: "+D(t.data.policy.toBase58()),1)]),_:1})]),_:1}))}}),Ct=qe("swap",()=>{const t=Le(),e=Qe(),n=je(),{publicKey:c}=Ze(),{notify:a}=Xe(),d=be(()=>new Dt(new ve(t.connection,n.value??{publicKey:m.default},ve.defaultOptions()))),w=x([]),h=x([]),u=x(),o=He({loading:!1,slippageDialog:!1,status:void 0,poolBalance:{},poolTokenSupply:0,from:$e,to:_e,swapping:!1,active:!1,slippage:.01,rate:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0});b(n,async s=>{I().then(),s||xe()},{immediate:!0});async function I(){o.loading=!0;try{console.log("swapClient ================: ",d.value),w.value=await d.value.loadAll(),console.log("swaps ================: ",w.value)}catch(s){console.log(s),w.value=[]}finally{o.loading=!1}}const g=x(!1),v=et(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!u.value){g.value=!0;try{const s=await tt(t.connection,d.value.swapAuthority(u.value.pubkey));for(const y of s)o.poolBalance[`${y.mint}`]=y.amount;const f=await ct(t.connection,u.value.data.poolMint);o.poolTokenSupply=Number(f.supply),console.log("[Pool Balance]",o.poolBalance),console.log("[Pool Balance] poolTokenSupply",o.poolTokenSupply)}catch(s){console.log("[Pool Balance] error",s)}finally{g.value=!1}}},500);setInterval(v,6e4);function De(s){u.value=s,console.log("setTokenSwap ========================== ",u.value)}b([w,()=>o.from.mint,()=>o.to.mint],async()=>{console.log("tokenSwapsAll ================: ",w.value),console.log("from.mint ================: ",o.from.mint),console.log("to.mint ================: ",o.to.mint),w.value&&o.from.mint&&o.to.mint&&o.from.mint!==o.to.mint?(h.value=w.value.filter(s=>{const f=s.data?.tokenAMint.toBase58(),y=s.data?.tokenBMint.toBase58();return f===o.from.mint&&y===o.to.mint||f===o.to.mint&&y===o.from.mint}),h.value.length?u.value=h.value[0]:u.value=void 0):(h.value=[],u.value=void 0,e.setContractPolicy(""),o.poolBalance={})},{immediate:!0}),b([u],async()=>{console.log("Token SWAP: ",u.value),u.value&&(e.setContractPolicy(u.value?.data.policy?.toBase58()??""),v())},{immediate:!0});function xe(){o.loading=!1,o.slippageDialog=!1,o.status=void 0,o.poolBalance={},o.poolTokenSupply=0}b([()=>o.from.amount,()=>o.poolBalance],async()=>{const s=W(o.from.amount??0,o.from.decimals),f=Number(o.poolBalance[o.from.mint]??0),y=Number(o.poolBalance[o.to.mint]??0);if(s===0||Number.isNaN(s)){o.to.amount=0,o.rate=y/f,o.impact=0;return}console.log(o.fees);const A=y-f*y/(f+s);o.rate=s?A/s:y/f,o.to.amount=ot(A?A*(1-o.fees.ownerTrade-o.fees.trade):0,o.to.decimals),o.impact=s?1-A/s/(y/f):0},{immediate:!0});const ue=be(()=>{const s=Number(W(o.to.amount??0,o.to.decimals));return Math.floor(s-s*o.slippage)});async function Ne(){if(!e.certificateValid)return nt();if(!u.value||!c.value){console.log("TokenSwap is not initialized...");return}n.value.publicKey||a({type:"info",message:"Please connect your wallet first"});const f=Number(W(o.from.amount??0,o.from.decimals)),y=Number(W(e.tokenBalance(o.from.mint)??0,o.from.decimals)),A=Number(W(o.to.amount??0,o.to.decimals));if(f>y){a({type:"negative",message:"Insufficient balance."});return}try{o.swapping=!0;const le=o.direction===0?u.value.data.tokenAMint:u.value.data.tokenBMint,ke=o.direction===0?u.value.data.tokenBMint:u.value.data.tokenAMint,fe=o.direction===0?u.value.data.tokenA:u.value.data.tokenB,we=o.direction===0?u.value.data.tokenB:u.value.data.tokenA,ye=await Be(le,n.value.publicKey),Se=await Be(ke,n.value.publicKey),he=f;console.log("toAmount = ",A),console.log("slippage = ",o.slippage),console.log("slippage 2 = ",A*o.slippage);const ge=d.value.swapAuthority(u.value.pubkey);console.log("proofRequest = ",e.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",ge),console.log("tokenSwap = ",u.value.pubkey.toBase58()),console.log("userSource = ",ye.toBase58()),console.log("userDestination = ",Se.toBase58()),console.log("poolSource = ",fe.toBase58()),console.log("poolDestination = ",we.toBase58()),console.log("poolMint = ",u.value.data.poolMint.toBase58()),console.log("poolFee = ",u.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",he),console.log("minimumAmountOut = ",ue.value),await d.value.swap({proofRequest:e.certificate?.pubkey,authority:ge,tokenSwap:u.value.pubkey,userSource:ye,userDestination:Se,poolSource:fe,poolDestination:we,poolMint:u.value.data.poolMint,poolFee:u.value.data.poolFeeAccount,amountIn:he,minimumAmountOut:ue.value,receiver:c.value,destinationTokenMint:ke},{commitment:"confirmed"}),me()}catch(le){console.log(le)}finally{o.swapping=!1}}function Pe(){const{from:s,to:f}=o;o.rate=0,o.to={...s,amount:void 0},o.from={...f,amount:void 0},o.direction=o.direction===0?1:0}function ze(){o.slippageDialog=!0}function Ce(){o.slippageDialog=!1}function Ke(s){o.from.amount=s}function me(){v(),o.from.amount=void 0,o.to.amount=void 0}return b(()=>n.value?.publicKey,s=>{s||me()}),b(()=>o.to,s=>{s.amount&&(s.amount=void 0)}),b(u,s=>{s&&(o.fees.host=N(s.data.fees.hostFeeNumerator,s.data.fees.hostFeeDenominator),o.fees.ownerTrade=N(s.data.fees.ownerTradeFeeNumerator,s.data.fees.ownerTradeFeeDenominator),o.fees.ownerWithdraw=N(s.data.fees.ownerWithdrawFeeNumerator,s.data.fees.ownerWithdrawFeeDenominator),o.fees.trade=N(s.data.fees.tradeFeeNumerator,s.data.fees.tradeFeeDenominator),console.log("fees ==== ",o.fees))}),{state:o,tokenSwapsAll:w,tokenSwaps:h,tokenSwap:u,swapClient:d,loadingPoolTokens:g,loadPoolTokenAccounts:v,minimumReceived:ue,setTokenSwap:De,setMax:Ke,closeSlippage:Ce,openSlippage:ze,changeDirection:Pe,swapSubmit:Ne}});export{zt as _,Ie as t,Ct as u};
