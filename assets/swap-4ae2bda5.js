import{m as k,ao as we,ap as Se,a as Je,q as F,bo as xe,b6 as Pe,aq as rt,bp as it,k as a,bq as M,n as P,br as at,S as ze,R as h,s as st,u as ct,t as ut,w as lt,x as pt,y as dt,z as mt,v as ft,K as De,P as kt,G as z,A as Ie,B as ht,bs as Ce,W as yt,H as wt,C as g,aG as ke,I as he,J as St,bt as At,bu as gt,ax as Ne,a6 as vt,aR as N,Q as bt,bv as K}from"./index-248adac9.js";import{b as E,d as Tt,A as Bt,N as Ke,g as Re,T as Oe,a as qe,c as Le}from"./associatedTokenAccount-f16a5f7e.js";var O;(function(e){e[e.InitializeMint=0]="InitializeMint",e[e.InitializeAccount=1]="InitializeAccount",e[e.InitializeMultisig=2]="InitializeMultisig",e[e.Transfer=3]="Transfer",e[e.Approve=4]="Approve",e[e.Revoke=5]="Revoke",e[e.SetAuthority=6]="SetAuthority",e[e.MintTo=7]="MintTo",e[e.Burn=8]="Burn",e[e.CloseAccount=9]="CloseAccount",e[e.FreezeAccount=10]="FreezeAccount",e[e.ThawAccount=11]="ThawAccount",e[e.TransferChecked=12]="TransferChecked",e[e.ApproveChecked=13]="ApproveChecked",e[e.MintToChecked=14]="MintToChecked",e[e.BurnChecked=15]="BurnChecked",e[e.InitializeAccount2=16]="InitializeAccount2",e[e.SyncNative=17]="SyncNative",e[e.InitializeAccount3=18]="InitializeAccount3",e[e.InitializeMultisig2=19]="InitializeMultisig2",e[e.InitializeMint2=20]="InitializeMint2",e[e.GetAccountDataSize=21]="GetAccountDataSize",e[e.InitializeImmutableOwner=22]="InitializeImmutableOwner",e[e.AmountToUiAmount=23]="AmountToUiAmount",e[e.UiAmountToAmount=24]="UiAmountToAmount",e[e.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",e[e.TransferFeeExtension=26]="TransferFeeExtension",e[e.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",e[e.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",e[e.Reallocate=29]="Reallocate",e[e.MemoTransferExtension=30]="MemoTransferExtension",e[e.CreateNativeMint=31]="CreateNativeMint",e[e.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",e[e.InterestBearingMintExtension=33]="InterestBearingMintExtension",e[e.CpiGuardExtension=34]="CpiGuardExtension",e[e.InitializePermanentDelegate=35]="InitializePermanentDelegate",e[e.TransferHookExtension=36]="TransferHookExtension",e[e.MetadataPointerExtension=39]="MetadataPointerExtension"})(O||(O={}));function Mt(e,t,n){if(n.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const r of n)e.push({pubkey:r instanceof k?r:r.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}const Ue=we([Se("instruction")]);function Et(e,t,n,r=[],c=E){const p=Mt([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}],n,r),y=Je.Buffer.alloc(Ue.span);return Ue.encode({instruction:O.CloseAccount},y),new F({keys:p,programId:c,data:y})}const Ft=we([xe("mintAuthorityOption"),Pe("mintAuthority"),rt("supply"),Se("decimals"),it("isInitialized"),xe("freezeAuthorityOption"),Pe("freezeAuthority")]);Ft.span;async function Wt(e,t,n=!1,r=E,c=Bt){if(!n&&!k.isOnCurve(t.toBuffer()))throw new Tt;const[p]=await k.findProgramAddress([t.toBuffer(),r.toBuffer(),e.toBuffer()],c);return p}const Ge=we([Se("instruction")]);function xt(e,t=E){const n=[{pubkey:e,isSigner:!1,isWritable:!0}],r=Je.Buffer.alloc(Ge.span);return Ge.encode({instruction:O.SyncNative},r),new F({keys:n,programId:t,data:r})}var Pt=Object.defineProperty,zt=(e,t,n)=>t in e?Pt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,i=(e,t,n)=>(zt(e,typeof t!="symbol"?t+"":t,n),n);const $e=new a.BeetArgsStruct([["tradeFeeNumerator",a.u64],["tradeFeeDenominator",a.u64],["ownerTradeFeeNumerator",a.u64],["ownerTradeFeeDenominator",a.u64],["ownerWithdrawFeeNumerator",a.u64],["ownerWithdrawFeeDenominator",a.u64],["hostFeeNumerator",a.u64],["hostFeeDenominator",a.u64]],"FeesInfo"),He=new a.BeetArgsStruct([["curveType",a.u8],["curveParameters",a.uniformFixedSizeArray(a.u8,32)]],"CurveInfo"),ye=[135,144,215,161,140,125,41,96];class B{constructor(t,n,r,c,p,y,W,v,S,b,u,x){this.isInitialized=t,this.bumpSeed=n,this.tokenProgramId=r,this.tokenA=c,this.tokenB=p,this.poolMint=y,this.tokenAMint=W,this.tokenBMint=v,this.poolFeeAccount=S,this.fees=b,this.curve=u,this.policy=x}static fromArgs(t){return new B(t.isInitialized,t.bumpSeed,t.tokenProgramId,t.tokenA,t.tokenB,t.poolMint,t.tokenAMint,t.tokenBMint,t.poolFeeAccount,t.fees,t.curve,t.policy)}static fromAccountInfo(t,n=0){return B.deserialize(t.data,n)}static async fromAccountAddress(t,n,r){const c=await t.getAccountInfo(n,r);if(c==null)throw new Error(`Unable to find TokenSwap account at ${n}`);return B.fromAccountInfo(c,0)[0]}static gpaBuilder(t=new k("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return M.GpaBuilder.fromStruct(t,R)}static deserialize(t,n=0){return R.deserialize(t,n)}serialize(){return R.serialize({accountDiscriminator:ye,...this})}static byteSize(t){const n=B.fromArgs(t);return R.toFixedFromValue({accountDiscriminator:ye,...n}).byteSize}static async getMinimumBalanceForRentExemption(t,n,r){return n.getMinimumBalanceForRentExemption(B.byteSize(t),r)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const R=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["isInitialized",a.bool],["bumpSeed",a.u8],["tokenProgramId",M.publicKey],["tokenA",M.publicKey],["tokenB",M.publicKey],["poolMint",M.publicKey],["tokenAMint",M.publicKey],["tokenBMint",M.publicKey],["poolFeeAccount",M.publicKey],["fees",$e],["curve",He],["policy",a.coption(M.publicKey)]],B.fromArgs,"TokenSwap"),m=new Map,f=new Map;class q extends Error{constructor(){super("Swap account already in use"),i(this,"code",6e3),i(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,q)}}m.set(6e3,()=>new q);f.set("AlreadyInUse",()=>new q);class L extends Error{constructor(){super("Invalid program address generated from bump seed and key"),i(this,"code",6001),i(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,L)}}m.set(6001,()=>new L);f.set("InvalidProgramAddress",()=>new L);class U extends Error{constructor(){super("Input account owner is not the program address"),i(this,"code",6002),i(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,U)}}m.set(6002,()=>new U);f.set("InvalidOwner",()=>new U);class G extends Error{constructor(){super("Output pool account owner cannot be the program address"),i(this,"code",6003),i(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G)}}m.set(6003,()=>new G);f.set("InvalidOutputOwner",()=>new G);class J extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),i(this,"code",6004),i(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,J)}}m.set(6004,()=>new J);f.set("ExpectedMint",()=>new J);class $ extends Error{constructor(){super("Deserialized account is not an SPL Token account"),i(this,"code",6005),i(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$)}}m.set(6005,()=>new $);f.set("ExpectedAccount",()=>new $);class H extends Error{constructor(){super("Input token account empty"),i(this,"code",6006),i(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,H)}}m.set(6006,()=>new H);f.set("EmptySupply",()=>new H);class Q extends Error{constructor(){super("Pool token mint has a non-zero supply"),i(this,"code",6007),i(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Q)}}m.set(6007,()=>new Q);f.set("InvalidSupply",()=>new Q);class V extends Error{constructor(){super("Token account has a delegate"),i(this,"code",6008),i(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,V)}}m.set(6008,()=>new V);f.set("InvalidDelegate",()=>new V);class j extends Error{constructor(){super("InvalidInput"),i(this,"code",6009),i(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,j)}}m.set(6009,()=>new j);f.set("InvalidInput",()=>new j);class Z extends Error{constructor(){super("Address of the provided swap token account is incorrect"),i(this,"code",6010),i(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Z)}}m.set(6010,()=>new Z);f.set("IncorrectSwapAccount",()=>new Z);class X extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),i(this,"code",6011),i(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,X)}}m.set(6011,()=>new X);f.set("IncorrectPoolMint",()=>new X);class Y extends Error{constructor(){super("InvalidOutput"),i(this,"code",6012),i(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Y)}}m.set(6012,()=>new Y);f.set("InvalidOutput",()=>new Y);class _ extends Error{constructor(){super("General calculation failure due to overflow or underflow"),i(this,"code",6013),i(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_)}}m.set(6013,()=>new _);f.set("CalculationFailure",()=>new _);class ee extends Error{constructor(){super("Invalid instruction"),i(this,"code",6014),i(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ee)}}m.set(6014,()=>new ee);f.set("InvalidInstruction",()=>new ee);class te extends Error{constructor(){super("Swap input token accounts have the same mint"),i(this,"code",6015),i(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,te)}}m.set(6015,()=>new te);f.set("RepeatedMint",()=>new te);class oe extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),i(this,"code",6016),i(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,oe)}}m.set(6016,()=>new oe);f.set("ExceededSlippage",()=>new oe);class ne extends Error{constructor(){super("Token account has a close authority"),i(this,"code",6017),i(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ne)}}m.set(6017,()=>new ne);f.set("InvalidCloseAuthority",()=>new ne);class re extends Error{constructor(){super("Pool token mint has a freeze authority"),i(this,"code",6018),i(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,re)}}m.set(6018,()=>new re);f.set("InvalidFreezeAuthority",()=>new re);class ie extends Error{constructor(){super("Pool fee token account incorrect"),i(this,"code",6019),i(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ie)}}m.set(6019,()=>new ie);f.set("IncorrectFeeAccount",()=>new ie);class ae extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),i(this,"code",6020),i(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ae)}}m.set(6020,()=>new ae);f.set("ZeroTradingTokens",()=>new ae);class se extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),i(this,"code",6021),i(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,se)}}m.set(6021,()=>new se);f.set("FeeCalculationFailure",()=>new se);class ce extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),i(this,"code",6022),i(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ce)}}m.set(6022,()=>new ce);f.set("ConversionFailure",()=>new ce);class ue extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),i(this,"code",6023),i(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ue)}}m.set(6023,()=>new ue);f.set("InvalidFee",()=>new ue);class le extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),i(this,"code",6024),i(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,le)}}m.set(6024,()=>new le);f.set("IncorrectTokenProgramId",()=>new le);class pe extends Error{constructor(){super("The provided curve type is not supported by the program owner"),i(this,"code",6025),i(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pe)}}m.set(6025,()=>new pe);f.set("UnsupportedCurveType",()=>new pe);class de extends Error{constructor(){super("The provided curve parameters are invalid"),i(this,"code",6026),i(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,de)}}m.set(6026,()=>new de);f.set("InvalidCurve",()=>new de);class me extends Error{constructor(){super("The operation cannot be performed on the given curve"),i(this,"code",6027),i(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,me)}}m.set(6027,()=>new me);f.set("UnsupportedCurveOperation",()=>new me);new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"CloseAccountInstructionArgs");const Dt=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["poolTokenAmount",a.u64],["maximumTokenAAmount",a.u64],["maximumTokenBAmount",a.u64]],"DepositAllTokenTypesInstructionArgs"),It=[32,95,69,60,75,79,205,238];function Ct(e,t,n=new k("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Dt.serialize({instructionDiscriminator:It,...t}),c=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userTokenA,isWritable:!0,isSigner:!1},{pubkey:e.userTokenB,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const p of e.anchorRemainingAccounts)c.push(p);return new F({programId:n,keys:c,data:r})}const Nt=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["sourceTokenAmount",a.u64],["minimumPoolTokenAmount",a.u64]],"DepositSingleTokenTypeInstructionArgs"),Kt=[175,0,152,41,199,0,148,43];function Rt(e,t,n=new k("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Nt.serialize({instructionDiscriminator:Kt,...t}),c=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const p of e.anchorRemainingAccounts)c.push(p);return new F({programId:n,keys:c,data:r})}const Ot=new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["feesInput",$e],["curveInput",He],["policy",a.coption(M.publicKey)]],"InitializeInstructionArgs"),qt=[175,175,109,31,13,152,155,237];function Lt(e,t,n=new k("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Ot.serialize({instructionDiscriminator:qt,...t}),c=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.tokenA,isWritable:!0,isSigner:!1},{pubkey:e.tokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const p of e.anchorRemainingAccounts)c.push(p);return new F({programId:n,keys:c,data:r})}const Ut=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["amountIn",a.u64],["minimumAmountOut",a.u64]],"SwapInstructionArgs"),Gt=[248,198,158,145,225,117,135,200];function Jt(e,t,n=new k("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Ut.serialize({instructionDiscriminator:Gt,...t}),c=[{pubkey:e.proofRequest??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userSource,isWritable:!0,isSigner:!1},{pubkey:e.userDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolSource,isWritable:!0,isSigner:!1},{pubkey:e.poolDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.hostFeeAccount??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const p of e.anchorRemainingAccounts)c.push(p);return new F({programId:n,keys:c,data:r})}const $t=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["poolTokenAmount",a.u64],["minimumTokenAAmount",a.u64],["minimumTokenBAmount",a.u64]],"WithdrawAllTokenTypesInstructionArgs"),Ht=[189,254,156,174,210,9,164,216];function Qt(e,t,n=new k("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=$t.serialize({instructionDiscriminator:Ht,...t}),c=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const p of e.anchorRemainingAccounts)c.push(p);return new F({programId:n,keys:c,data:r})}const Vt=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["destinationTokenAmount",a.u64],["maximumPoolTokenAmount",a.u64]],"WithdrawSingleTokenTypeInstructionArgs"),jt=[111,171,21,77,237,181,241,56];function Zt(e,t,n=new k("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Vt.serialize({instructionDiscriminator:jt,...t}),c=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const p of e.anchorRemainingAccounts)c.push(p);return new F({programId:n,keys:c,data:r})}var Qe=(e=>(e[e.ConstantProduct=0]="ConstantProduct",e[e.ConstantPrice=1]="ConstantPrice",e[e.Offset=2]="Offset",e))(Qe||{});a.fixedScalarEnum(Qe);var Ve=(e=>(e[e.Floor=0]="Floor",e[e.Ceiling=1]="Ceiling",e))(Ve||{});a.fixedScalarEnum(Ve);var je=(e=>(e[e.AtoB=0]="AtoB",e[e.BtoA=1]="BtoA",e))(je||{});a.fixedScalarEnum(je);const Xt="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",Yt=new k(Xt);class _t{constructor(t){i(this,"programId",Yt),this.provider=t}get connection(){return this.provider.connection}swapAuthority(t){return k.findProgramAddressSync([t.toBuffer()],this.programId)[0]}async createTokenSwap(t,n){const r=new P,c=t.tokenSwap??at.generate(),p=Array.from({length:32}),y=Array.from(t.curveParameters??[]);for(let u=0;u<y.length;u++)p[u]=y[u];const W={curveType:t.curveType,curveParameters:p},v=B.byteSize({bumpSeed:0,curve:W,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:k.default,poolFeeAccount:k.default,poolMint:k.default,tokenA:k.default,tokenAMint:k.default,tokenB:k.default,tokenBMint:k.default,tokenProgramId:k.default}),S=await this.connection.getMinimumBalanceForRentExemption(v);r.add(ze.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:c.publicKey,programId:this.programId,lamports:S,space:v})),r.add(Lt({authority:this.swapAuthority(c.publicKey),tokenSwap:c.publicKey,destination:t.destination,poolMint:t.poolMint,poolFee:t.poolFee,tokenA:t.tokenA,tokenB:t.tokenB},{feesInput:{tradeFeeNumerator:new h(t.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new h(t.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new h(t.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new h(t.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new h(t.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new h(t.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new h(t.fees.hostFeeNumerator.toString()),hostFeeDenominator:new h(t.fees.hostFeeDenominator.toString())},curveInput:W,policy:t.policy??null}));const b=await this.provider.sendAndConfirm(r,[c],n);return{tokenSwap:c.publicKey,signature:b}}async swap(t,n){const r=new P;return await this.handleAccount(r,t.userDestination,t.destinationTokenMint),await this.handleWrappedSol({tx:r,amount:t.amountIn,userSource:t.userSource,sourceTokenMint:t.sourceTokenMint}),r.add(Jt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:t.userSource,userDestination:t.userDestination,tokenSwap:t.tokenSwap,poolFee:t.poolFee,poolMint:t.poolMint,poolSource:t.poolSource,poolDestination:t.poolDestination,proofRequest:t.proofRequest,hostFeeAccount:t.hostFeeAccount},{amountIn:new h(t.amountIn.toString()),minimumAmountOut:new h(t.minimumAmountOut.toString())})),this.unwrapSol(r,t.userDestination,t.destinationTokenMint),this.provider.sendAndConfirm(r,[],n)}async depositAllTokenTypes(t,n){const r=new P;return await this.handleAccount(r,t.destination,t.poolMint),await this.handleWrappedSol({tx:r,amount:t.maximumTokenA,userSource:t.userTokenA,sourceTokenMint:t.tokenAMint}),await this.handleWrappedSol({tx:r,amount:t.maximumTokenB,userSource:t.userTokenB,sourceTokenMint:t.tokenBMint}),r.add(Ct({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,destination:t.destination,userTokenA:t.userTokenA,userTokenB:t.userTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new h(t.poolTokenAmount.toString()),maximumTokenAAmount:new h(t.maximumTokenA.toString()),maximumTokenBAmount:new h(t.maximumTokenB.toString())})),this.provider.sendAndConfirm(r,[],n)}async withdrawAllTokenTypes(t,n){const r=new P;return await this.handleAccount(r,t.destTokenA,t.tokenAMint),await this.handleAccount(r,t.destTokenB,t.tokenBMint),r.add(Qt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destTokenA:t.destTokenA,destTokenB:t.destTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new h(t.poolTokenAmount.toString()),minimumTokenAAmount:new h(t.minimumTokenA.toString()),minimumTokenBAmount:new h(t.minimumTokenB.toString())})),this.unwrapSol(r,t.destTokenA,t.tokenAMint),this.unwrapSol(r,t.destTokenB,t.tokenBMint),this.provider.sendAndConfirm(r,[],n)}async depositSingleTokenTypeExactAmountIn(t,n){const r=new P;return await this.handleAccount(r,t.destination,t.poolMint),await this.handleWrappedSol({tx:r,amount:t.sourceTokenAmount,userSource:t.source,sourceTokenMint:t.sourceTokenMint}),r.add(Rt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{sourceTokenAmount:new h(t.sourceTokenAmount.toString()),minimumPoolTokenAmount:new h(t.minimumPoolTokenAmount.toString())})),this.provider.sendAndConfirm(r,[],n)}async withdrawSingleTokenTypeExactAmountOut(t,n){const r=new P;return await this.handleAccount(r,t.destination,t.destinationTokenMint),r.add(Zt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{destinationTokenAmount:new h(t.destinationTokenAmount.toString()),maximumPoolTokenAmount:new h(t.maximumPoolTokenAmount.toString())})),this.unwrapSol(r,t.destination,t.destinationTokenMint),this.provider.sendAndConfirm(r,[],n)}async load(t,n){return B.fromAccountAddress(this.provider.connection,new k(t),n)}async loadAll(t={}){const n=B.gpaBuilder().addFilter("accountDiscriminator",ye);return t.noData&&(n.config.dataSlice={offset:0,length:0}),t.tokenProgramId&&n.addFilter("tokenProgramId",new k(t.tokenProgramId)),t.poolMint&&n.addFilter("poolMint",new k(t.poolMint)),t.tokenAMint&&n.addFilter("tokenAMint",new k(t.tokenAMint)),t.tokenBMint&&n.addFilter("tokenBMint",new k(t.tokenBMint)),(await n.run(this.provider.connection)).map(({pubkey:r,account:c})=>({pubkey:r,data:t.noData?null:B.fromAccountInfo(c)[0]}))}unwrapSol(t,n,r){r&&r.toBase58()===Ke.toBase58()&&t.add(Et(n,this.provider.publicKey,this.provider.publicKey))}async handleAccount(t,n,r){try{await Re(this.connection,n)}catch(c){(c instanceof Oe||c instanceof qe)&&r&&t.add(Le(this.provider.publicKey,n,this.provider.publicKey,r))}}async handleWrappedSol(t){var n;if(t.sourceTokenMint&&((n=t.sourceTokenMint)==null?void 0:n.toBase58())===Ke.toBase58()){let r=0;try{if((await Wt(t.sourceTokenMint,this.provider.publicKey)).toBase58()!==t.userSource.toBase58())return;const p=await Re(this.connection,t.userSource);r=Number(p.amount)}catch(p){(p instanceof Oe||p instanceof qe)&&t.tx.add(Le(this.provider.publicKey,t.userSource,this.provider.publicKey,t.sourceTokenMint))}const c=Number(t.amount);t.amount>r&&t.tx.add(ze.transfer({fromPubkey:this.provider.publicKey,toPubkey:t.userSource,lamports:c-r}),xt(t.userSource))}}}var eo=(e=>(e[e.ASC=0]="ASC",e[e.DESC=1]="DESC",e))(eo||{});const ro=st("swap",()=>{const e=ct(),t=ut(),n=lt(),r=pt(),{publicKey:c}=dt(),{notify:p}=mt(),y=ft(()=>new _t(new De(e.connection,r.value??{publicKey:kt.default},De.defaultOptions()))),W=z({}),v=z([]),S=z([]),b=z([]),u=z(),x=Ie("token-a",""),D=Ie("token-b",""),o=ht({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:Ce,to:Ce,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:Ze,tokens:T}=yt();Ze(wt),g(T,()=>{if(T.value.length>=2){const s=T.value.find(d=>d.mint===x.value)??T.value[0];let l=T.value.find(d=>d.mint===D.value)??T.value[1];if(o.from=T.value.find(d=>d.mint===x.value)??T.value[0],o.to=T.value.find(d=>d.mint===D.value)??T.value[1],s===l){const d=T.value.find(w=>w.mint!==s.mint);d&&(l=d)}o.from=s,o.to=l}},{immediate:!0}),g(()=>o.from,()=>{o.from&&(x.value=o.from.mint)}),g(()=>o.to,()=>{o.to&&(D.value=o.to.mint)});const Ae=ke(async()=>{o.loading=!0;try{console.log("swapClient ================: ",y.value),v.value=await y.value.loadAll(),console.log("swaps ================: ",v.value)}catch(s){console.log(s),v.value=[]}finally{o.loading=!1}},400);g([r,()=>e.cluster],async s=>{Ae()?.then(),s||Ye()},{immediate:!0});const ge=ke(async()=>{if(c.value&&S.value.length>0){const s={};for(const l of S.value)try{const d=await he(l.data.poolMint,c.value),w=await St(e.connection,d);s[l.data.poolMint.toBase58()]=Number(w.amount),console.log("userAcc === ",w)}catch{}W.value=s}},500);g([c,S],ge,{immediate:!0});const fe=z(!1),I=ke(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!u.value){fe.value=!0;try{const s=await At(e.connection,y.value.swapAuthority(u.value.pubkey)),l={};for(const w of s)l[`${w.mint}`]=w.amount;o.poolBalance=l;const d=await gt(e.connection,u.value.data.poolMint);o.poolTokenSupply=Number(d.supply),console.log("[Pool Balance] poolMint",d),console.log("[Pool Balance]",o.poolBalance),console.log("[Pool Balance] poolTokenSupply",o.poolTokenSupply)}catch(s){console.log("[Pool Balance] error",s)}finally{fe.value=!1}}},500);setInterval(I,6e4);function Xe(s){u.value=s,console.log("setTokenSwap: ",u.value)}g([v,()=>n.servicePolicy],async()=>{console.log("tokenSwapsAll: ",v.value),S.value=v.value.filter(s=>!!n.servicePolicy.find(l=>l.pubkey.toBase58()===s.data.policy?.toBase58()&&!!t.tokenByMint(s.data.tokenAMint.toBase58())&&!!t.tokenByMint(s.data.tokenBMint.toBase58())))},{immediate:!0}),g([S,()=>o.from?.mint,()=>o.to?.mint,()=>n.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",S.value),S.value&&o.from?.mint&&o.to?.mint&&o.from.mint!==o.to.mint&&n.servicePolicy.length)if(b.value=S.value.filter(s=>{const l=s.data?.tokenAMint.toBase58(),d=s.data?.tokenBMint.toBase58();return l===o.from.mint&&d===o.to.mint||l===o.to.mint&&d===o.from.mint}),b.value.length){if(b.value.length>1){const s=b.value.find(l=>n.state.certificates?.find(d=>d.data?.policy.toBase58()===l.data.policy?.toBase58()));s&&(u.value=s)}u.value=b.value[0]}else u.value=void 0;else b.value=[],u.value=void 0,n.setContractPolicy("","swap"),o.poolBalance={}},{immediate:!0}),g([u],async()=>{console.log("Token SWAP: ",u.value),n.setContractPolicy(u.value?.data.policy?.toBase58()??"","swap"),u.value&&(I(),u.value.data.tokenAMint.toBase58()===o.from.mint?o.direction=0:o.direction=1)},{immediate:!0});function Ye(){o.loading=!1,o.slippageDialog=!1,o.poolBalance={},o.poolTokenSupply=0}g([()=>o.direction,()=>o.from.amount,()=>o.poolBalance],async()=>{const s=Number(o.from.amount??0),l=Ne(Number(o.poolBalance[o.from.mint]??0),o.from.decimals),d=Ne(Number(o.poolBalance[o.to.mint]??0),o.to.decimals),w=1-o.fees.ownerTrade-o.fees.trade;if(s===0||Number.isNaN(s)){o.to.amount=0,o.rate=Number(d)/Number(l)*w,o.impact=0,o.minimumReceived=0;return}const A=d-l*d/(l+s*w);o.rate=s?A/s:d/l,o.to.amount=A?Number(vt(A,o.to.decimals)):0,o.impact=s?1-A/s/w/(d/l):0,o.minimumReceived=N(o.to.amount-o.to.amount*o.slippage,o.to.decimals)},{immediate:!0});async function _e(){if(!n.certificateValid)return bt();if(!u.value||!c.value){console.log("Pool is not selected...");return}r.value.publicKey||p({type:"info",message:"Please connect your wallet first"});const l=Number(N(o.from.amount??0,o.from.decimals)),d=Number(N(n.tokenBalance(o.from.mint)??0,o.from.decimals)),w=Number(N(o.to.amount??0,o.to.decimals));if(l>d){p({type:"negative",message:"Insufficient balance."});return}try{o.swapping=!0;const A=o.direction===0?u.value.data.tokenAMint:u.value.data.tokenBMint,C=o.direction===0?u.value.data.tokenBMint:u.value.data.tokenAMint,Te=o.direction===0?u.value.data.tokenA:u.value.data.tokenB,Be=o.direction===0?u.value.data.tokenB:u.value.data.tokenA;console.log("userSourceMint = ",A.toBase58()),console.log("userDestinationMint = ",C.toBase58()),console.log("userSourceMint = ",A.toBase58()),console.log("userDestinationMint = ",C.toBase58());const Me=await he(A,r.value.publicKey),Ee=await he(C,r.value.publicKey),Fe=l;console.log("toAmount = ",w),console.log("slippage = ",o.slippage),console.log("slippage 2 = ",w*o.slippage);const We=y.value.swapAuthority(u.value.pubkey);console.log("proofRequest = ",n.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",We),console.log("tokenSwap = ",u.value.pubkey.toBase58()),console.log("userSource = ",Me.toBase58()),console.log("userDestination = ",Ee.toBase58()),console.log("poolSource = ",Te.toBase58()),console.log("poolDestination = ",Be.toBase58()),console.log("poolMint = ",u.value.data.poolMint.toBase58()),console.log("poolFee = ",u.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",Fe),console.log("minimumAmountOut = ",o.minimumReceived);const nt=await y.value.swap({proofRequest:n.certificate?.pubkey,authority:We,tokenSwap:u.value.pubkey,userSource:Me,userDestination:Ee,poolSource:Te,poolDestination:Be,poolMint:u.value.data.poolMint,poolFee:u.value.data.poolFeeAccount,amountIn:Fe,minimumAmountOut:o.minimumReceived,sourceTokenMint:A,destinationTokenMint:C},{commitment:"confirmed"});p({message:"Transaction confirmed",type:"positive",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${nt}?cluster=${e.cluster}`,onClick:()=>!1}]}),ve()}catch(A){console.log(A),`${A}`.includes("User rejected the request")||p({type:"negative",message:`${A}`})}finally{o.swapping=!1}}function et(){const{from:s,to:l}=o;o.rate=0,o.to={...s,amount:void 0},o.from={...l,amount:void 0},o.direction=o.direction===0?1:0}function tt(){o.slippageDialog=!0}function ot(){o.slippageDialog=!1}function ve(){I(),o.from.amount=void 0,o.to.amount=void 0}g(()=>r.value?.publicKey,s=>{s||ve()}),g(()=>o.to,s=>{s.amount&&(s.amount=void 0)});function be(s){return{host:K(s.fees.hostFeeNumerator,s.fees.hostFeeDenominator),trade:K(s.fees.tradeFeeNumerator,s.fees.tradeFeeDenominator),ownerTrade:K(s.fees.ownerTradeFeeNumerator,s.fees.ownerTradeFeeDenominator),ownerWithdraw:K(s.fees.ownerWithdrawFeeNumerator,s.fees.ownerWithdrawFeeDenominator)}}return g(u,s=>{if(!s)return;const l=be(s.data);o.fees.host=l.host,o.fees.trade=l.trade,o.fees.ownerTrade=l.ownerTrade,o.fees.ownerWithdraw=l.ownerWithdraw,console.log("fees ==== ",o.fees)}),{state:o,tokenSwapsAllFiltered:S,tokenSwaps:b,tokenSwap:u,swapClient:y,loadingPoolTokens:fe,loadPoolTokenAccounts:I,setTokenSwap:Xe,closeSlippage:ot,openSlippage:tt,changeDirection:et,swapSubmit:_e,getPoolFee:be,init:Ae,tokenAMint:x,tokenBMint:D,userPoolsTokens:W,reloadUserLP:ge}});export{eo as S,Qe as s,ro as u};
