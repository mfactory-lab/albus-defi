import{m as y,ao as ge,ap as ve,a as Ue,q as W,bg as ze,bh as De,aq as nt,bi as rt,k as s,bj as M,n as P,bk as it,S as Ie,R as h,s as at,u as st,w as ct,x as ut,y as lt,z as pt,v as dt,K as Ce,P as mt,G as z,A as Ne,B as ft,bl as Ke,W as yt,H as ht,C as S,bm as we,I as Se,J as kt,bn as wt,bo as St,ax as Re,a6 as At,aN as C,Q as gt,bp as N}from"./index-156c4556.js";import{b as E,d as vt,A as bt,g as K,T as R,a as O,c as q,N as Oe}from"./associatedTokenAccount-2d691262.js";var U;(function(e){e[e.InitializeMint=0]="InitializeMint",e[e.InitializeAccount=1]="InitializeAccount",e[e.InitializeMultisig=2]="InitializeMultisig",e[e.Transfer=3]="Transfer",e[e.Approve=4]="Approve",e[e.Revoke=5]="Revoke",e[e.SetAuthority=6]="SetAuthority",e[e.MintTo=7]="MintTo",e[e.Burn=8]="Burn",e[e.CloseAccount=9]="CloseAccount",e[e.FreezeAccount=10]="FreezeAccount",e[e.ThawAccount=11]="ThawAccount",e[e.TransferChecked=12]="TransferChecked",e[e.ApproveChecked=13]="ApproveChecked",e[e.MintToChecked=14]="MintToChecked",e[e.BurnChecked=15]="BurnChecked",e[e.InitializeAccount2=16]="InitializeAccount2",e[e.SyncNative=17]="SyncNative",e[e.InitializeAccount3=18]="InitializeAccount3",e[e.InitializeMultisig2=19]="InitializeMultisig2",e[e.InitializeMint2=20]="InitializeMint2",e[e.GetAccountDataSize=21]="GetAccountDataSize",e[e.InitializeImmutableOwner=22]="InitializeImmutableOwner",e[e.AmountToUiAmount=23]="AmountToUiAmount",e[e.UiAmountToAmount=24]="UiAmountToAmount",e[e.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",e[e.TransferFeeExtension=26]="TransferFeeExtension",e[e.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",e[e.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",e[e.Reallocate=29]="Reallocate",e[e.MemoTransferExtension=30]="MemoTransferExtension",e[e.CreateNativeMint=31]="CreateNativeMint",e[e.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",e[e.InterestBearingMintExtension=33]="InterestBearingMintExtension",e[e.CpiGuardExtension=34]="CpiGuardExtension",e[e.InitializePermanentDelegate=35]="InitializePermanentDelegate",e[e.TransferHookExtension=36]="TransferHookExtension",e[e.MetadataPointerExtension=39]="MetadataPointerExtension"})(U||(U={}));function Tt(e,t,n){if(n.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const r of n)e.push({pubkey:r instanceof y?r:r.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}const qe=ge([ve("instruction")]);function Bt(e,t,n,r=[],i=E){const l=Tt([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}],n,r),B=Ue.Buffer.alloc(qe.span);return qe.encode({instruction:U.CloseAccount},B),new W({keys:l,programId:i,data:B})}const Mt=ge([ze("mintAuthorityOption"),De("mintAuthority"),nt("supply"),ve("decimals"),rt("isInitialized"),ze("freezeAuthorityOption"),De("freezeAuthority")]);Mt.span;async function Et(e,t,n=!1,r=E,i=bt){if(!n&&!y.isOnCurve(t.toBuffer()))throw new vt;const[l]=await y.findProgramAddress([t.toBuffer(),r.toBuffer(),e.toBuffer()],i);return l}const Le=ge([ve("instruction")]);function Ft(e,t=E){const n=[{pubkey:e,isSigner:!1,isWritable:!0}],r=Ue.Buffer.alloc(Le.span);return Le.encode({instruction:U.SyncNative},r),new W({keys:n,programId:t,data:r})}var Wt=Object.defineProperty,xt=(e,t,n)=>t in e?Wt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,a=(e,t,n)=>(xt(e,typeof t!="symbol"?t+"":t,n),n);const Ge=new s.BeetArgsStruct([["tradeFeeNumerator",s.u64],["tradeFeeDenominator",s.u64],["ownerTradeFeeNumerator",s.u64],["ownerTradeFeeDenominator",s.u64],["ownerWithdrawFeeNumerator",s.u64],["ownerWithdrawFeeDenominator",s.u64],["hostFeeNumerator",s.u64],["hostFeeDenominator",s.u64]],"FeesInfo"),Je=new s.BeetArgsStruct([["curveType",s.u8],["curveParameters",s.uniformFixedSizeArray(s.u8,32)]],"CurveInfo"),Ae=[135,144,215,161,140,125,41,96];class T{constructor(t,n,r,i,l,B,A,w,g,u,v,x){this.isInitialized=t,this.bumpSeed=n,this.tokenProgramId=r,this.tokenA=i,this.tokenB=l,this.poolMint=B,this.tokenAMint=A,this.tokenBMint=w,this.poolFeeAccount=g,this.fees=u,this.curve=v,this.policy=x}static fromArgs(t){return new T(t.isInitialized,t.bumpSeed,t.tokenProgramId,t.tokenA,t.tokenB,t.poolMint,t.tokenAMint,t.tokenBMint,t.poolFeeAccount,t.fees,t.curve,t.policy)}static fromAccountInfo(t,n=0){return T.deserialize(t.data,n)}static async fromAccountAddress(t,n,r){const i=await t.getAccountInfo(n,r);if(i==null)throw new Error(`Unable to find TokenSwap account at ${n}`);return T.fromAccountInfo(i,0)[0]}static gpaBuilder(t=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return M.GpaBuilder.fromStruct(t,L)}static deserialize(t,n=0){return L.deserialize(t,n)}serialize(){return L.serialize({accountDiscriminator:Ae,...this})}static byteSize(t){const n=T.fromArgs(t);return L.toFixedFromValue({accountDiscriminator:Ae,...n}).byteSize}static async getMinimumBalanceForRentExemption(t,n,r){return n.getMinimumBalanceForRentExemption(T.byteSize(t),r)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const L=new s.FixableBeetStruct([["accountDiscriminator",s.uniformFixedSizeArray(s.u8,8)],["isInitialized",s.bool],["bumpSeed",s.u8],["tokenProgramId",M.publicKey],["tokenA",M.publicKey],["tokenB",M.publicKey],["poolMint",M.publicKey],["tokenAMint",M.publicKey],["tokenBMint",M.publicKey],["poolFeeAccount",M.publicKey],["fees",Ge],["curve",Je],["policy",s.coption(M.publicKey)]],T.fromArgs,"TokenSwap"),m=new Map,f=new Map;class G extends Error{constructor(){super("Swap account already in use"),a(this,"code",6e3),a(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G)}}m.set(6e3,()=>new G);f.set("AlreadyInUse",()=>new G);class J extends Error{constructor(){super("Invalid program address generated from bump seed and key"),a(this,"code",6001),a(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,J)}}m.set(6001,()=>new J);f.set("InvalidProgramAddress",()=>new J);class $ extends Error{constructor(){super("Input account owner is not the program address"),a(this,"code",6002),a(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$)}}m.set(6002,()=>new $);f.set("InvalidOwner",()=>new $);class H extends Error{constructor(){super("Output pool account owner cannot be the program address"),a(this,"code",6003),a(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,H)}}m.set(6003,()=>new H);f.set("InvalidOutputOwner",()=>new H);class j extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),a(this,"code",6004),a(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,j)}}m.set(6004,()=>new j);f.set("ExpectedMint",()=>new j);class Q extends Error{constructor(){super("Deserialized account is not an SPL Token account"),a(this,"code",6005),a(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Q)}}m.set(6005,()=>new Q);f.set("ExpectedAccount",()=>new Q);class V extends Error{constructor(){super("Input token account empty"),a(this,"code",6006),a(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,V)}}m.set(6006,()=>new V);f.set("EmptySupply",()=>new V);class Z extends Error{constructor(){super("Pool token mint has a non-zero supply"),a(this,"code",6007),a(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Z)}}m.set(6007,()=>new Z);f.set("InvalidSupply",()=>new Z);class X extends Error{constructor(){super("Token account has a delegate"),a(this,"code",6008),a(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,X)}}m.set(6008,()=>new X);f.set("InvalidDelegate",()=>new X);class Y extends Error{constructor(){super("InvalidInput"),a(this,"code",6009),a(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Y)}}m.set(6009,()=>new Y);f.set("InvalidInput",()=>new Y);class _ extends Error{constructor(){super("Address of the provided swap token account is incorrect"),a(this,"code",6010),a(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_)}}m.set(6010,()=>new _);f.set("IncorrectSwapAccount",()=>new _);class ee extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),a(this,"code",6011),a(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ee)}}m.set(6011,()=>new ee);f.set("IncorrectPoolMint",()=>new ee);class te extends Error{constructor(){super("InvalidOutput"),a(this,"code",6012),a(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,te)}}m.set(6012,()=>new te);f.set("InvalidOutput",()=>new te);class oe extends Error{constructor(){super("General calculation failure due to overflow or underflow"),a(this,"code",6013),a(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,oe)}}m.set(6013,()=>new oe);f.set("CalculationFailure",()=>new oe);class ne extends Error{constructor(){super("Invalid instruction"),a(this,"code",6014),a(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ne)}}m.set(6014,()=>new ne);f.set("InvalidInstruction",()=>new ne);class re extends Error{constructor(){super("Swap input token accounts have the same mint"),a(this,"code",6015),a(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,re)}}m.set(6015,()=>new re);f.set("RepeatedMint",()=>new re);class ie extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),a(this,"code",6016),a(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ie)}}m.set(6016,()=>new ie);f.set("ExceededSlippage",()=>new ie);class ae extends Error{constructor(){super("Token account has a close authority"),a(this,"code",6017),a(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ae)}}m.set(6017,()=>new ae);f.set("InvalidCloseAuthority",()=>new ae);class se extends Error{constructor(){super("Pool token mint has a freeze authority"),a(this,"code",6018),a(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,se)}}m.set(6018,()=>new se);f.set("InvalidFreezeAuthority",()=>new se);class ce extends Error{constructor(){super("Pool fee token account incorrect"),a(this,"code",6019),a(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ce)}}m.set(6019,()=>new ce);f.set("IncorrectFeeAccount",()=>new ce);class ue extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),a(this,"code",6020),a(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ue)}}m.set(6020,()=>new ue);f.set("ZeroTradingTokens",()=>new ue);class le extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),a(this,"code",6021),a(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,le)}}m.set(6021,()=>new le);f.set("FeeCalculationFailure",()=>new le);class pe extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),a(this,"code",6022),a(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pe)}}m.set(6022,()=>new pe);f.set("ConversionFailure",()=>new pe);class de extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),a(this,"code",6023),a(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,de)}}m.set(6023,()=>new de);f.set("InvalidFee",()=>new de);class me extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),a(this,"code",6024),a(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,me)}}m.set(6024,()=>new me);f.set("IncorrectTokenProgramId",()=>new me);class fe extends Error{constructor(){super("The provided curve type is not supported by the program owner"),a(this,"code",6025),a(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,fe)}}m.set(6025,()=>new fe);f.set("UnsupportedCurveType",()=>new fe);class ye extends Error{constructor(){super("The provided curve parameters are invalid"),a(this,"code",6026),a(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ye)}}m.set(6026,()=>new ye);f.set("InvalidCurve",()=>new ye);class he extends Error{constructor(){super("The operation cannot be performed on the given curve"),a(this,"code",6027),a(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,he)}}m.set(6027,()=>new he);f.set("UnsupportedCurveOperation",()=>new he);new s.BeetArgsStruct([["instructionDiscriminator",s.uniformFixedSizeArray(s.u8,8)]],"CloseAccountInstructionArgs");const Pt=new s.BeetArgsStruct([["instructionDiscriminator",s.uniformFixedSizeArray(s.u8,8)],["poolTokenAmount",s.u64],["maximumTokenAAmount",s.u64],["maximumTokenBAmount",s.u64]],"DepositAllTokenTypesInstructionArgs"),zt=[32,95,69,60,75,79,205,238];function Dt(e,t,n=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Pt.serialize({instructionDiscriminator:zt,...t}),i=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userTokenA,isWritable:!0,isSigner:!1},{pubkey:e.userTokenB,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)i.push(l);return new W({programId:n,keys:i,data:r})}const It=new s.BeetArgsStruct([["instructionDiscriminator",s.uniformFixedSizeArray(s.u8,8)],["sourceTokenAmount",s.u64],["minimumPoolTokenAmount",s.u64]],"DepositSingleTokenTypeInstructionArgs"),Ct=[175,0,152,41,199,0,148,43];function Nt(e,t,n=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=It.serialize({instructionDiscriminator:Ct,...t}),i=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)i.push(l);return new W({programId:n,keys:i,data:r})}const Kt=new s.FixableBeetArgsStruct([["instructionDiscriminator",s.uniformFixedSizeArray(s.u8,8)],["feesInput",Ge],["curveInput",Je],["policy",s.coption(M.publicKey)]],"InitializeInstructionArgs"),Rt=[175,175,109,31,13,152,155,237];function Ot(e,t,n=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Kt.serialize({instructionDiscriminator:Rt,...t}),i=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.tokenA,isWritable:!0,isSigner:!1},{pubkey:e.tokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)i.push(l);return new W({programId:n,keys:i,data:r})}const qt=new s.BeetArgsStruct([["instructionDiscriminator",s.uniformFixedSizeArray(s.u8,8)],["amountIn",s.u64],["minimumAmountOut",s.u64]],"SwapInstructionArgs"),Lt=[248,198,158,145,225,117,135,200];function Ut(e,t,n=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=qt.serialize({instructionDiscriminator:Lt,...t}),i=[{pubkey:e.proofRequest??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userSource,isWritable:!0,isSigner:!1},{pubkey:e.userDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolSource,isWritable:!0,isSigner:!1},{pubkey:e.poolDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.hostFeeAccount??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)i.push(l);return new W({programId:n,keys:i,data:r})}const Gt=new s.BeetArgsStruct([["instructionDiscriminator",s.uniformFixedSizeArray(s.u8,8)],["poolTokenAmount",s.u64],["minimumTokenAAmount",s.u64],["minimumTokenBAmount",s.u64]],"WithdrawAllTokenTypesInstructionArgs"),Jt=[189,254,156,174,210,9,164,216];function $t(e,t,n=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Gt.serialize({instructionDiscriminator:Jt,...t}),i=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)i.push(l);return new W({programId:n,keys:i,data:r})}const Ht=new s.BeetArgsStruct([["instructionDiscriminator",s.uniformFixedSizeArray(s.u8,8)],["destinationTokenAmount",s.u64],["maximumPoolTokenAmount",s.u64]],"WithdrawSingleTokenTypeInstructionArgs"),jt=[111,171,21,77,237,181,241,56];function Qt(e,t,n=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[r]=Ht.serialize({instructionDiscriminator:jt,...t}),i=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)i.push(l);return new W({programId:n,keys:i,data:r})}var $e=(e=>(e[e.ConstantProduct=0]="ConstantProduct",e[e.ConstantPrice=1]="ConstantPrice",e[e.Offset=2]="Offset",e))($e||{});s.fixedScalarEnum($e);var He=(e=>(e[e.Floor=0]="Floor",e[e.Ceiling=1]="Ceiling",e))(He||{});s.fixedScalarEnum(He);var je=(e=>(e[e.AtoB=0]="AtoB",e[e.BtoA=1]="BtoA",e))(je||{});s.fixedScalarEnum(je);const Vt="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",Zt=new y(Vt);class Xt{constructor(t){a(this,"programId",Zt),this.provider=t}get connection(){return this.provider.connection}swapAuthority(t){return y.findProgramAddressSync([t.toBuffer()],this.programId)[0]}async createTokenSwap(t,n){const r=new P,i=t.tokenSwap??it.generate(),l=Array.from({length:32}),B=Array.from(t.curveParameters??[]);for(let v=0;v<B.length;v++)l[v]=B[v];const A={curveType:t.curveType,curveParameters:l},w=T.byteSize({bumpSeed:0,curve:A,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:y.default,poolFeeAccount:y.default,poolMint:y.default,tokenA:y.default,tokenAMint:y.default,tokenB:y.default,tokenBMint:y.default,tokenProgramId:y.default}),g=await this.connection.getMinimumBalanceForRentExemption(w);r.add(Ie.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:i.publicKey,programId:this.programId,lamports:g,space:w})),r.add(Ot({authority:this.swapAuthority(i.publicKey),tokenSwap:i.publicKey,destination:t.destination,poolMint:t.poolMint,poolFee:t.poolFee,tokenA:t.tokenA,tokenB:t.tokenB},{feesInput:{tradeFeeNumerator:new h(t.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new h(t.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new h(t.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new h(t.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new h(t.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new h(t.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new h(t.fees.hostFeeNumerator.toString()),hostFeeDenominator:new h(t.fees.hostFeeDenominator.toString())},curveInput:A,policy:t.policy??null}));const u=await this.provider.sendAndConfirm(r,[i],n);return{tokenSwap:i.publicKey,signature:u}}async swap(t,n){var r;const i=new P;try{await K(this.connection,t.userDestination)}catch(l){(l instanceof R||l instanceof O)&&t.destinationTokenMint&&i.add(q(this.provider.publicKey,t.userDestination,this.provider.publicKey,t.destinationTokenMint))}return await this.handleWrappedSol({tx:i,amount:t.amountIn,userSource:t.userSource,sourceTokenMint:t.sourceTokenMint}),i.add(Ut({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:t.userSource,userDestination:t.userDestination,tokenSwap:t.tokenSwap,poolFee:t.poolFee,poolMint:t.poolMint,poolSource:t.poolSource,poolDestination:t.poolDestination,proofRequest:t.proofRequest,hostFeeAccount:t.hostFeeAccount},{amountIn:new h(t.amountIn.toString()),minimumAmountOut:new h(t.minimumAmountOut.toString())})),t.destinationTokenMint&&((r=t.destinationTokenMint)==null?void 0:r.toBase58())===Oe.toBase58()&&i.add(Bt(t.userDestination,this.provider.publicKey,this.provider.publicKey)),this.provider.sendAndConfirm(i,[],n)}async depositAllTokenTypes(t,n){const r=new P;try{await K(this.connection,t.destination)}catch(i){(i instanceof R||i instanceof O)&&r.add(q(this.provider.publicKey,t.destination,this.provider.publicKey,t.poolMint))}return await this.handleWrappedSol({tx:r,amount:t.maximumTokenA,userSource:t.userTokenA,sourceTokenMint:t.tokenAMint}),await this.handleWrappedSol({tx:r,amount:t.maximumTokenB,userSource:t.userTokenB,sourceTokenMint:t.tokenBMint}),r.add(Dt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,destination:t.destination,userTokenA:t.userTokenA,userTokenB:t.userTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new h(t.poolTokenAmount.toString()),maximumTokenAAmount:new h(t.maximumTokenA.toString()),maximumTokenBAmount:new h(t.maximumTokenB.toString())})),this.provider.sendAndConfirm(r,[],n)}async withdrawAllTokenTypes(t,n){const r=$t({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destTokenA:t.destTokenA,destTokenB:t.destTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new h(t.poolTokenAmount.toString()),minimumTokenAAmount:new h(t.minimumTokenA.toString()),minimumTokenBAmount:new h(t.minimumTokenB.toString())}),i=new P().add(r);return this.provider.sendAndConfirm(i,[],n)}async depositSingleTokenTypeExactAmountIn(t,n){const r=new P;try{await K(this.connection,t.destination)}catch(i){(i instanceof R||i instanceof O)&&r.add(q(this.provider.publicKey,t.destination,this.provider.publicKey,t.poolMint))}return await this.handleWrappedSol({tx:r,amount:t.sourceTokenAmount,userSource:t.source,sourceTokenMint:t.sourceTokenMint}),r.add(Nt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{sourceTokenAmount:new h(t.sourceTokenAmount.toString()),minimumPoolTokenAmount:new h(t.minimumPoolTokenAmount.toString())})),this.provider.sendAndConfirm(r,[],n)}async withdrawSingleTokenTypeExactAmountOut(t,n){const r=Qt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{destinationTokenAmount:new h(t.destinationTokenAmount.toString()),maximumPoolTokenAmount:new h(t.maximumPoolTokenAmount.toString())}),i=new P().add(r);return this.provider.sendAndConfirm(i,[],n)}async load(t,n){return T.fromAccountAddress(this.provider.connection,new y(t),n)}async loadAll(t={}){const n=T.gpaBuilder().addFilter("accountDiscriminator",Ae);return t.noData&&(n.config.dataSlice={offset:0,length:0}),t.tokenProgramId&&n.addFilter("tokenProgramId",new y(t.tokenProgramId)),t.poolMint&&n.addFilter("poolMint",new y(t.poolMint)),t.tokenAMint&&n.addFilter("tokenAMint",new y(t.tokenAMint)),t.tokenBMint&&n.addFilter("tokenBMint",new y(t.tokenBMint)),(await n.run(this.provider.connection)).map(({pubkey:r,account:i})=>({pubkey:r,data:t.noData?null:T.fromAccountInfo(i)[0]}))}async handleWrappedSol(t){var n;if(t.sourceTokenMint&&((n=t.sourceTokenMint)==null?void 0:n.toBase58())===Oe.toBase58()){let r=0;try{if((await Et(t.sourceTokenMint,this.provider.publicKey)).toBase58()!==t.userSource.toBase58())return;const l=await K(this.connection,t.userSource);r=Number(l.amount)}catch(l){(l instanceof R||l instanceof O)&&t.tx.add(q(this.provider.publicKey,t.userSource,this.provider.publicKey,t.sourceTokenMint))}const i=Number(t.amount);t.amount>r&&t.tx.add(Ie.transfer({fromPubkey:this.provider.publicKey,toPubkey:t.userSource,lamports:i-r}),Ft(t.userSource))}}}var Yt=(e=>(e[e.ASC=0]="ASC",e[e.DESC=1]="DESC",e))(Yt||{});const oo=at("swap",()=>{const e=st(),t=ct(),n=ut(),{publicKey:r}=lt(),{notify:i}=pt(),l=dt(()=>new Xt(new Ce(e.connection,n.value??{publicKey:mt.default},Ce.defaultOptions()))),B=z({}),A=z([]),w=z([]),g=z([]),u=z(),v=Ne("token-a",""),x=Ne("token-b",""),o=ft({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:Ke,to:Ke,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:Qe,tokens:b}=yt();Qe(ht),S(b,()=>{if(b.value.length>=2){const c=b.value.find(d=>d.mint===v.value)??b.value[0];let p=b.value.find(d=>d.mint===x.value)??b.value[1];if(o.from=b.value.find(d=>d.mint===v.value)??b.value[0],o.to=b.value.find(d=>d.mint===x.value)??b.value[1],c===p){const d=b.value.find(k=>k.mint!==c.mint);d&&(p=d)}o.from=c,o.to=p}},{immediate:!0}),S(()=>o.from,()=>{o.from&&(v.value=o.from.mint)}),S(()=>o.to,()=>{o.to&&(x.value=o.to.mint)});const Ve=we(async()=>{o.loading=!0;try{console.log("swapClient ================: ",l.value),A.value=await l.value.loadAll(),console.log("swaps ================: ",A.value)}catch(c){console.log(c),A.value=[]}finally{o.loading=!1}},400);S([n,()=>e.cluster],async c=>{Ve()?.then(),c||Xe()},{immediate:!0});const be=we(async()=>{if(r.value&&w.value.length>0){const c={};for(const p of w.value)try{const d=await Se(p.data.poolMint,r.value),k=await kt(e.connection,d);c[p.data.poolMint.toBase58()]=Number(k.amount),console.log("userAcc === ",k)}catch{}B.value=c}},500);S([r,w],be,{immediate:!0});const ke=z(!1),D=we(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!u.value){ke.value=!0;try{const c=await wt(e.connection,l.value.swapAuthority(u.value.pubkey)),p={};for(const k of c)p[`${k.mint}`]=k.amount;o.poolBalance=p;const d=await St(e.connection,u.value.data.poolMint);o.poolTokenSupply=Number(d.supply),console.log("[Pool Balance] poolMint",d),console.log("[Pool Balance]",o.poolBalance),console.log("[Pool Balance] poolTokenSupply",o.poolTokenSupply)}catch(c){console.log("[Pool Balance] error",c)}finally{ke.value=!1}}},500);setInterval(D,6e4);function Ze(c){u.value=c,console.log("setTokenSwap: ",u.value)}S([A,()=>t.servicePolicy],async()=>{console.log("tokenSwapsAll: ",A.value),w.value=A.value.filter(c=>!!t.servicePolicy.find(p=>p.pubkey.toBase58()===c.data.policy?.toBase58()))},{immediate:!0}),S([w,()=>o.from?.mint,()=>o.to?.mint,()=>t.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",w.value),w.value&&o.from?.mint&&o.to?.mint&&o.from.mint!==o.to.mint&&t.servicePolicy.length)if(g.value=w.value.filter(c=>{const p=c.data?.tokenAMint.toBase58(),d=c.data?.tokenBMint.toBase58();return p===o.from.mint&&d===o.to.mint||p===o.to.mint&&d===o.from.mint}),g.value.length){if(g.value.length>1){const c=g.value.find(p=>t.state.certificates?.find(d=>d.data?.policy.toBase58()===p.data.policy?.toBase58()));c&&(u.value=c)}u.value=g.value[0]}else u.value=void 0;else g.value=[],u.value=void 0,t.setContractPolicy("","swap"),o.poolBalance={}},{immediate:!0}),S([u],async()=>{console.log("Token SWAP: ",u.value),t.setContractPolicy(u.value?.data.policy?.toBase58()??"","swap"),u.value&&(D(),u.value.data.tokenAMint.toBase58()===o.from.mint?o.direction=0:o.direction=1)},{immediate:!0});function Xe(){o.loading=!1,o.slippageDialog=!1,o.poolBalance={},o.poolTokenSupply=0}S([()=>o.direction,()=>o.from.amount,()=>o.poolBalance],async()=>{const c=Number(o.from.amount??0),p=Re(Number(o.poolBalance[o.from.mint]??0),o.from.decimals),d=Re(Number(o.poolBalance[o.to.mint]??0),o.to.decimals);if(c===0||Number.isNaN(c)){o.to.amount=0,o.rate=Number(d)/Number(p),o.impact=0,o.minimumReceived=0;return}const k=d-p*d/(p+c);o.rate=c?k/c:d/p,o.to.amount=k?Number(At(k*(1-o.fees.ownerTrade-o.fees.trade),o.to.decimals)):0,o.impact=c?1-k/c/(d/p):0,o.minimumReceived=C(o.to.amount-o.to.amount*o.slippage,o.to.decimals)},{immediate:!0});async function Ye(){if(!t.certificateValid)return gt();if(!u.value||!r.value){console.log("Pool is not selected...");return}n.value.publicKey||i({type:"info",message:"Please connect your wallet first"});const p=Number(C(o.from.amount??0,o.from.decimals)),d=Number(C(t.tokenBalance(o.from.mint)??0,o.from.decimals)),k=Number(C(o.to.amount??0,o.to.decimals));if(p>d){i({type:"negative",message:"Insufficient balance."});return}try{o.swapping=!0;const F=o.direction===0?u.value.data.tokenAMint:u.value.data.tokenBMint,I=o.direction===0?u.value.data.tokenBMint:u.value.data.tokenAMint,Me=o.direction===0?u.value.data.tokenA:u.value.data.tokenB,Ee=o.direction===0?u.value.data.tokenB:u.value.data.tokenA;console.log("userSourceMint = ",F.toBase58()),console.log("userDestinationMint = ",I.toBase58()),console.log("userSourceMint = ",F.toBase58()),console.log("userDestinationMint = ",I.toBase58());const Fe=await Se(F,n.value.publicKey),We=await Se(I,n.value.publicKey),xe=p;console.log("toAmount = ",k),console.log("slippage = ",o.slippage),console.log("slippage 2 = ",k*o.slippage);const Pe=l.value.swapAuthority(u.value.pubkey);console.log("proofRequest = ",t.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",Pe),console.log("tokenSwap = ",u.value.pubkey.toBase58()),console.log("userSource = ",Fe.toBase58()),console.log("userDestination = ",We.toBase58()),console.log("poolSource = ",Me.toBase58()),console.log("poolDestination = ",Ee.toBase58()),console.log("poolMint = ",u.value.data.poolMint.toBase58()),console.log("poolFee = ",u.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",xe),console.log("minimumAmountOut = ",o.minimumReceived);const ot=await l.value.swap({proofRequest:t.certificate?.pubkey,authority:Pe,tokenSwap:u.value.pubkey,userSource:Fe,userDestination:We,poolSource:Me,poolDestination:Ee,poolMint:u.value.data.poolMint,poolFee:u.value.data.poolFeeAccount,amountIn:xe,minimumAmountOut:o.minimumReceived,sourceTokenMint:F,destinationTokenMint:I},{commitment:"confirmed"});i({message:"Transaction confirmed",type:"positive",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${ot}?cluster=${e.cluster}`,onClick:()=>!1}]}),Te()}catch(F){console.log(F),`${F}`.includes("User rejected the request")||i({type:"negative",message:`${F}`})}finally{o.swapping=!1}}function _e(){const{from:c,to:p}=o;o.rate=0,o.to={...c,amount:void 0},o.from={...p,amount:void 0},o.direction=o.direction===0?1:0}function et(){o.slippageDialog=!0}function tt(){o.slippageDialog=!1}function Te(){D(),o.from.amount=void 0,o.to.amount=void 0}S(()=>n.value?.publicKey,c=>{c||Te()}),S(()=>o.to,c=>{c.amount&&(c.amount=void 0)});function Be(c){return{host:N(c.fees.hostFeeNumerator,c.fees.hostFeeDenominator),trade:N(c.fees.tradeFeeNumerator,c.fees.tradeFeeDenominator),ownerTrade:N(c.fees.ownerTradeFeeNumerator,c.fees.ownerTradeFeeDenominator),ownerWithdraw:N(c.fees.ownerWithdrawFeeNumerator,c.fees.ownerWithdrawFeeDenominator)}}return S(u,c=>{if(!c)return;const p=Be(c.data);o.fees.host=p.host,o.fees.trade=p.trade,o.fees.ownerTrade=p.ownerTrade,o.fees.ownerWithdraw=p.ownerWithdraw,console.log("fees ==== ",o.fees)}),{state:o,tokenSwapsAllFiltered:w,tokenSwaps:g,tokenSwap:u,swapClient:l,loadingPoolTokens:ke,loadPoolTokenAccounts:D,setTokenSwap:Ze,closeSlippage:tt,openSlippage:et,changeDirection:_e,swapSubmit:Ye,getPoolFee:Be,tokenAMint:v,tokenBMint:x,userPoolsTokens:B,reloadUserLP:be}});export{Yt as S,$e as s,oo as u};
