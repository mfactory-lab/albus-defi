var Mt=Object.defineProperty;var Ft=(e,t,o)=>t in e?Mt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var n=(e,t,o)=>(Ft(e,typeof t!="symbol"?t+"":t,o),o);import{b2 as me,b3 as fe,a as ke,b4 as ye,w as B,v as M,m as i,b5 as g,P as y,n as F,b6 as oe,aj as Wt,S as J,b1 as re,q as G,s as ne,t as ie,u as ae,N as q,b7 as Pt,x as xt,y as Dt,z as zt,B as Ct,C as Nt,F as Rt,G as Kt,A as Ot,O as se,L as x,H as ue,I as qt,b8 as ce,$ as Lt,M as Ut,J as h,au as U,b9 as Jt,ba as Gt,ak as le,ab as $t,aG as R,W as _t,bb as K}from"./index-c73aa05e.js";import{a as Zt}from"./internal-59c88893.js";const de=me([fe("instruction")]);function Vt(e,t,o,s=[],u=M){const k=Zt([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}],o,s),d=ke.Buffer.alloc(de.span);return de.encode({instruction:ye.CloseAccount},d),new B({keys:k,programId:u,data:d})}const pe=me([fe("instruction")]);function jt(e,t=M){const o=[{pubkey:e,isSigner:!1,isWritable:!0}],s=ke.Buffer.alloc(pe.span);return pe.encode({instruction:ye.SyncNative},s),new B({keys:o,programId:t,data:s})}var we=new i.BeetArgsStruct([["tradeFeeNumerator",i.u64],["tradeFeeDenominator",i.u64],["ownerTradeFeeNumerator",i.u64],["ownerTradeFeeDenominator",i.u64],["ownerWithdrawFeeNumerator",i.u64],["ownerWithdrawFeeDenominator",i.u64],["hostFeeNumerator",i.u64],["hostFeeDenominator",i.u64]],"FeesInfo"),Se=new i.BeetArgsStruct([["curveType",i.u8],["curveParameters",i.uniformFixedSizeArray(i.u8,32)]],"CurveInfo"),$=[135,144,215,161,140,125,41,96],z=class D{constructor(t,o,s,u,k,d,I,b,A,S,c,W,P,r){this.isInitialized=t,this.bumpSeed=o,this.tokenProgramId=s,this.tokenA=u,this.tokenB=k,this.poolMint=d,this.tokenAMint=I,this.tokenBMint=b,this.poolFeeAccount=A,this.fees=S,this.curve=c,this.swapPolicy=W,this.addLiquidityPolicy=P,this.reserved=r}static fromArgs(t){return new D(t.isInitialized,t.bumpSeed,t.tokenProgramId,t.tokenA,t.tokenB,t.poolMint,t.tokenAMint,t.tokenBMint,t.poolFeeAccount,t.fees,t.curve,t.swapPolicy,t.addLiquidityPolicy,t.reserved)}static fromAccountInfo(t,o=0){return D.deserialize(t.data,o)}static async fromAccountAddress(t,o,s){const u=await t.getAccountInfo(o,s);if(u==null)throw new Error(`Unable to find TokenSwap account at ${o}`);return D.fromAccountInfo(u,0)[0]}static gpaBuilder(t=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return g.GpaBuilder.fromStruct(t,O)}static deserialize(t,o=0){return O.deserialize(t,o)}serialize(){return O.serialize({accountDiscriminator:$,...this})}static byteSize(t){const o=D.fromArgs(t);return O.toFixedFromValue({accountDiscriminator:$,...o}).byteSize}static async getMinimumBalanceForRentExemption(t,o,s){return o.getMinimumBalanceForRentExemption(D.byteSize(t),s)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,swapPolicy:this.swapPolicy,addLiquidityPolicy:this.addLiquidityPolicy,reserved:this.reserved}}},O=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["isInitialized",i.bool],["bumpSeed",i.u8],["tokenProgramId",g.publicKey],["tokenA",g.publicKey],["tokenB",g.publicKey],["poolMint",g.publicKey],["tokenAMint",g.publicKey],["tokenBMint",g.publicKey],["poolFeeAccount",g.publicKey],["fees",we],["curve",Se],["swapPolicy",i.coption(g.publicKey)],["addLiquidityPolicy",i.coption(g.publicKey)],["reserved",i.uniformFixedSizeArray(i.u8,64)]],z.fromArgs,"TokenSwap"),m=new Map,f=new Map,ve=class Te extends Error{constructor(){super("Swap account already in use");n(this,"code",6e3);n(this,"name","AlreadyInUse");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Te)}};m.set(6e3,()=>new ve);f.set("AlreadyInUse",()=>new ve);var Ae=class he extends Error{constructor(){super("Invalid program address generated from bump seed and key");n(this,"code",6001);n(this,"name","InvalidProgramAddress");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,he)}};m.set(6001,()=>new Ae);f.set("InvalidProgramAddress",()=>new Ae);var ge=class be extends Error{constructor(){super("Input account owner is not the program address");n(this,"code",6002);n(this,"name","InvalidOwner");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,be)}};m.set(6002,()=>new ge);f.set("InvalidOwner",()=>new ge);var Ee=class Ie extends Error{constructor(){super("Output pool account owner cannot be the program address");n(this,"code",6003);n(this,"name","InvalidOutputOwner");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ie)}};m.set(6003,()=>new Ee);f.set("InvalidOutputOwner",()=>new Ee);var Be=class Me extends Error{constructor(){super("Deserialized account is not an SPL Token mint");n(this,"code",6004);n(this,"name","ExpectedMint");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Me)}};m.set(6004,()=>new Be);f.set("ExpectedMint",()=>new Be);var Fe=class We extends Error{constructor(){super("Deserialized account is not an SPL Token account");n(this,"code",6005);n(this,"name","ExpectedAccount");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,We)}};m.set(6005,()=>new Fe);f.set("ExpectedAccount",()=>new Fe);var Pe=class xe extends Error{constructor(){super("Input token account empty");n(this,"code",6006);n(this,"name","EmptySupply");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,xe)}};m.set(6006,()=>new Pe);f.set("EmptySupply",()=>new Pe);var De=class ze extends Error{constructor(){super("Pool token mint has a non-zero supply");n(this,"code",6007);n(this,"name","InvalidSupply");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ze)}};m.set(6007,()=>new De);f.set("InvalidSupply",()=>new De);var Ce=class Ne extends Error{constructor(){super("Token account has a delegate");n(this,"code",6008);n(this,"name","InvalidDelegate");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ne)}};m.set(6008,()=>new Ce);f.set("InvalidDelegate",()=>new Ce);var Re=class Ke extends Error{constructor(){super("InvalidInput");n(this,"code",6009);n(this,"name","InvalidInput");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ke)}};m.set(6009,()=>new Re);f.set("InvalidInput",()=>new Re);var Oe=class qe extends Error{constructor(){super("Address of the provided swap token account is incorrect");n(this,"code",6010);n(this,"name","IncorrectSwapAccount");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,qe)}};m.set(6010,()=>new Oe);f.set("IncorrectSwapAccount",()=>new Oe);var Le=class Ue extends Error{constructor(){super("Address of the provided pool token mint is incorrect");n(this,"code",6011);n(this,"name","IncorrectPoolMint");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ue)}};m.set(6011,()=>new Le);f.set("IncorrectPoolMint",()=>new Le);var Je=class Ge extends Error{constructor(){super("InvalidOutput");n(this,"code",6012);n(this,"name","InvalidOutput");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ge)}};m.set(6012,()=>new Je);f.set("InvalidOutput",()=>new Je);var $e=class _e extends Error{constructor(){super("General calculation failure due to overflow or underflow");n(this,"code",6013);n(this,"name","CalculationFailure");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_e)}};m.set(6013,()=>new $e);f.set("CalculationFailure",()=>new $e);var Ze=class Ve extends Error{constructor(){super("Invalid instruction");n(this,"code",6014);n(this,"name","InvalidInstruction");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ve)}};m.set(6014,()=>new Ze);f.set("InvalidInstruction",()=>new Ze);var je=class He extends Error{constructor(){super("Swap input token accounts have the same mint");n(this,"code",6015);n(this,"name","RepeatedMint");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,He)}};m.set(6015,()=>new je);f.set("RepeatedMint",()=>new je);var Qe=class Xe extends Error{constructor(){super("Swap instruction exceeds desired slippage limit");n(this,"code",6016);n(this,"name","ExceededSlippage");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xe)}};m.set(6016,()=>new Qe);f.set("ExceededSlippage",()=>new Qe);var Ye=class et extends Error{constructor(){super("Token account has a close authority");n(this,"code",6017);n(this,"name","InvalidCloseAuthority");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,et)}};m.set(6017,()=>new Ye);f.set("InvalidCloseAuthority",()=>new Ye);var tt=class ot extends Error{constructor(){super("Pool token mint has a freeze authority");n(this,"code",6018);n(this,"name","InvalidFreezeAuthority");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ot)}};m.set(6018,()=>new tt);f.set("InvalidFreezeAuthority",()=>new tt);var rt=class nt extends Error{constructor(){super("Pool fee token account incorrect");n(this,"code",6019);n(this,"name","IncorrectFeeAccount");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,nt)}};m.set(6019,()=>new rt);f.set("IncorrectFeeAccount",()=>new rt);var it=class at extends Error{constructor(){super("Given pool token amount results in zero trading tokens");n(this,"code",6020);n(this,"name","ZeroTradingTokens");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,at)}};m.set(6020,()=>new it);f.set("ZeroTradingTokens",()=>new it);var st=class ut extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0");n(this,"code",6021);n(this,"name","FeeCalculationFailure");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ut)}};m.set(6021,()=>new st);f.set("FeeCalculationFailure",()=>new st);var ct=class lt extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow");n(this,"code",6022);n(this,"name","ConversionFailure");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,lt)}};m.set(6022,()=>new ct);f.set("ConversionFailure",()=>new ct);var dt=class pt extends Error{constructor(){super("The provided fee does not match the program owner's constraints");n(this,"code",6023);n(this,"name","InvalidFee");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pt)}};m.set(6023,()=>new dt);f.set("InvalidFee",()=>new dt);var mt=class ft extends Error{constructor(){super("The provided token program does not match the token program expected by the swap");n(this,"code",6024);n(this,"name","IncorrectTokenProgramId");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ft)}};m.set(6024,()=>new mt);f.set("IncorrectTokenProgramId",()=>new mt);var kt=class yt extends Error{constructor(){super("The provided curve type is not supported by the program owner");n(this,"code",6025);n(this,"name","UnsupportedCurveType");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,yt)}};m.set(6025,()=>new kt);f.set("UnsupportedCurveType",()=>new kt);var wt=class St extends Error{constructor(){super("The provided curve parameters are invalid");n(this,"code",6026);n(this,"name","InvalidCurve");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,St)}};m.set(6026,()=>new wt);f.set("InvalidCurve",()=>new wt);var vt=class Tt extends Error{constructor(){super("The operation cannot be performed on the given curve");n(this,"code",6027);n(this,"name","UnsupportedCurveOperation");typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Tt)}};m.set(6027,()=>new vt);f.set("UnsupportedCurveOperation",()=>new vt);var Ht=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"CloseInstructionArgs"),Qt=[98,165,201,177,108,65,206,96];function Xt(e,t=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=Ht.serialize({instructionDiscriminator:Qt}),s=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.payer,isWritable:!0,isSigner:!0},{pubkey:e.tokenProgram??M,isWritable:!1,isSigner:!1},{pubkey:e.systemProgram??J.programId,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const k of e.anchorRemainingAccounts)s.push(k);return new B({programId:t,keys:s,data:o})}var Yt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["maximumTokenAAmount",i.u64],["maximumTokenBAmount",i.u64]],"DepositAllTokenTypesInstructionArgs"),eo=[32,95,69,60,75,79,205,238];function to(e,t,o=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=Yt.serialize({instructionDiscriminator:eo,...t}),u=[{pubkey:e.proofRequest??o,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userTokenA,isWritable:!0,isSigner:!1},{pubkey:e.userTokenB,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??M,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const d of e.anchorRemainingAccounts)u.push(d);return new B({programId:o,keys:u,data:s})}var oo=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["sourceTokenAmount",i.u64],["minimumPoolTokenAmount",i.u64]],"DepositSingleTokenTypeInstructionArgs"),ro=[175,0,152,41,199,0,148,43];function no(e,t,o=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=oo.serialize({instructionDiscriminator:ro,...t}),u=[{pubkey:e.proofRequest??o,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??M,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const d of e.anchorRemainingAccounts)u.push(d);return new B({programId:o,keys:u,data:s})}var io=new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["feesInput",we],["curveInput",Se],["swapPolicy",i.coption(g.publicKey)],["addLiquidityPolicy",i.coption(g.publicKey)]],"InitializeInstructionArgs"),ao=[175,175,109,31,13,152,155,237];function so(e,t,o=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=io.serialize({instructionDiscriminator:ao,...t}),u=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.tokenA,isWritable:!0,isSigner:!1},{pubkey:e.tokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??M,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const d of e.anchorRemainingAccounts)u.push(d);return new B({programId:o,keys:u,data:s})}var uo=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["amountIn",i.u64],["minimumAmountOut",i.u64]],"SwapInstructionArgs"),co=[248,198,158,145,225,117,135,200];function lo(e,t,o=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=uo.serialize({instructionDiscriminator:co,...t}),u=[{pubkey:e.proofRequest??o,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userSource,isWritable:!0,isSigner:!1},{pubkey:e.userDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolSource,isWritable:!0,isSigner:!1},{pubkey:e.poolDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.hostFeeAccount??o,isWritable:!1,isSigner:!1},{pubkey:e.tokenProgram??M,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const d of e.anchorRemainingAccounts)u.push(d);return new B({programId:o,keys:u,data:s})}var po=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["minimumTokenAAmount",i.u64],["minimumTokenBAmount",i.u64]],"WithdrawAllTokenTypesInstructionArgs"),mo=[189,254,156,174,210,9,164,216];function fo(e,t,o=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=po.serialize({instructionDiscriminator:mo,...t}),u=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??M,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const d of e.anchorRemainingAccounts)u.push(d);return new B({programId:o,keys:u,data:s})}var ko=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["destinationTokenAmount",i.u64],["maximumPoolTokenAmount",i.u64]],"WithdrawSingleTokenTypeInstructionArgs"),yo=[111,171,21,77,237,181,241,56];function wo(e,t,o=new y("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=ko.serialize({instructionDiscriminator:yo,...t}),u=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??M,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const d of e.anchorRemainingAccounts)u.push(d);return new B({programId:o,keys:u,data:s})}var So="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",vo=new y(So),{BN:w}=Pt,To=class{constructor(e){n(this,"programId",vo);this.provider=e}get connection(){return this.provider.connection}swapAuthority(e){return y.findProgramAddressSync([e.toBuffer()],this.programId)[0]}async closeTokenSwap(e,t){const o=new F,s=this.provider.publicKey,u=this.swapAuthority(e.tokenSwap),k=await this.load(e.tokenSwap),d=oe(k.tokenAMint,s),I=oe(k.tokenBMint,s);return await this.handleMissingTokenAccount(o,d,k.tokenAMint),await this.handleMissingTokenAccount(o,I,k.tokenBMint),o.add(Xt({payer:s,tokenSwap:e.tokenSwap,authority:u,destTokenA:d,destTokenB:I,swapTokenA:k.tokenA,swapTokenB:k.tokenB})),{signature:await this.provider.sendAndConfirm(o,[],t)}}async createTokenSwap(e,t){const o=new F,s=e.tokenSwap??Wt.generate(),u=Array.from({length:32}),k=Array.from(e.curveParameters??[]);for(let S=0;S<k.length;S++)u[S]=k[S];const d={curveType:e.curveType,curveParameters:u},I=this.getTokenSwapSpace(d),b=await this.connection.getMinimumBalanceForRentExemption(I);o.add(J.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:s.publicKey,programId:this.programId,lamports:b,space:I})),o.add(so({authority:this.swapAuthority(s.publicKey),tokenSwap:s.publicKey,destination:e.destination,poolMint:e.poolMint,poolFee:e.poolFee,tokenA:e.tokenA,tokenB:e.tokenB},{feesInput:{tradeFeeNumerator:new w(e.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new w(e.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new w(e.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new w(e.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new w(e.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new w(e.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new w(e.fees.hostFeeNumerator.toString()),hostFeeDenominator:new w(e.fees.hostFeeDenominator.toString())},curveInput:d,swapPolicy:e.swapPolicy??null,addLiquidityPolicy:e.addLiquidityPolicy??null}));const A=await this.provider.sendAndConfirm(o,[s],t);return{tokenSwap:s.publicKey,signature:A}}getTokenSwapSpace(e){return z.byteSize({bumpSeed:0,curve:e,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,poolFeeAccount:y.default,poolMint:y.default,tokenA:y.default,tokenAMint:y.default,tokenB:y.default,tokenBMint:y.default,tokenProgramId:y.default,swapPolicy:y.default,addLiquidityPolicy:y.default,reserved:[]})}async swap(e,t){const o=new F;return await this.handleMissingTokenAccount(o,e.userDestination,e.destinationTokenMint),await this.handleWrappedSol({tx:o,amount:e.amountIn,userSource:e.userSource,sourceTokenMint:e.sourceTokenMint}),o.add(lo({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:e.userSource,userDestination:e.userDestination,tokenSwap:e.tokenSwap,poolFee:e.poolFee,poolMint:e.poolMint,poolSource:e.poolSource,poolDestination:e.poolDestination,hostFeeAccount:e.hostFeeAccount,proofRequest:e.proofRequest},{amountIn:new w(e.amountIn.toString()),minimumAmountOut:new w(e.minimumAmountOut.toString())})),this.unwrapSol(o,e.userDestination,e.destinationTokenMint),this.provider.sendAndConfirm(o,[],t)}async depositAllTokenTypes(e,t){const o=new F;return await this.handleMissingTokenAccount(o,e.destination,e.poolMint),await this.handleWrappedSol({tx:o,amount:e.maximumTokenA,userSource:e.userTokenA,sourceTokenMint:e.tokenAMint}),await this.handleWrappedSol({tx:o,amount:e.maximumTokenB,userSource:e.userTokenB,sourceTokenMint:e.tokenBMint}),o.add(to({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,destination:e.destination,userTokenA:e.userTokenA,userTokenB:e.userTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB,proofRequest:e.proofRequest},{poolTokenAmount:new w(e.poolTokenAmount.toString()),maximumTokenAAmount:new w(e.maximumTokenA.toString()),maximumTokenBAmount:new w(e.maximumTokenB.toString())})),this.provider.sendAndConfirm(o,[],t)}async withdrawAllTokenTypes(e,t){const o=new F;return await this.handleMissingTokenAccount(o,e.destTokenA,e.tokenAMint),await this.handleMissingTokenAccount(o,e.destTokenB,e.tokenBMint),o.add(fo({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destTokenA:e.destTokenA,destTokenB:e.destTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new w(e.poolTokenAmount.toString()),minimumTokenAAmount:new w(e.minimumTokenA.toString()),minimumTokenBAmount:new w(e.minimumTokenB.toString())})),this.unwrapSol(o,e.destTokenA,e.tokenAMint),this.unwrapSol(o,e.destTokenB,e.tokenBMint),this.provider.sendAndConfirm(o,[],t)}async depositSingleTokenTypeExactAmountIn(e,t){const o=new F;return await this.handleMissingTokenAccount(o,e.destination,e.poolMint),await this.handleWrappedSol({tx:o,amount:e.sourceTokenAmount,userSource:e.source,sourceTokenMint:e.sourceTokenMint}),o.add(no({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB,proofRequest:e.proofRequest},{sourceTokenAmount:new w(e.sourceTokenAmount.toString()),minimumPoolTokenAmount:new w(e.minimumPoolTokenAmount.toString())})),this.provider.sendAndConfirm(o,[],t)}async withdrawSingleTokenTypeExactAmountOut(e,t){const o=new F;return await this.handleMissingTokenAccount(o,e.destination,e.destinationTokenMint),o.add(wo({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{destinationTokenAmount:new w(e.destinationTokenAmount.toString()),maximumPoolTokenAmount:new w(e.maximumPoolTokenAmount.toString())})),this.unwrapSol(o,e.destination,e.destinationTokenMint),this.provider.sendAndConfirm(o,[],t)}async load(e,t){return z.fromAccountAddress(this.provider.connection,new y(e),t)}async loadAll(e={}){const t=z.gpaBuilder().addFilter("accountDiscriminator",$);return e.noData&&(t.config.dataSlice={offset:0,length:0}),e.tokenProgramId&&t.addFilter("tokenProgramId",new y(e.tokenProgramId)),e.poolMint&&t.addFilter("poolMint",new y(e.poolMint)),e.tokenAMint&&t.addFilter("tokenAMint",new y(e.tokenAMint)),e.tokenBMint&&t.addFilter("tokenBMint",new y(e.tokenBMint)),(await t.run(this.provider.connection)).map(({pubkey:o,account:s})=>({pubkey:o,data:e.noData?null:z.fromAccountInfo(s)[0]}))}unwrapSol(e,t,o){o&&o.toBase58()===re.toBase58()&&e.add(Vt(t,this.provider.publicKey,this.provider.publicKey))}async handleMissingTokenAccount(e,t,o){try{await G(this.connection,t)}catch(s){(s instanceof ne||s instanceof ie)&&o&&e.add(ae(this.provider.publicKey,t,this.provider.publicKey,o))}}async handleWrappedSol(e){if(e.sourceTokenMint&&e.sourceTokenMint?.toBase58()===re.toBase58()){let t=0;try{if((await q(e.sourceTokenMint,this.provider.publicKey)).toBase58()!==e.userSource.toBase58())return;const u=await G(this.connection,e.userSource);t=Number(u.amount)}catch(s){(s instanceof ne||s instanceof ie)&&e.tx.add(ae(this.provider.publicKey,e.userSource,this.provider.publicKey,e.sourceTokenMint))}const o=Number(e.amount);e.amount>t&&e.tx.add(J.transfer({fromPubkey:this.provider.publicKey,toPubkey:e.userSource,lamports:o-t}),jt(e.userSource))}}},Ao=(e=>(e[e.ASC=0]="ASC",e[e.DESC=1]="DESC",e))(Ao||{});const Io=xt("swap",()=>{const e=Dt(),t=zt(),o=Ct(),s=Nt(),{publicKey:u}=Rt(),{notify:k}=Kt(),d=Ot(()=>new To(new se(e.connection,s.value??{publicKey:y.default},se.defaultOptions()))),I=x({}),b=x([]),A=x([]),S=x([]),c=x(),W=ue("token-a",""),P=ue("token-b",""),r=qt({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:ce,to:ce,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:At,tokens:E}=Lt();At(Ut),h(E,()=>{if(E.value.length>=2){const a=E.value.find(p=>p.mint===W.value)??E.value[0];let l=E.value.find(p=>p.mint===P.value)??E.value[1];if(r.from=E.value.find(p=>p.mint===W.value)??E.value[0],r.to=E.value.find(p=>p.mint===P.value)??E.value[1],a===l){const p=E.value.find(v=>v.mint!==a.mint);p&&(l=p)}r.from=a,r.to=l}},{immediate:!0}),h(()=>r.from,()=>{r.from&&(W.value=r.from.mint)}),h(()=>r.to,()=>{r.to&&(P.value=r.to.mint)});const _=U(async()=>{r.loading=!0;try{console.log("swapClient ================: ",d.value),b.value=await d.value.loadAll(),console.log("swaps ================: ",b.value)}catch(a){console.log(a),b.value=[]}finally{r.loading=!1}},400);h([s,()=>e.cluster],async a=>{_()?.then(),a||gt()},{immediate:!0});const Z=U(async()=>{if(u.value&&A.value.length>0){const a={};for(const l of A.value)try{const p=await q(l.data.poolMint,u.value),v=await G(e.connection,p);a[l.data.poolMint.toBase58()]=Number(v.amount),console.log("userAcc === ",v)}catch{}I.value=a}},500);h([u,A],Z,{immediate:!0});const L=x(!1),C=U(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!c.value){L.value=!0;try{const a=await Jt(e.connection,d.value.swapAuthority(c.value.pubkey)),l={};for(const v of a)l[`${v.mint}`]=v.amount;r.poolBalance=l;const p=await Gt(e.connection,c.value.data.poolMint);r.poolTokenSupply=Number(p.supply),console.log("[Pool Balance] poolMint",p),console.log("[Pool Balance]",r.poolBalance),console.log("[Pool Balance] poolTokenSupply",r.poolTokenSupply)}catch(a){console.log("[Pool Balance] error",a)}finally{L.value=!1}}},500);setInterval(C,6e4);function ht(a){c.value=a,console.log("setTokenSwap: ",c.value)}h([b,()=>o.servicePolicy],async()=>{console.log("tokenSwapsAll: ",b.value),A.value=b.value.filter(a=>!!o.servicePolicy.find(l=>l.pubkey.toBase58()===a.data.swapPolicy?.toBase58())&&!!o.servicePolicy.find(l=>l.pubkey.toBase58()===a.data.addLiquidityPolicy?.toBase58())&&!!t.tokenByMint(a.data.tokenAMint.toBase58())&&!!t.tokenByMint(a.data.tokenBMint.toBase58()))},{immediate:!0}),h([A,()=>r.from?.mint,()=>r.to?.mint,()=>o.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",A.value),A.value&&r.from?.mint&&r.to?.mint&&r.from.mint!==r.to.mint&&o.servicePolicy.length)if(S.value=A.value.filter(a=>{const l=a.data?.tokenAMint.toBase58(),p=a.data?.tokenBMint.toBase58();return l===r.from.mint&&p===r.to.mint||l===r.to.mint&&p===r.from.mint}),S.value.length){if(S.value.length>1){const a=S.value.find(l=>o.state.certificates?.find(p=>p.data?.policy.toBase58()===l.data.swapPolicy?.toBase58()||p.data?.policy.toBase58()===l.data.addLiquidityPolicy?.toBase58()));a&&(c.value=a)}c.value=S.value[0]}else c.value=void 0;else S.value=[],c.value=void 0,o.setContractPolicy("","swap"),o.setContractPolicy("","liquidity"),r.poolBalance={}},{immediate:!0}),h([c],async()=>{console.log("Token SWAP: ",c.value),o.setContractPolicy(c.value?.data.swapPolicy?.toBase58()??"","swap"),o.setContractPolicy(c.value?.data.addLiquidityPolicy?.toBase58()??"","liquidity"),c.value&&(C(),c.value.data.tokenAMint.toBase58()===r.from.mint?r.direction=0:r.direction=1)},{immediate:!0});function gt(){r.loading=!1,r.slippageDialog=!1,r.poolBalance={},r.poolTokenSupply=0}h([()=>r.direction,()=>r.from.amount,()=>r.poolBalance],async()=>{const a=Number(r.from.amount??0),l=le(Number(r.poolBalance[r.from.mint]??0),r.from.decimals),p=le(Number(r.poolBalance[r.to.mint]??0),r.to.decimals),v=1-r.fees.ownerTrade-r.fees.trade;if(a===0||Number.isNaN(a)){r.to.amount=0,r.rate=Number(p)/Number(l)*v,r.impact=0,r.minimumReceived=0;return}const T=p-l*p/(l+a*v);r.rate=a?T/a:p/l,r.to.amount=T?Number($t(T,r.to.decimals)):0,r.impact=a?1-T/a/v/(p/l):0,r.minimumReceived=R(r.to.amount-r.to.amount*r.slippage,r.to.decimals)},{immediate:!0});async function bt(){if(!o.certificateValid)return _t();if(!c.value||!u.value){console.log("Pool is not selected...");return}s.value.publicKey||k({type:"info",message:"Please connect your wallet first"});const l=Number(R(r.from.amount??0,r.from.decimals)),p=Number(R(o.tokenBalance(r.from.mint)??0,r.from.decimals)),v=Number(R(r.to.amount??0,r.to.decimals));if(l>p){k({type:"negative",message:"Insufficient balance."});return}try{r.swapping=!0;const T=r.direction===0?c.value.data.tokenAMint:c.value.data.tokenBMint,N=r.direction===0?c.value.data.tokenBMint:c.value.data.tokenAMint,H=r.direction===0?c.value.data.tokenA:c.value.data.tokenB,Q=r.direction===0?c.value.data.tokenB:c.value.data.tokenA;console.log("userSourceMint = ",T.toBase58()),console.log("userDestinationMint = ",N.toBase58()),console.log("userSourceMint = ",T.toBase58()),console.log("userDestinationMint = ",N.toBase58());const X=await q(T,s.value.publicKey),Y=await q(N,s.value.publicKey),ee=l;console.log("toAmount = ",v),console.log("slippage = ",r.slippage),console.log("slippage 2 = ",v*r.slippage);const te=d.value.swapAuthority(c.value.pubkey);console.log("proofRequest = ",o.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",te),console.log("tokenSwap = ",c.value.pubkey.toBase58()),console.log("userSource = ",X.toBase58()),console.log("userDestination = ",Y.toBase58()),console.log("poolSource = ",H.toBase58()),console.log("poolDestination = ",Q.toBase58()),console.log("poolMint = ",c.value.data.poolMint.toBase58()),console.log("poolFee = ",c.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",ee),console.log("minimumAmountOut = ",r.minimumReceived);const Bt=await d.value.swap({proofRequest:o.certificate?.pubkey,authority:te,tokenSwap:c.value.pubkey,userSource:X,userDestination:Y,poolSource:H,poolDestination:Q,poolMint:c.value.data.poolMint,poolFee:c.value.data.poolFeeAccount,amountIn:ee,minimumAmountOut:r.minimumReceived,sourceTokenMint:T,destinationTokenMint:N},{commitment:"confirmed"});k({message:"Transaction confirmed",type:"positive",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${Bt}?cluster=${e.cluster}`,onClick:()=>!1}]}),V()}catch(T){console.log(T),console.error(T.logs),`${T}`.includes("User rejected the request")||k({type:"negative",message:`${T}`})}finally{r.swapping=!1}}function Et(){const{from:a,to:l}=r;r.rate=0,r.to={...a,amount:void 0},r.from={...l,amount:void 0},r.direction=r.direction===0?1:0}function It(){r.slippageDialog=!1}function V(){C(),r.from.amount=void 0,r.to.amount=void 0}h(()=>s.value?.publicKey,a=>{a||V()}),h(()=>r.to,a=>{a.amount&&(a.amount=void 0)});function j(a){return{host:K(a.fees.hostFeeNumerator,a.fees.hostFeeDenominator),trade:K(a.fees.tradeFeeNumerator,a.fees.tradeFeeDenominator),ownerTrade:K(a.fees.ownerTradeFeeNumerator,a.fees.ownerTradeFeeDenominator),ownerWithdraw:K(a.fees.ownerWithdrawFeeNumerator,a.fees.ownerWithdrawFeeDenominator)}}return h(c,a=>{if(!a)return;const l=j(a.data);r.fees.host=l.host,r.fees.trade=l.trade,r.fees.ownerTrade=l.ownerTrade,r.fees.ownerWithdraw=l.ownerWithdraw,console.log("fees ==== ",r.fees)}),{state:r,tokenSwapsAllFiltered:A,tokenSwaps:S,tokenSwap:c,swapClient:d,loadingPoolTokens:L,loadPoolTokenAccounts:C,setTokenSwap:ht,closeSlippage:It,changeDirection:Et,swapSubmit:bt,getPoolFee:j,init:_,tokenAMint:W,tokenBMint:P,userPoolsTokens:I,reloadUserLP:Z}});export{Ao as S,jt as c,Io as u};
