var U=Object.defineProperty;var $=(t,e,s)=>e in t?U(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s;var z=(t,e,s)=>($(t,typeof e!="symbol"?e+"":e,s),s);import{_ as B,o as D,j as F,m as q,n as v,p as H,S as I,i as O,P as T,h as M,u as E,q as J,t as Q,s as G,w as X,x as j,y as Z,z as ee,A as N,B as R,C,F as te,G as ne,H as se,L as ae,I as ie,J as oe,K,N as re,O as S,Q as ce,k as m,R as A,U as L,V as l,W as r,X as le,Y as W,Z as V,$ as Y,a0 as de,a1 as ue}from"./index-dc55865a.js";import{u as P,s as fe,a as pe,f as me,Q as x,o as he,b as ge,_ as ve}from"./token-d350a281.js";const _e={},ye={class:"swap-content"},we=q('<div class="row"><div class="swap-content__title"> Compliant DeFi with KYC </div><div class="swap-content__details"><p> Compliant DeFi with KYC (Know Your Customer) and AML (Anti-Money Laundering) refers to a type of decentralized finance (DeFi) that incorporates customer identification and anti-money laundering measures to ensure compliance with regulatory requirements. </p><p> KYC refers to the process of verifying the identity of a customer to assess their risk profile and prevent illegal activities such as money laundering and financing of terrorism. In Compliant DeFi with KYC, users are required to provide personal information and undergo identity verification procedures before they can participate in DeFi activities. </p><p> AML refers to the set of policies, procedures, and regulations aimed at detecting and preventing money laundering. In Compliant DeFi with AML, transactions are monitored and analyzed to identify any suspicious or illegal activities. </p><p> By incorporating KYC and AML measures, Compliant DeFi aims to enhance the transparency and security of DeFi transactions while ensuring regulatory compliance. This helps to mitigate the risk of illegal activities in the DeFi ecosystem and enhance the trust and confidence of users, regulators, and other stakeholders. In conclusion, Compliant DeFi with KYC and AML is a new and evolving segment of the DeFi ecosystem that seeks to balance the benefits of decentralized finance with the need for regulatory compliance and security. </p></div></div><div class="row"><div class="swap-content__title"> What zKKYC? What are the benefits? </div><div class="swap-content__details"><p> zKKYC (Zero-Knowledge KYC) is a privacy-preserving technology that enables users to prove their identity without revealing their personal information. It is based on zero-knowledge proofs, a cryptographic technique that allows users to prove the validity of information without revealing the actual data. zKKYC provides a number of benefits over traditional KYC (Know Your Customer) methods that rely on sharing personal information with the platform or a third party: </p><ul class="swap-details"><li> Privacy: zKKYC allows users to prove their identity without revealing their personal information, providing greater privacy and control over their data. </li><li> Security: zKKYC eliminates the risk of personal information being stolen or misused, as the information is not stored or transmitted. </li><li> Convenience: zKKYC enables users to complete the KYC process quickly and easily, without having to provide personal information or wait for manual verification. </li><li> Compliance: zKKYC enables DeFi platforms to comply with regulatory requirements while still preserving user privacy and security. In conclusion, zKKYC is a cutting-edge technology that provides a solution to the challenges posed by traditional KYC methods and offers numerous benefits to both users and platforms in the DeFi ecosystem. </li></ul></div></div>',2),be=[we];function ke(t,e){return D(),F("div",ye,be)}const Se=B(_e,[["render",ke]]),Te=new v.BeetArgsStruct([["instructionDiscriminator",v.uniformFixedSizeArray(v.u8,8)],["amount",v.u64]],"SplTransferInstructionArgs"),Ce=[67,186,237,99,235,243,166,198];function Ke(t,e,s=new T("ChfXD6UnExK5ihM1LJcnNGVJekVtHWms5cJu47pH9Fe2")){const[i]=Te.serialize({instructionDiscriminator:Ce,...e}),o=[{pubkey:t.sender,isWritable:!0,isSigner:!0},{pubkey:t.receiver,isWritable:!0,isSigner:!1},{pubkey:t.tokenMint,isWritable:!1,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.zkpRequest,isWritable:!1,isSigner:!1},{pubkey:t.tokenProgram??H,isWritable:!1,isSigner:!1},{pubkey:t.systemProgram??I.programId,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const n of t.anchorRemainingAccounts)o.push(n);return new O({programId:s,keys:o,data:i})}const Ae=new v.BeetArgsStruct([["instructionDiscriminator",v.uniformFixedSizeArray(v.u8,8)],["amount",v.u64]],"TransferInstructionArgs"),De=[163,52,200,231,140,3,69,186];function Me(t,e,s=new T("ChfXD6UnExK5ihM1LJcnNGVJekVtHWms5cJu47pH9Fe2")){const[i]=Ae.serialize({instructionDiscriminator:De,...e}),o=[{pubkey:t.sender,isWritable:!0,isSigner:!0},{pubkey:t.receiver,isWritable:!0,isSigner:!1},{pubkey:t.zkpRequest,isWritable:!1,isSigner:!1},{pubkey:t.systemProgram??I.programId,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const n of t.anchorRemainingAccounts)o.push(n);return new O({programId:s,keys:o,data:i})}const Fe="ChfXD6UnExK5ihM1LJcnNGVJekVtHWms5cJu47pH9Fe2",Ie=new T(Fe);class ze{constructor(e){z(this,"programId",Ie);this.provider=e}get connection(){return this.provider.connection}async transfer(e,s){const i=Me({receiver:e.receiver,sender:this.provider.publicKey,zkpRequest:e.zkpRequest},{amount:e.amount}),o=new M().add(i);return await this.provider.sendAndConfirm(o,[],s)}async splTransfer(e,s){const i=Ke({destination:e.destination,receiver:e.receiver,sender:this.provider.publicKey,source:e.source,tokenMint:e.tokenMint,zkpRequest:e.zkpRequest},{amount:e.amount}),o=new M().add(i);return await this.provider.sendAndConfirm(o,[],s)}}function Ne(){const t=E(),{notify:e}=J(),s=Q(t,"cluster"),i=G(!1);async function o(_,{onSuccess:n,onError:y,idx:c,commitment:h=X,sendTimeout:w=j,confirmTimeout:g=Z}={}){c=c??"";let p=e({progress:!0,type:"ongoing",message:c?`Sending transaction "${c}" ...`:"Sending transaction...",timeout:w});const b={label:"Close",color:"white"};i.value=!0;let a="";try{a=String(await _)}catch(d){i.value=!1,p(),String(d?.message).startsWith("User rejected")||e({message:c?`Transaction "${c}" error`:"Transaction error",caption:d?.message,type:"negative",timeout:0,actions:[b]});return}const f={label:"Explore",color:"white",target:"_blank",href:`https://solscan.io/tx/${a}?cluster=${s.value}`,onClick:()=>!1};try{p(),p=e({progress:!0,type:"ongoing",message:c?`Confirming transaction "${c}" ...`:"Confirming transaction...",actions:[f],timeout:g});const d=await t.connection.getLatestBlockhash(),k=await t.connection.confirmTransaction({blockhash:d.blockhash,lastValidBlockHeight:d.lastValidBlockHeight,signature:a},h);if(p(),k.value.err)throw new Error(JSON.stringify(k.value.err));p=e({message:c?`Transaction "${c}" confirmed`:"Transaction confirmed",type:"positive",actions:[f]}),n&&n(a)}catch(d){p(),e({message:c?`Transaction "${c}" error`:"Transaction error",caption:d.message,type:"negative",timeout:0,actions:[f,b]}),y&&y(d),console.error(d)}finally{i.value=!1}}return{monitorTransaction:o,sending:i}}const Re=ee("transfer",()=>{const{monitorTransaction:t}=Ne(),e=E(),{getTokens:s}=P(),i=0,o=N(),_=R({image:fe,value:"sol",label:"sol"}),n=R({address:"",value:void 0,loading:!1,token:_,fee:i,valid:!1});let y;C(N(),a=>{if(a){const u=te(a,e.connection);y=new ze(u),console.log(y)}},{deep:!0});function c(a){n.value=a}function h(a){n.token=a}function w(){n.address="",n.value=void 0,n.fee=i}C(()=>n.token,()=>{w()}),C(()=>n.address,async()=>{n.valid=await ne(n.address)}),C([()=>n.valid,()=>n.value],async([a,u])=>{a&&Number(u)>0?p():n.fee=i});async function g(){const a=new T(o.value?.publicKey),u=new T(n.address),f=new M().add(I.transfer({fromPubkey:a,toPubkey:u,lamports:Number(n.value)*ae})),d=(await e.connection.getLatestBlockhash("finalized")).blockhash;return f.recentBlockhash=d,f.feePayer=o.value?.publicKey,f}async function p(){const a=await g();n.fee=await se(a,e.connection)}async function b(){try{n.loading=!0;const a=await g(),{instructions:u}=a;console.log("instructions => ",u),await t(ie(e.connection,o.value,u,[]),{onSuccess:async()=>{console.log("[Transaction] Success"),w(),s()}})}finally{n.loading=!1}}return{state:n,setMax:c,setToken:h,transferSOL:b}}),Le={class:"swap-form"},We={class:"swap-field"},Ve={class:"swap-field__info"},Ye={class:"row"},xe=l("div",{class:"col-2 swap-field__label"}," AMOUNT ",-1),Be={class:"col row justify-end swap-field__balance q-pr-sm"},Oe={key:0,class:"insufficient-error"},Ee=l("div",{class:"col-3 swap-field__label q-pl-sm"}," ASSET ",-1),Pe={class:"row justify-between",style:{gap:"10px"}},Ue={class:"transfer-address"},$e=l("div",{class:"col transfer-address__label"}," Address ",-1),qe={class:"swap-info"},He=l("dt",null,"Transfer fee:",-1),Je={class:"swap-submit transfer-submit"},Qe=oe({__name:"TransferCard",setup(t){const{state:e,setMax:s,transferSOL:i,setToken:o}=Re(),{state:_}=P(),{handleSearchToken:n,options:y,tokenBalance:c}=pe(),h=K(()=>c(e.token.label)),w=K(()=>h.value===0),g=K(()=>Number(e.value)>h.value);async function p(){const u=g.value?"Insufficient funds":"Not valid address";if(!e.valid||g.value)return Y.create({type:"negative",timeout:2e3,message:u});i()}function b(){s(h.value),e.token.value==="sol"&&Y.create({type:"negative",timeout:0,message:"When transferring all funds, you will no longer be able to sign transactions! Leave not a lot of SOL on the account",actions:[{icon:de,color:"white"}]})}const a=K(()=>Number(e.value)>0&&e.address.length>=44);return(u,f)=>{const d=ve;return D(),re(ce,{class:"swap-card transfer-card"},{default:S(()=>[m(L,{class:"swap-card__header"},{default:S(()=>[A(" Transfer ")]),_:1}),m(L,{class:"swap-card__body"},{default:S(()=>[l("div",Le,[l("div",We,[l("div",Ve,[l("div",Ye,[xe,l("div",Be,[r(g)?(D(),F("div",Oe," Insufficient funds ")):le("",!0),A(" Balance: "+W(r(me)(r(h))),1)]),Ee])]),l("div",Pe,[m(x,{modelValue:r(e).value,"onUpdate:modelValue":f[0]||(f[0]=k=>r(e).value=k),maxlength:14,outlined:"",placeholder:"0.0",class:"swap-input col",disable:r(w),onKeypress:r(he)},{append:S(()=>[m(V,{dense:"",unelevated:"",ripple:!1,class:"swap-input__max",onClick:b},{default:S(()=>[A(" MAX ")]),_:1})]),_:1},8,["modelValue","disable","onKeypress"]),m(d,{options:r(y),onHandleSearchToken:r(n),onSetToken:r(o)},null,8,["options","onHandleSearchToken","onSetToken"])])])]),l("div",Ue,[$e,m(x,{modelValue:r(e).address,"onUpdate:modelValue":f[1]||(f[1]=k=>r(e).address=k),disable:r(w),maxlength:50,outlined:"",class:"swap-input col"},null,8,["modelValue","disable"])]),l("div",qe,[l("dl",null,[He,l("dd",null,W(r(e).fee),1)])]),l("div",Je,[m(V,{loading:r(e).loading,disable:!r(a),rounded:"",ripple:!1,onClick:p},{default:S(()=>[A(" Send ")]),_:1},8,["loading","disable"])])]),_:1}),m(ge,{showing:r(_).loading,class:"swap-loading",color:"grey"},null,8,["showing"])]),_:1})}}}),Ge={};function Xe(t,e){const s=Qe,i=Se;return D(),F(ue,null,[m(s),m(i)],64)}const tt=B(Ge,[["render",Xe]]);export{tt as default};
