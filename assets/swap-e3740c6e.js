import{m as f,ao as we,ap as Se,a as Oe,q as M,b9 as Fe,ba as We,aq as tt,bb as ot,k as i,bc as T,n as x,bd as nt,S as xe,R as y,s as rt,u as it,w as at,x as st,y as ct,z as ut,v as lt,K as ze,P as pt,G as z,A as Pe,B as dt,be as De,W as mt,H as ft,C as A,bf as yt,bg as ht,bh as kt,ax as Ie,a6 as wt,aF as I,Q as St,I as Ce,bi as C}from"./index-73c4a0a1.js";import{b as B,d as At,A as gt,g as me,T as fe,a as ye,c as he,N as Ne}from"./associatedTokenAccount-a3b7c792.js";var K;(function(e){e[e.InitializeMint=0]="InitializeMint",e[e.InitializeAccount=1]="InitializeAccount",e[e.InitializeMultisig=2]="InitializeMultisig",e[e.Transfer=3]="Transfer",e[e.Approve=4]="Approve",e[e.Revoke=5]="Revoke",e[e.SetAuthority=6]="SetAuthority",e[e.MintTo=7]="MintTo",e[e.Burn=8]="Burn",e[e.CloseAccount=9]="CloseAccount",e[e.FreezeAccount=10]="FreezeAccount",e[e.ThawAccount=11]="ThawAccount",e[e.TransferChecked=12]="TransferChecked",e[e.ApproveChecked=13]="ApproveChecked",e[e.MintToChecked=14]="MintToChecked",e[e.BurnChecked=15]="BurnChecked",e[e.InitializeAccount2=16]="InitializeAccount2",e[e.SyncNative=17]="SyncNative",e[e.InitializeAccount3=18]="InitializeAccount3",e[e.InitializeMultisig2=19]="InitializeMultisig2",e[e.InitializeMint2=20]="InitializeMint2",e[e.GetAccountDataSize=21]="GetAccountDataSize",e[e.InitializeImmutableOwner=22]="InitializeImmutableOwner",e[e.AmountToUiAmount=23]="AmountToUiAmount",e[e.UiAmountToAmount=24]="UiAmountToAmount",e[e.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",e[e.TransferFeeExtension=26]="TransferFeeExtension",e[e.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",e[e.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",e[e.Reallocate=29]="Reallocate",e[e.MemoTransferExtension=30]="MemoTransferExtension",e[e.CreateNativeMint=31]="CreateNativeMint",e[e.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",e[e.InterestBearingMintExtension=33]="InterestBearingMintExtension",e[e.CpiGuardExtension=34]="CpiGuardExtension",e[e.InitializePermanentDelegate=35]="InitializePermanentDelegate",e[e.TransferHookExtension=36]="TransferHookExtension",e[e.MetadataPointerExtension=39]="MetadataPointerExtension"})(K||(K={}));function bt(e,t,n){if(n.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const s of n)e.push({pubkey:s instanceof f?s:s.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}const Ke=we([Se("instruction")]);function vt(e,t,n,s=[],a=B){const l=bt([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}],n,s),k=Oe.Buffer.alloc(Ke.span);return Ke.encode({instruction:K.CloseAccount},k),new M({keys:l,programId:a,data:k})}const Tt=we([Fe("mintAuthorityOption"),We("mintAuthority"),tt("supply"),Se("decimals"),ot("isInitialized"),Fe("freezeAuthorityOption"),We("freezeAuthority")]);Tt.span;async function Bt(e,t,n=!1,s=B,a=gt){if(!n&&!f.isOnCurve(t.toBuffer()))throw new At;const[l]=await f.findProgramAddress([t.toBuffer(),s.toBuffer(),e.toBuffer()],a);return l}const Re=we([Se("instruction")]);function Mt(e,t=B){const n=[{pubkey:e,isSigner:!1,isWritable:!0}],s=Oe.Buffer.alloc(Re.span);return Re.encode({instruction:K.SyncNative},s),new M({keys:n,programId:t,data:s})}var Et=Object.defineProperty,Ft=(e,t,n)=>t in e?Et(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,r=(e,t,n)=>(Ft(e,typeof t!="symbol"?t+"":t,n),n);const qe=new i.BeetArgsStruct([["tradeFeeNumerator",i.u64],["tradeFeeDenominator",i.u64],["ownerTradeFeeNumerator",i.u64],["ownerTradeFeeDenominator",i.u64],["ownerWithdrawFeeNumerator",i.u64],["ownerWithdrawFeeDenominator",i.u64],["hostFeeNumerator",i.u64],["hostFeeDenominator",i.u64]],"FeesInfo"),Le=new i.BeetArgsStruct([["curveType",i.u8],["curveParameters",i.uniformFixedSizeArray(i.u8,32)]],"CurveInfo"),ke=[135,144,215,161,140,125,41,96];class g{constructor(t,n,s,a,l,k,S,w,u,E,b,o){this.isInitialized=t,this.bumpSeed=n,this.tokenProgramId=s,this.tokenA=a,this.tokenB=l,this.poolMint=k,this.tokenAMint=S,this.tokenBMint=w,this.poolFeeAccount=u,this.fees=E,this.curve=b,this.policy=o}static fromArgs(t){return new g(t.isInitialized,t.bumpSeed,t.tokenProgramId,t.tokenA,t.tokenB,t.poolMint,t.tokenAMint,t.tokenBMint,t.poolFeeAccount,t.fees,t.curve,t.policy)}static fromAccountInfo(t,n=0){return g.deserialize(t.data,n)}static async fromAccountAddress(t,n,s){const a=await t.getAccountInfo(n,s);if(a==null)throw new Error(`Unable to find TokenSwap account at ${n}`);return g.fromAccountInfo(a,0)[0]}static gpaBuilder(t=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return T.GpaBuilder.fromStruct(t,N)}static deserialize(t,n=0){return N.deserialize(t,n)}serialize(){return N.serialize({accountDiscriminator:ke,...this})}static byteSize(t){const n=g.fromArgs(t);return N.toFixedFromValue({accountDiscriminator:ke,...n}).byteSize}static async getMinimumBalanceForRentExemption(t,n,s){return n.getMinimumBalanceForRentExemption(g.byteSize(t),s)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const N=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["isInitialized",i.bool],["bumpSeed",i.u8],["tokenProgramId",T.publicKey],["tokenA",T.publicKey],["tokenB",T.publicKey],["poolMint",T.publicKey],["tokenAMint",T.publicKey],["tokenBMint",T.publicKey],["poolFeeAccount",T.publicKey],["fees",qe],["curve",Le],["policy",i.coption(T.publicKey)]],g.fromArgs,"TokenSwap"),p=new Map,d=new Map;class R extends Error{constructor(){super("Swap account already in use"),r(this,"code",6e3),r(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,R)}}p.set(6e3,()=>new R);d.set("AlreadyInUse",()=>new R);class O extends Error{constructor(){super("Invalid program address generated from bump seed and key"),r(this,"code",6001),r(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,O)}}p.set(6001,()=>new O);d.set("InvalidProgramAddress",()=>new O);class q extends Error{constructor(){super("Input account owner is not the program address"),r(this,"code",6002),r(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,q)}}p.set(6002,()=>new q);d.set("InvalidOwner",()=>new q);class L extends Error{constructor(){super("Output pool account owner cannot be the program address"),r(this,"code",6003),r(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,L)}}p.set(6003,()=>new L);d.set("InvalidOutputOwner",()=>new L);class U extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),r(this,"code",6004),r(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,U)}}p.set(6004,()=>new U);d.set("ExpectedMint",()=>new U);class G extends Error{constructor(){super("Deserialized account is not an SPL Token account"),r(this,"code",6005),r(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G)}}p.set(6005,()=>new G);d.set("ExpectedAccount",()=>new G);class J extends Error{constructor(){super("Input token account empty"),r(this,"code",6006),r(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,J)}}p.set(6006,()=>new J);d.set("EmptySupply",()=>new J);class $ extends Error{constructor(){super("Pool token mint has a non-zero supply"),r(this,"code",6007),r(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$)}}p.set(6007,()=>new $);d.set("InvalidSupply",()=>new $);class H extends Error{constructor(){super("Token account has a delegate"),r(this,"code",6008),r(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,H)}}p.set(6008,()=>new H);d.set("InvalidDelegate",()=>new H);class Q extends Error{constructor(){super("InvalidInput"),r(this,"code",6009),r(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Q)}}p.set(6009,()=>new Q);d.set("InvalidInput",()=>new Q);class V extends Error{constructor(){super("Address of the provided swap token account is incorrect"),r(this,"code",6010),r(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,V)}}p.set(6010,()=>new V);d.set("IncorrectSwapAccount",()=>new V);class Z extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),r(this,"code",6011),r(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Z)}}p.set(6011,()=>new Z);d.set("IncorrectPoolMint",()=>new Z);class j extends Error{constructor(){super("InvalidOutput"),r(this,"code",6012),r(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,j)}}p.set(6012,()=>new j);d.set("InvalidOutput",()=>new j);class X extends Error{constructor(){super("General calculation failure due to overflow or underflow"),r(this,"code",6013),r(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,X)}}p.set(6013,()=>new X);d.set("CalculationFailure",()=>new X);class Y extends Error{constructor(){super("Invalid instruction"),r(this,"code",6014),r(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Y)}}p.set(6014,()=>new Y);d.set("InvalidInstruction",()=>new Y);class _ extends Error{constructor(){super("Swap input token accounts have the same mint"),r(this,"code",6015),r(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_)}}p.set(6015,()=>new _);d.set("RepeatedMint",()=>new _);class ee extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),r(this,"code",6016),r(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ee)}}p.set(6016,()=>new ee);d.set("ExceededSlippage",()=>new ee);class te extends Error{constructor(){super("Token account has a close authority"),r(this,"code",6017),r(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,te)}}p.set(6017,()=>new te);d.set("InvalidCloseAuthority",()=>new te);class oe extends Error{constructor(){super("Pool token mint has a freeze authority"),r(this,"code",6018),r(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,oe)}}p.set(6018,()=>new oe);d.set("InvalidFreezeAuthority",()=>new oe);class ne extends Error{constructor(){super("Pool fee token account incorrect"),r(this,"code",6019),r(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ne)}}p.set(6019,()=>new ne);d.set("IncorrectFeeAccount",()=>new ne);class re extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),r(this,"code",6020),r(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,re)}}p.set(6020,()=>new re);d.set("ZeroTradingTokens",()=>new re);class ie extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),r(this,"code",6021),r(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ie)}}p.set(6021,()=>new ie);d.set("FeeCalculationFailure",()=>new ie);class ae extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),r(this,"code",6022),r(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ae)}}p.set(6022,()=>new ae);d.set("ConversionFailure",()=>new ae);class se extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),r(this,"code",6023),r(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,se)}}p.set(6023,()=>new se);d.set("InvalidFee",()=>new se);class ce extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),r(this,"code",6024),r(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ce)}}p.set(6024,()=>new ce);d.set("IncorrectTokenProgramId",()=>new ce);class ue extends Error{constructor(){super("The provided curve type is not supported by the program owner"),r(this,"code",6025),r(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ue)}}p.set(6025,()=>new ue);d.set("UnsupportedCurveType",()=>new ue);class le extends Error{constructor(){super("The provided curve parameters are invalid"),r(this,"code",6026),r(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,le)}}p.set(6026,()=>new le);d.set("InvalidCurve",()=>new le);class pe extends Error{constructor(){super("The operation cannot be performed on the given curve"),r(this,"code",6027),r(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pe)}}p.set(6027,()=>new pe);d.set("UnsupportedCurveOperation",()=>new pe);new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"CloseAccountInstructionArgs");const Wt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["maximumTokenAAmount",i.u64],["maximumTokenBAmount",i.u64]],"DepositAllTokenTypesInstructionArgs"),xt=[32,95,69,60,75,79,205,238];function zt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=Wt.serialize({instructionDiscriminator:xt,...t}),a=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userTokenA,isWritable:!0,isSigner:!1},{pubkey:e.userTokenB,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??B,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)a.push(l);return new M({programId:n,keys:a,data:s})}const Pt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["sourceTokenAmount",i.u64],["minimumPoolTokenAmount",i.u64]],"DepositSingleTokenTypeInstructionArgs"),Dt=[175,0,152,41,199,0,148,43];function It(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=Pt.serialize({instructionDiscriminator:Dt,...t}),a=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??B,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)a.push(l);return new M({programId:n,keys:a,data:s})}const Ct=new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["feesInput",qe],["curveInput",Le],["policy",i.coption(T.publicKey)]],"InitializeInstructionArgs"),Nt=[175,175,109,31,13,152,155,237];function Kt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=Ct.serialize({instructionDiscriminator:Nt,...t}),a=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.tokenA,isWritable:!0,isSigner:!1},{pubkey:e.tokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??B,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)a.push(l);return new M({programId:n,keys:a,data:s})}const Rt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["amountIn",i.u64],["minimumAmountOut",i.u64]],"SwapInstructionArgs"),Ot=[248,198,158,145,225,117,135,200];function qt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=Rt.serialize({instructionDiscriminator:Ot,...t}),a=[{pubkey:e.proofRequest??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userSource,isWritable:!0,isSigner:!1},{pubkey:e.userDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolSource,isWritable:!0,isSigner:!1},{pubkey:e.poolDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.hostFeeAccount??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenProgram??B,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)a.push(l);return new M({programId:n,keys:a,data:s})}const Lt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["minimumTokenAAmount",i.u64],["minimumTokenBAmount",i.u64]],"WithdrawAllTokenTypesInstructionArgs"),Ut=[189,254,156,174,210,9,164,216];function Gt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=Lt.serialize({instructionDiscriminator:Ut,...t}),a=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??B,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)a.push(l);return new M({programId:n,keys:a,data:s})}const Jt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["destinationTokenAmount",i.u64],["maximumPoolTokenAmount",i.u64]],"WithdrawSingleTokenTypeInstructionArgs"),$t=[111,171,21,77,237,181,241,56];function Ht(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[s]=Jt.serialize({instructionDiscriminator:$t,...t}),a=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??B,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)a.push(l);return new M({programId:n,keys:a,data:s})}var Ue=(e=>(e[e.ConstantProduct=0]="ConstantProduct",e[e.ConstantPrice=1]="ConstantPrice",e[e.Offset=2]="Offset",e))(Ue||{});i.fixedScalarEnum(Ue);var Ge=(e=>(e[e.Floor=0]="Floor",e[e.Ceiling=1]="Ceiling",e))(Ge||{});i.fixedScalarEnum(Ge);var Je=(e=>(e[e.AtoB=0]="AtoB",e[e.BtoA=1]="BtoA",e))(Je||{});i.fixedScalarEnum(Je);const Qt="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",Vt=new f(Qt);class Zt{constructor(t){r(this,"programId",Vt),this.provider=t}get connection(){return this.provider.connection}swapAuthority(t){return f.findProgramAddressSync([t.toBuffer()],this.programId)[0]}async createTokenSwap(t,n){const s=new x,a=t.tokenSwap??nt.generate(),l=Array.from({length:32}),k=Array.from(t.curveParameters??[]);for(let b=0;b<k.length;b++)l[b]=k[b];const S={curveType:t.curveType,curveParameters:l},w=g.byteSize({bumpSeed:0,curve:S,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:f.default,poolFeeAccount:f.default,poolMint:f.default,tokenA:f.default,tokenAMint:f.default,tokenB:f.default,tokenBMint:f.default,tokenProgramId:f.default}),u=await this.connection.getMinimumBalanceForRentExemption(w);s.add(xe.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:a.publicKey,programId:this.programId,lamports:u,space:w})),s.add(Kt({authority:this.swapAuthority(a.publicKey),tokenSwap:a.publicKey,destination:t.destination,poolMint:t.poolMint,poolFee:t.poolFee,tokenA:t.tokenA,tokenB:t.tokenB},{feesInput:{tradeFeeNumerator:new y(t.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new y(t.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new y(t.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new y(t.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new y(t.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new y(t.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new y(t.fees.hostFeeNumerator.toString()),hostFeeDenominator:new y(t.fees.hostFeeDenominator.toString())},curveInput:S,policy:t.policy??null}));const E=await this.provider.sendAndConfirm(s,[a],n);return{tokenSwap:a.publicKey,signature:E}}async swap(t,n){var s;const a=new x;try{await me(this.connection,t.userDestination)}catch(l){(l instanceof fe||l instanceof ye)&&t.destinationTokenMint&&a.add(he(this.provider.publicKey,t.userDestination,this.provider.publicKey,t.destinationTokenMint))}return await this.handleWrappedSol({tx:a,amount:t.amountIn,userSource:t.userSource,sourceTokenMint:t.sourceTokenMint}),a.add(qt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:t.userSource,userDestination:t.userDestination,tokenSwap:t.tokenSwap,poolFee:t.poolFee,poolMint:t.poolMint,poolSource:t.poolSource,poolDestination:t.poolDestination,proofRequest:t.proofRequest,hostFeeAccount:t.hostFeeAccount},{amountIn:new y(t.amountIn.toString()),minimumAmountOut:new y(t.minimumAmountOut.toString())})),t.destinationTokenMint&&((s=t.destinationTokenMint)==null?void 0:s.toBase58())===Ne.toBase58()&&a.add(vt(t.userDestination,this.provider.publicKey,this.provider.publicKey)),this.provider.sendAndConfirm(a,[],n)}async depositAllTokenTypes(t,n){const s=zt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,destination:t.destination,userTokenA:t.userTokenA,userTokenB:t.userTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new y(t.poolTokenAmount.toString()),maximumTokenAAmount:new y(t.maximumTokenA.toString()),maximumTokenBAmount:new y(t.maximumTokenB.toString())}),a=new x().add(s);return this.provider.sendAndConfirm(a,[],n)}async withdrawAllTokenTypes(t,n){const s=Gt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destTokenA:t.destTokenA,destTokenB:t.destTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new y(t.poolTokenAmount.toString()),minimumTokenAAmount:new y(t.minimumTokenA.toString()),minimumTokenBAmount:new y(t.minimumTokenB.toString())}),a=new x().add(s);return this.provider.sendAndConfirm(a,[],n)}async depositSingleTokenTypeExactAmountIn(t,n){const s=new x;try{await me(this.connection,t.destination)}catch(a){(a instanceof fe||a instanceof ye)&&s.add(he(this.provider.publicKey,t.destination,this.provider.publicKey,t.poolMint))}return await this.handleWrappedSol({tx:s,amount:t.sourceTokenAmount,userSource:t.source,sourceTokenMint:t.sourceTokenMint}),s.add(It({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{sourceTokenAmount:new y(t.sourceTokenAmount.toString()),minimumPoolTokenAmount:new y(t.minimumPoolTokenAmount.toString())})),this.provider.sendAndConfirm(s,[],n)}async withdrawSingleTokenTypeExactAmountOut(t,n){const s=Ht({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{destinationTokenAmount:new y(t.destinationTokenAmount.toString()),maximumPoolTokenAmount:new y(t.maximumPoolTokenAmount.toString())}),a=new x().add(s);return this.provider.sendAndConfirm(a,[],n)}async load(t,n){return g.fromAccountAddress(this.provider.connection,new f(t),n)}async loadAll(t={}){const n=g.gpaBuilder().addFilter("accountDiscriminator",ke);return t.noData&&(n.config.dataSlice={offset:0,length:0}),t.tokenProgramId&&n.addFilter("tokenProgramId",new f(t.tokenProgramId)),t.poolMint&&n.addFilter("poolMint",new f(t.poolMint)),t.tokenAMint&&n.addFilter("tokenAMint",new f(t.tokenAMint)),t.tokenBMint&&n.addFilter("tokenBMint",new f(t.tokenBMint)),(await n.run(this.provider.connection)).map(({pubkey:s,account:a})=>({pubkey:s,data:t.noData?null:g.fromAccountInfo(a)[0]}))}async handleWrappedSol(t){var n;if(t.sourceTokenMint&&((n=t.sourceTokenMint)==null?void 0:n.toBase58())===Ne.toBase58()){let s=0;try{if((await Bt(t.sourceTokenMint,this.provider.publicKey)).toBase58()!==t.userSource.toBase58())return;const l=await me(this.connection,t.userSource);s=Number(l.amount)}catch(l){(l instanceof fe||l instanceof ye)&&t.tx.add(he(this.provider.publicKey,t.userSource,this.provider.publicKey,t.sourceTokenMint))}const a=Number(t.amount);t.amount>s&&t.tx.add(xe.transfer({fromPubkey:this.provider.publicKey,toPubkey:t.userSource,lamports:a-s}),Mt(t.userSource))}}}var jt=(e=>(e[e.ASC=0]="ASC",e[e.DESC=1]="DESC",e))(jt||{});const eo=rt("swap",()=>{const e=it(),t=at(),n=st(),{publicKey:s}=ct(),{notify:a}=ut(),l=lt(()=>new Zt(new ze(e.connection,n.value??{publicKey:pt.default},ze.defaultOptions()))),k=z([]),S=z([]),w=z([]),u=z(),E=Pe("token-a",""),b=Pe("token-b",""),o=dt({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:De,to:De,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:$e,tokens:F}=mt();$e(ft),A(F,()=>{F.value.length>=2&&(o.from=F.value.find(c=>c.mint===E.value)??F.value[0],o.to=F.value.find(c=>c.mint===b.value)??F.value[1])},{immediate:!0}),A(()=>o.from,()=>{o.from&&(E.value=o.from.mint)}),A(()=>o.to,()=>{o.to&&(b.value=o.to.mint)}),A([n,()=>e.cluster],async c=>{He().then(),c||Ve()},{immediate:!0});async function He(){o.loading=!0;try{console.log("swapClient ================: ",l.value),k.value=await l.value.loadAll(),console.log("swaps ================: ",k.value)}catch(c){console.log(c),k.value=[]}finally{o.loading=!1}}const de=z(!1),P=yt(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!u.value){de.value=!0;try{const c=await ht(e.connection,l.value.swapAuthority(u.value.pubkey)),m={};for(const v of c)m[`${v.mint}`]=v.amount;o.poolBalance=m;const h=await kt(e.connection,u.value.data.poolMint);o.poolTokenSupply=Number(h.supply),console.log("[Pool Balance] poolMint",h),console.log("[Pool Balance]",o.poolBalance),console.log("[Pool Balance] poolTokenSupply",o.poolTokenSupply)}catch(c){console.log("[Pool Balance] error",c)}finally{de.value=!1}}},500);setInterval(P,6e4);function Qe(c){u.value=c,console.log("setTokenSwap: ",u.value)}A([k,()=>t.servicePolicy],async()=>{console.log("tokenSwapsAll: ",k.value),S.value=k.value.filter(c=>!!t.servicePolicy.find(m=>m.pubkey.toBase58()===c.data.policy?.toBase58()))},{immediate:!0}),A([S,()=>o.from?.mint,()=>o.to?.mint,()=>t.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",S.value),S.value&&o.from?.mint&&o.to?.mint&&o.from.mint!==o.to.mint&&t.servicePolicy.length)if(w.value=S.value.filter(c=>{const m=c.data?.tokenAMint.toBase58(),h=c.data?.tokenBMint.toBase58();return m===o.from.mint&&h===o.to.mint||m===o.to.mint&&h===o.from.mint}),w.value.length){if(w.value.length>1){const c=w.value.find(m=>t.state.certificates?.find(h=>h.data?.policy.toBase58()===m.data.policy?.toBase58()));c&&(u.value=c)}u.value=w.value[0]}else u.value=void 0;else w.value=[],u.value=void 0,t.setContractPolicy("","swap"),o.poolBalance={}},{immediate:!0}),A([u],async()=>{console.log("Token SWAP: ",u.value),t.setContractPolicy(u.value?.data.policy?.toBase58()??"","swap"),u.value&&(P(),u.value.data.tokenAMint.toBase58()===o.from.mint?o.direction=0:o.direction=1)},{immediate:!0});function Ve(){o.loading=!1,o.slippageDialog=!1,o.poolBalance={},o.poolTokenSupply=0}A([()=>o.direction,()=>o.from.amount,()=>o.poolBalance],async()=>{const c=Number(o.from.amount??0),m=Ie(Number(o.poolBalance[o.from.mint]??0),o.from.decimals),h=Ie(Number(o.poolBalance[o.to.mint]??0),o.to.decimals);if(c===0||Number.isNaN(c)){o.to.amount=0,o.rate=Number(h)/Number(m),o.impact=0,o.minimumReceived=0;return}const v=h-m*h/(m+c);o.rate=c?v/c:h/m,o.to.amount=v?Number(wt(v*(1-o.fees.ownerTrade-o.fees.trade),o.to.decimals)):0,o.impact=c?1-v/c/(h/m):0,o.minimumReceived=I(o.to.amount-o.to.amount*o.slippage,o.to.decimals)},{immediate:!0});async function Ze(){if(!t.certificateValid)return St();if(!u.value||!s.value){console.log("TokenSwap is not initialized...");return}n.value.publicKey||a({type:"info",message:"Please connect your wallet first"});const m=Number(I(o.from.amount??0,o.from.decimals)),h=Number(I(t.tokenBalance(o.from.mint)??0,o.from.decimals)),v=Number(I(o.to.amount??0,o.to.decimals));if(m>h){a({type:"negative",message:"Insufficient balance."});return}try{o.swapping=!0;const W=o.direction===0?u.value.data.tokenAMint:u.value.data.tokenBMint,D=o.direction===0?u.value.data.tokenBMint:u.value.data.tokenAMint,be=o.direction===0?u.value.data.tokenA:u.value.data.tokenB,ve=o.direction===0?u.value.data.tokenB:u.value.data.tokenA;console.log("userSourceMint = ",W.toBase58()),console.log("userDestinationMint = ",D.toBase58()),console.log("userSourceMint = ",W.toBase58()),console.log("userDestinationMint = ",D.toBase58());const Te=await Ce(W,n.value.publicKey),Be=await Ce(D,n.value.publicKey),Me=m;console.log("toAmount = ",v),console.log("slippage = ",o.slippage),console.log("slippage 2 = ",v*o.slippage);const Ee=l.value.swapAuthority(u.value.pubkey);console.log("proofRequest = ",t.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",Ee),console.log("tokenSwap = ",u.value.pubkey.toBase58()),console.log("userSource = ",Te.toBase58()),console.log("userDestination = ",Be.toBase58()),console.log("poolSource = ",be.toBase58()),console.log("poolDestination = ",ve.toBase58()),console.log("poolMint = ",u.value.data.poolMint.toBase58()),console.log("poolFee = ",u.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",Me),console.log("minimumAmountOut = ",o.minimumReceived);const et=await l.value.swap({proofRequest:t.certificate?.pubkey,authority:Ee,tokenSwap:u.value.pubkey,userSource:Te,userDestination:Be,poolSource:be,poolDestination:ve,poolMint:u.value.data.poolMint,poolFee:u.value.data.poolFeeAccount,amountIn:Me,minimumAmountOut:o.minimumReceived,sourceTokenMint:W,destinationTokenMint:D},{commitment:"confirmed"});a({message:"Transaction confirmed",type:"positive",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${et}?cluster=${e.cluster}`,onClick:()=>!1}]}),Ae()}catch(W){console.log(W)}finally{o.swapping=!1}}function je(){const{from:c,to:m}=o;o.rate=0,o.to={...c,amount:void 0},o.from={...m,amount:void 0},o.direction=o.direction===0?1:0}function Xe(){o.slippageDialog=!0}function Ye(){o.slippageDialog=!1}function _e(c){o.from.amount=c}function Ae(){P(),o.from.amount=void 0,o.to.amount=void 0}A(()=>n.value?.publicKey,c=>{c||Ae()}),A(()=>o.to,c=>{c.amount&&(c.amount=void 0)});function ge(c){return{host:C(c.fees.hostFeeNumerator,c.fees.hostFeeDenominator),trade:C(c.fees.tradeFeeNumerator,c.fees.tradeFeeDenominator),ownerTrade:C(c.fees.ownerTradeFeeNumerator,c.fees.ownerTradeFeeDenominator),ownerWithdraw:C(c.fees.ownerWithdrawFeeNumerator,c.fees.ownerWithdrawFeeDenominator)}}return A(u,c=>{if(!c)return;const m=ge(c.data);o.fees.host=m.host,o.fees.trade=m.trade,o.fees.ownerTrade=m.ownerTrade,o.fees.ownerWithdraw=m.ownerWithdraw,console.log("fees ==== ",o.fees)}),{state:o,tokenSwapsAllFiltered:S,tokenSwaps:w,tokenSwap:u,swapClient:l,loadingPoolTokens:de,loadPoolTokenAccounts:P,setTokenSwap:Qe,setMax:_e,closeSlippage:Ye,openSlippage:Xe,changeDirection:je,swapSubmit:Ze,getPoolFee:ge,tokenAMint:E,tokenBMint:b}});export{jt as S,Ue as s,eo as u};
