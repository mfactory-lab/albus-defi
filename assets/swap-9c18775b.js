import{b8 as ye,a as I,b9 as D,s as m,q as y,ba as Y,u as P,bb as ae,bc as me,bd as Te,be as l,bf as vt,bg as It,bh as K,bi as Be,bj as u,bk as i,bl as f,bm as h,bn as A,bo as se,bp as on,bq as H,br as Me,bs as ee,bt as rn,bu as te,h as J,Z as R,bv as Dt,bw as Rn,bx as Cn,by as Nn,bz as Dn,bA as On,bB as Ln,k as Un,m as U,n as ht,v as b,bC as re,x as qn,y as _n,B as Hn,C as Vn,F as Gn,G as Jn,A as jn,Q as Ot,P as $n,L as ke,H as Lt,I as Yn,bD as Ut,a1 as Xn,M as Zn,J as Q,bE as Qn,bF as eo,bG as to,aC as qt,ac as no,bH as xe,Y as oo,N as _t,X as ro,bI as Pe}from"./index-90b379f1.js";ye.utils.randomPrivateKey;const Ht=()=>{const t=ye.utils.randomPrivateKey(),e=mt(t),n=new Uint8Array(64);return n.set(t),n.set(e,32),{publicKey:e,secretKey:n}},mt=ye.getPublicKey;function Vt(t){try{return ye.ExtendedPoint.fromHex(t),!0}catch{return!1}}const io=(t,e)=>ye.sign(t,e.slice(0,32)),so=ye.verify,_=t=>I.Buffer.isBuffer(t)?t:t instanceof Uint8Array?I.Buffer.from(t.buffer,t.byteOffset,t.byteLength):I.Buffer.from(t);class ao{constructor(e){Object.assign(this,e)}encode(){return I.Buffer.from(Cn(ze,this))}static decode(e){return Nn(ze,this,e)}static decodeUnchecked(e){return Dn(ze,this,e)}}const ze=new Map;var sn;let an;const co=32,ue=32;function uo(t){return t._bn!==void 0}let Gt=1;an=Symbol.toStringTag;class p extends ao{constructor(e){if(super({}),this._bn=void 0,uo(e))this._bn=e._bn;else{if(typeof e=="string"){const n=J.decode(e);if(n.length!=ue)throw new Error("Invalid public key input");this._bn=new R(n)}else this._bn=new R(e);if(this._bn.byteLength()>ue)throw new Error("Invalid public key input")}}static unique(){const e=new p(Gt);return Gt+=1,new p(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return J.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(I.Buffer);if(e.length===ue)return e;const n=I.Buffer.alloc(32);return e.copy(n,32-e.length),n}get[an](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,n,o){const r=I.Buffer.concat([e.toBuffer(),I.Buffer.from(n),o.toBuffer()]),s=Dt(r);return new p(s)}static createProgramAddressSync(e,n){let o=I.Buffer.alloc(0);e.forEach(function(s){if(s.length>co)throw new TypeError("Max seed length exceeded");o=I.Buffer.concat([o,_(s)])}),o=I.Buffer.concat([o,n.toBuffer(),I.Buffer.from("ProgramDerivedAddress")]);const r=Dt(o);if(Vt(r))throw new Error("Invalid seeds, address must fall off the curve");return new p(r)}static async createProgramAddress(e,n){return this.createProgramAddressSync(e,n)}static findProgramAddressSync(e,n){let o=255,r;for(;o!=0;){try{const s=e.concat(I.Buffer.from([o]));r=this.createProgramAddressSync(s,n)}catch(s){if(s instanceof TypeError)throw s;o--;continue}return[r,o]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,n){return this.findProgramAddressSync(e,n)}static isOnCurve(e){const n=new p(e);return Vt(n.toBytes())}}sn=p;p.default=new sn("11111111111111111111111111111111");ze.set(p,{kind:"struct",fields:[["_bn","u256"]]});new p("BPFLoader1111111111111111111111111111111111");const gt=1280-40-8,lo=127,yt=64;class Jt{constructor(e,n){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=n}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const n of this.keySegments()){if(e<n.length)return n[e];e-=n.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const o=new Map;this.keySegments().flat().forEach((s,c)=>{o.set(s.toBase58(),c)});const r=s=>{const c=o.get(s.toBase58());if(c===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return c};return e.map(s=>({programIdIndex:r(s.programId),accountKeyIndexes:s.keys.map(c=>r(c.pubkey)),data:s.data}))}}const T=(t="publicKey")=>te(32,t),fe=(t="string")=>{const e=m([y("length"),y("lengthPadding"),te(me(y(),-8),"chars")],t),n=e.decode.bind(e),o=e.encode.bind(e),r=e;return r.decode=(s,c)=>n(s,c).chars.toString(),r.encode=(s,c,k)=>{const d={chars:I.Buffer.from(s,"utf8")};return o(d,c,k)},r.alloc=s=>y().span+y().span+I.Buffer.from(s,"utf8").length,r},po=(t="authorized")=>m([T("staker"),T("withdrawer")],t),ho=(t="lockup")=>m([Y("unixTimestamp"),Y("epoch"),T("custodian")],t),fo=(t="voteInit")=>m([T("nodePubkey"),T("authorizedVoter"),T("authorizedWithdrawer"),P("commission")],t),mo=(t="voteAuthorizeWithSeedArgs")=>m([y("voteAuthorizationType"),T("currentAuthorityDerivedKeyOwnerPubkey"),fe("currentAuthorityDerivedKeySeed"),T("newAuthorized")],t);function cn(t,e){const n=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){const s=e[r.property];if(Array.isArray(s))return s.length*n(r.elementLayout)}else if("fields"in r)return cn({layout:r},e[r.property]);return 0};let o=0;return t.layout.fields.forEach(r=>{o+=n(r)}),o}function we(t){let e=0,n=0;for(;;){let o=t.shift();if(e|=(o&127)<<n*7,n+=1,!(o&128))break}return e}function Ae(t,e){let n=e;for(;;){let o=n&127;if(n>>=7,n==0){t.push(o);break}else o|=128,t.push(o)}}function G(t,e){if(!t)throw new Error(e||"Assertion failed")}class Tt{constructor(e,n){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=n}static compile(e,n){const o=new Map,r=c=>{const k=c.toBase58();let d=o.get(k);return d===void 0&&(d={isSigner:!1,isWritable:!1,isInvoked:!1},o.set(k,d)),d},s=r(n);s.isSigner=!0,s.isWritable=!0;for(const c of e){r(c.programId).isInvoked=!0;for(const k of c.keys){const d=r(k.pubkey);d.isSigner||(d.isSigner=k.isSigner),d.isWritable||(d.isWritable=k.isWritable)}}return new Tt(n,o)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];G(e.length<=256,"Max static account keys length exceeded");const n=e.filter(([,d])=>d.isSigner&&d.isWritable),o=e.filter(([,d])=>d.isSigner&&!d.isWritable),r=e.filter(([,d])=>!d.isSigner&&d.isWritable),s=e.filter(([,d])=>!d.isSigner&&!d.isWritable),c={numRequiredSignatures:n.length+o.length,numReadonlySignedAccounts:o.length,numReadonlyUnsignedAccounts:s.length};{G(n.length>0,"Expected at least one writable signer key");const[d]=n[0];G(d===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const k=[...n.map(([d])=>new p(d)),...o.map(([d])=>new p(d)),...r.map(([d])=>new p(d)),...s.map(([d])=>new p(d))];return[c,k]}extractTableLookup(e){const[n,o]=this.drainKeysFoundInLookupTable(e.state.addresses,c=>!c.isSigner&&!c.isInvoked&&c.isWritable),[r,s]=this.drainKeysFoundInLookupTable(e.state.addresses,c=>!c.isSigner&&!c.isInvoked&&!c.isWritable);if(!(n.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:n,readonlyIndexes:r},{writable:o,readonly:s}]}drainKeysFoundInLookupTable(e,n){const o=new Array,r=new Array;for(const[s,c]of this.keyMetaMap.entries())if(n(c)){const k=new p(s),d=e.findIndex(w=>w.equals(k));d>=0&&(G(d<256,"Max lookup table index exceeded"),o.push(d),r.push(k),this.keyMetaMap.delete(s))}return[o,r]}}class Ie{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(n=>new p(n)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(n=>this.indexToProgramIds.set(n.programIdIndex,this.accountKeys[n.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:J.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Jt(this.staticAccountKeys)}static compile(e){const n=Tt.compile(e.instructions,e.payerKey),[o,r]=n.getMessageComponents(),c=new Jt(r).compileInstructions(e.instructions).map(k=>({programIdIndex:k.programIdIndex,accounts:k.accountKeyIndexes,data:J.encode(k.data)}));return new Ie({header:o,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:c})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const n=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const o=e-n,s=this.accountKeys.length-n-this.header.numReadonlyUnsignedAccounts;return o<s}else{const o=n-this.header.numReadonlySignedAccounts;return e<o}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,n)=>!this.isProgramId(n))}serialize(){const e=this.accountKeys.length;let n=[];Ae(n,e);const o=this.instructions.map(z=>{const{accounts:a,programIdIndex:V}=z,L=Array.from(J.decode(z.data));let v=[];Ae(v,a.length);let B=[];return Ae(B,L.length),{programIdIndex:V,keyIndicesCount:I.Buffer.from(v),keyIndices:a,dataLength:I.Buffer.from(B),data:L}});let r=[];Ae(r,o.length);let s=I.Buffer.alloc(gt);I.Buffer.from(r).copy(s);let c=r.length;o.forEach(z=>{const V=m([P("programIdIndex"),te(z.keyIndicesCount.length,"keyIndicesCount"),ae(P("keyIndex"),z.keyIndices.length,"keyIndices"),te(z.dataLength.length,"dataLength"),ae(P("userdatum"),z.data.length,"data")]).encode(z,s,c);c+=V}),s=s.slice(0,c);const k=m([te(1,"numRequiredSignatures"),te(1,"numReadonlySignedAccounts"),te(1,"numReadonlyUnsignedAccounts"),te(n.length,"keyCount"),ae(T("key"),e,"keys"),T("recentBlockhash")]),d={numRequiredSignatures:I.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:I.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:I.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:I.Buffer.from(n),keys:this.accountKeys.map(z=>_(z.toBytes())),recentBlockhash:J.decode(this.recentBlockhash)};let w=I.Buffer.alloc(2048);const O=k.encode(d,w);return s.copy(w,O),w.slice(0,O+s.length)}static from(e){let n=[...e];const o=n.shift();if(o!==(o&lo))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const r=n.shift(),s=n.shift(),c=we(n);let k=[];for(let a=0;a<c;a++){const V=n.slice(0,ue);n=n.slice(ue),k.push(new p(I.Buffer.from(V)))}const d=n.slice(0,ue);n=n.slice(ue);const w=we(n);let O=[];for(let a=0;a<w;a++){const V=n.shift(),L=we(n),v=n.slice(0,L);n=n.slice(L);const B=we(n),F=n.slice(0,B),ce=J.encode(I.Buffer.from(F));n=n.slice(B),O.push({programIdIndex:V,accounts:v,data:ce})}const z={header:{numRequiredSignatures:o,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:s},recentBlockhash:J.encode(I.Buffer.from(d)),accountKeys:k,instructions:O};return new Ie(z)}}const go=I.Buffer.alloc(yt).fill(0);class C{constructor(e){this.keys=void 0,this.programId=void 0,this.data=I.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:n,isWritable:o})=>({pubkey:e.toJSON(),isSigner:n,isWritable:o})),programId:this.programId.toJSON(),data:[...this.data]}}}class ie{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:n,nonceInfo:o}=e;this.minNonceContextSlot=n,this.nonceInfo=o}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:n,lastValidBlockHeight:o}=e;this.recentBlockhash=n,this.lastValidBlockHeight=o}else{const{recentBlockhash:n,nonceInfo:o}=e;o&&(this.nonceInfo=o),this.recentBlockhash=n}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(n=>{"instructions"in n?this.instructions=this.instructions.concat(n.instructions):"data"in n&&"programId"in n&&"keys"in n?this.instructions.push(n):this.instructions.push(new C(n))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,n;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?n=[this.nonceInfo.nonceInstruction,...this.instructions]:n=this.instructions):(e=this.recentBlockhash,n=this.instructions),!e)throw new Error("Transaction recentBlockhash required");n.length<1&&console.warn("No instructions provided");let o;if(this.feePayer)o=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)o=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let v=0;v<n.length;v++)if(n[v].programId===void 0)throw new Error(`Transaction instruction index ${v} has undefined program id`);const r=[],s=[];n.forEach(v=>{v.keys.forEach(F=>{s.push({...F})});const B=v.programId.toString();r.includes(B)||r.push(B)}),r.forEach(v=>{s.push({pubkey:new p(v),isSigner:!1,isWritable:!1})});const c=[];s.forEach(v=>{const B=v.pubkey.toString(),F=c.findIndex(ce=>ce.pubkey.toString()===B);F>-1?(c[F].isWritable=c[F].isWritable||v.isWritable,c[F].isSigner=c[F].isSigner||v.isSigner):c.push(v)}),c.sort(function(v,B){if(v.isSigner!==B.isSigner)return v.isSigner?-1:1;if(v.isWritable!==B.isWritable)return v.isWritable?-1:1;const F={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return v.pubkey.toBase58().localeCompare(B.pubkey.toBase58(),"en",F)});const k=c.findIndex(v=>v.pubkey.equals(o));if(k>-1){const[v]=c.splice(k,1);v.isSigner=!0,v.isWritable=!0,c.unshift(v)}else c.unshift({pubkey:o,isSigner:!0,isWritable:!0});for(const v of this.signatures){const B=c.findIndex(F=>F.pubkey.equals(v.publicKey));if(B>-1)c[B].isSigner||(c[B].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${v.publicKey.toString()}`)}let d=0,w=0,O=0;const z=[],a=[];c.forEach(({pubkey:v,isSigner:B,isWritable:F})=>{B?(z.push(v.toString()),d+=1,F||(w+=1)):(a.push(v.toString()),F||(O+=1))});const V=z.concat(a),L=n.map(v=>{const{data:B,programId:F}=v;return{programIdIndex:V.indexOf(F.toString()),accounts:v.keys.map(ce=>V.indexOf(ce.pubkey.toString())),data:J.encode(B)}});return L.forEach(v=>{G(v.programIdIndex>=0),v.accounts.forEach(B=>G(B>=0))}),new Ie({header:{numRequiredSignatures:d,numReadonlySignedAccounts:w,numReadonlyUnsignedAccounts:O},accountKeys:V,recentBlockhash:e,instructions:L})}_compile(){const e=this.compileMessage(),n=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===n.length&&this.signatures.every((r,s)=>n[s].equals(r.publicKey))||(this.signatures=n.map(o=>({signature:null,publicKey:o}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const n=new Set;this.signatures=e.filter(o=>{const r=o.toString();return n.has(r)?!1:(n.add(r),!0)}).map(o=>({signature:null,publicKey:o}))}sign(...e){if(e.length===0)throw new Error("No signers");const n=new Set,o=[];for(const s of e){const c=s.publicKey.toString();n.has(c)||(n.add(c),o.push(s))}this.signatures=o.map(s=>({signature:null,publicKey:s.publicKey}));const r=this._compile();this._partialSign(r,...o)}partialSign(...e){if(e.length===0)throw new Error("No signers");const n=new Set,o=[];for(const s of e){const c=s.publicKey.toString();n.has(c)||(n.add(c),o.push(s))}const r=this._compile();this._partialSign(r,...o)}_partialSign(e,...n){const o=e.serialize();n.forEach(r=>{const s=io(o,r.secretKey);this._addSignature(r.publicKey,_(s))})}addSignature(e,n){this._compile(),this._addSignature(e,n)}_addSignature(e,n){G(n.length===64);const o=this.signatures.findIndex(r=>e.equals(r.publicKey));if(o<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[o].signature=I.Buffer.from(n)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,n){for(const{signature:o,publicKey:r}of this.signatures)if(o===null){if(n)return!1}else if(!so(o,e,r.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:n,verifySignatures:o}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(o&&!this._verifySignatures(r,n))throw new Error("Signature verification failed");return this._serialize(r)}_serialize(e){const{signatures:n}=this,o=[];Ae(o,n.length);const r=o.length+n.length*64+e.length,s=I.Buffer.alloc(r);return G(n.length<256),I.Buffer.from(o).copy(s,0),n.forEach(({signature:c},k)=>{c!==null&&(G(c.length===64,"signature has invalid length"),I.Buffer.from(c).copy(s,o.length+k*64))}),e.copy(s,o.length+n.length*64),G(s.length<=gt,`Transaction too large: ${s.length} > ${gt}`),s}get keys(){return G(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return G(this.instructions.length===1),this.instructions[0].programId}get data(){return G(this.instructions.length===1),this.instructions[0].data}static from(e){let n=[...e];const o=we(n);let r=[];for(let s=0;s<o;s++){const c=n.slice(0,yt);n=n.slice(yt),r.push(J.encode(I.Buffer.from(c)))}return ie.populate(Ie.from(n),r)}static populate(e,n=[]){const o=new ie;return o.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(o.feePayer=e.accountKeys[0]),n.forEach((r,s)=>{const c={signature:r==J.encode(go)?null:J.decode(r),publicKey:e.accountKeys[s]};o.signatures.push(c)}),e.instructions.forEach(r=>{const s=r.accounts.map(c=>{const k=e.accountKeys[c];return{pubkey:k,isSigner:o.signatures.some(d=>d.publicKey.toString()===k.toString())||e.isAccountSigner(c),isWritable:e.isAccountWritable(c)}});o.instructions.push(new C({keys:s,programId:e.accountKeys[r.programIdIndex],data:J.decode(r.data)}))}),o._message=e,o._json=o.toJSON(),o}}new p("SysvarC1ock11111111111111111111111111111111");new p("SysvarEpochSchedu1e111111111111111111111111");new p("Sysvar1nstructions1111111111111111111111111");const ft=new p("SysvarRecentB1ockHashes11111111111111111111"),jt=new p("SysvarRent111111111111111111111111111111111");new p("SysvarRewards111111111111111111111111111111");new p("SysvarS1otHashes111111111111111111111111111");new p("SysvarS1otHistory11111111111111111111111111");new p("SysvarStakeHistory1111111111111111111111111");function j(t,e){const n=t.layout.span>=0?t.layout.span:cn(t,e),o=I.Buffer.alloc(n),r=Object.assign({instruction:t.index},e);return t.layout.encode(r,o),o}const yo=D("lamportsPerSignature"),bo=m([y("version"),y("state"),T("authorizedPubkey"),T("nonce"),m([yo],"feeCalculator")]),$t=bo.span,ko=t=>{const e=t.decode.bind(t),n=t.encode.bind(t);return{decode:e,encode:n}},So=t=>e=>{const n=te(t,e),{encode:o,decode:r}=ko(n),s=n;return s.decode=(c,k)=>{const d=r(c,k);return On(I.Buffer.from(d))},s.encode=(c,k,d)=>{const w=Ln(c,t);return o(w,k,d)},s},ge=So(8),$=Object.freeze({Create:{index:0,layout:m([y("instruction"),Y("lamports"),Y("space"),T("programId")])},Assign:{index:1,layout:m([y("instruction"),T("programId")])},Transfer:{index:2,layout:m([y("instruction"),ge("lamports")])},CreateWithSeed:{index:3,layout:m([y("instruction"),T("base"),fe("seed"),Y("lamports"),Y("space"),T("programId")])},AdvanceNonceAccount:{index:4,layout:m([y("instruction")])},WithdrawNonceAccount:{index:5,layout:m([y("instruction"),Y("lamports")])},InitializeNonceAccount:{index:6,layout:m([y("instruction"),T("authorized")])},AuthorizeNonceAccount:{index:7,layout:m([y("instruction"),T("authorized")])},Allocate:{index:8,layout:m([y("instruction"),Y("space")])},AllocateWithSeed:{index:9,layout:m([y("instruction"),T("base"),fe("seed"),Y("space"),T("programId")])},AssignWithSeed:{index:10,layout:m([y("instruction"),T("base"),fe("seed"),T("programId")])},TransferWithSeed:{index:11,layout:m([y("instruction"),ge("lamports"),fe("seed"),T("programId")])},UpgradeNonceAccount:{index:12,layout:m([y("instruction")])}});class le{constructor(){}static createAccount(e){const n=$.Create,o=j(n,{lamports:e.lamports,space:e.space,programId:_(e.programId.toBuffer())});return new C({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:o})}static transfer(e){let n,o;if("basePubkey"in e){const r=$.TransferWithSeed;n=j(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:_(e.programId.toBuffer())}),o=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const r=$.Transfer;n=j(r,{lamports:BigInt(e.lamports)}),o=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new C({keys:o,programId:this.programId,data:n})}static assign(e){let n,o;if("basePubkey"in e){const r=$.AssignWithSeed;n=j(r,{base:_(e.basePubkey.toBuffer()),seed:e.seed,programId:_(e.programId.toBuffer())}),o=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=$.Assign;n=j(r,{programId:_(e.programId.toBuffer())}),o=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new C({keys:o,programId:this.programId,data:n})}static createAccountWithSeed(e){const n=$.CreateWithSeed,o=j(n,{base:_(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:_(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new C({keys:r,programId:this.programId,data:o})}static createNonceAccount(e){const n=new ie;"basePubkey"in e&&"seed"in e?n.add(le.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:$t,programId:this.programId})):n.add(le.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:$t,programId:this.programId}));const o={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return n.add(this.nonceInitialize(o)),n}static nonceInitialize(e){const n=$.InitializeNonceAccount,o=j(n,{authorized:_(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1}],programId:this.programId,data:o};return new C(r)}static nonceAdvance(e){const n=$.AdvanceNonceAccount,o=j(n),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new C(r)}static nonceWithdraw(e){const n=$.WithdrawNonceAccount,o=j(n,{lamports:e.lamports});return new C({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static nonceAuthorize(e){const n=$.AuthorizeNonceAccount,o=j(n,{authorized:_(e.newAuthorizedPubkey.toBuffer())});return new C({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static allocate(e){let n,o;if("basePubkey"in e){const r=$.AllocateWithSeed;n=j(r,{base:_(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:_(e.programId.toBuffer())}),o=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=$.Allocate;n=j(r,{space:e.space}),o=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new C({keys:o,programId:this.programId,data:n})}}le.programId=new p("11111111111111111111111111111111");new p("BPFLoader2111111111111111111111111111111111");m([y("typeIndex"),ge("deactivationSlot"),D("lastExtendedSlot"),P("lastExtendedStartIndex"),P(),ae(T(),me(P(),-1),"authority")]);const N=Te(vt(p),l(),t=>new p(t)),un=It([l(),K("base64")]),Bt=Te(vt(I.Buffer),un,t=>I.Buffer.from(t[0],"base64"));function ln(t){return H([u({jsonrpc:K("2.0"),id:l(),result:t}),u({jsonrpc:K("2.0"),id:l(),error:u({code:Be(),message:l(),data:A(Rn())})})])}const wo=ln(Be());function W(t){return Te(ln(t),wo,e=>"error"in e?e:{...e,result:Me(e.result,t)})}function X(t){return W(u({context:u({slot:i()}),value:t}))}function Ce(t){return u({context:u({slot:i()}),value:t})}const Ao=u({foundation:i(),foundationTerm:i(),initial:i(),taper:i(),terminal:i()});W(f(h(u({epoch:i(),effectiveSlot:i(),amount:i(),postBalance:i(),commission:A(h(i()))}))));const vo=f(u({slot:i(),prioritizationFee:i()})),Io=u({total:i(),validator:i(),foundation:i(),epoch:i()}),To=u({epoch:i(),slotIndex:i(),slotsInEpoch:i(),absoluteSlot:i(),blockHeight:A(i()),transactionCount:A(i())}),Bo=u({slotsPerEpoch:i(),leaderScheduleSlotOffset:i(),warmup:se(),firstNormalEpoch:i(),firstNormalSlot:i()}),Eo=on(l(),f(i())),de=h(H([u({}),l()])),xo=u({err:de}),Po=K("receivedSignature");u({"solana-core":l(),"feature-set":A(i())});X(u({err:h(H([u({}),l()])),logs:h(f(l())),accounts:A(h(f(h(u({executable:se(),owner:l(),lamports:i(),data:f(l()),rentEpoch:A(i())}))))),unitsConsumed:A(i()),returnData:A(h(u({programId:l(),data:It([l(),K("base64")])})))}));X(u({byIdentity:on(l(),f(i())),range:u({firstSlot:i(),lastSlot:i()})}));W(Ao);W(Io);W(vo);W(To);W(Bo);W(Eo);W(i());X(u({total:i(),circulating:i(),nonCirculating:i(),nonCirculatingAccounts:f(N)}));const Wo=u({amount:l(),uiAmount:h(i()),decimals:i(),uiAmountString:A(l())});X(f(u({address:N,amount:l(),uiAmount:h(i()),decimals:i(),uiAmountString:A(l())})));X(f(u({pubkey:N,account:u({executable:se(),owner:N,lamports:i(),data:Bt,rentEpoch:i()})})));const bt=u({program:l(),parsed:Be(),space:i()});X(f(u({pubkey:N,account:u({executable:se(),owner:N,lamports:i(),data:bt,rentEpoch:i()})})));X(f(u({lamports:i(),address:N})));const Et=u({executable:se(),owner:N,lamports:i(),data:Bt,rentEpoch:i()});u({pubkey:N,account:Et});const zo=Te(H([vt(I.Buffer),bt]),H([un,bt]),t=>Array.isArray(t)?Me(t,Bt):t),Mo=u({executable:se(),owner:N,lamports:i(),data:zo,rentEpoch:i()});u({pubkey:N,account:Mo});u({state:H([K("active"),K("inactive"),K("activating"),K("deactivating")]),active:i(),inactive:i()});W(f(u({signature:l(),slot:i(),err:de,memo:h(l()),blockTime:A(h(i()))})));W(f(u({signature:l(),slot:i(),err:de,memo:h(l()),blockTime:A(h(i()))})));u({subscription:i(),result:Ce(Et)});const Fo=u({pubkey:N,account:Et});u({subscription:i(),result:Ce(Fo)});const Ko=u({parent:i(),slot:i(),root:i()});u({subscription:i(),result:Ko});const Ro=H([u({type:H([K("firstShredReceived"),K("completed"),K("optimisticConfirmation"),K("root")]),slot:i(),timestamp:i()}),u({type:K("createdBank"),parent:i(),slot:i(),timestamp:i()}),u({type:K("frozen"),slot:i(),timestamp:i(),stats:u({numTransactionEntries:i(),numSuccessfulTransactions:i(),numFailedTransactions:i(),maxTransactionsPerEntry:i()})}),u({type:K("dead"),slot:i(),timestamp:i(),err:l()})]);u({subscription:i(),result:Ro});u({subscription:i(),result:Ce(H([xo,Po]))});u({subscription:i(),result:i()});u({pubkey:l(),gossip:h(l()),tpu:h(l()),rpc:h(l()),version:h(l())});const Yt=u({votePubkey:l(),nodePubkey:l(),activatedStake:i(),epochVoteAccount:se(),epochCredits:f(It([i(),i(),i()])),commission:i(),lastVote:i(),rootSlot:h(i())});W(u({current:f(Yt),delinquent:f(Yt)}));const Co=H([K("processed"),K("confirmed"),K("finalized")]),No=u({slot:i(),confirmations:h(i()),err:de,confirmationStatus:A(Co)});X(f(h(No)));W(i());const dn=u({accountKey:N,writableIndexes:f(i()),readonlyIndexes:f(i())}),xt=u({signatures:f(l()),message:u({accountKeys:f(l()),header:u({numRequiredSignatures:i(),numReadonlySignedAccounts:i(),numReadonlyUnsignedAccounts:i()}),instructions:f(u({accounts:f(i()),data:l(),programIdIndex:i()})),recentBlockhash:l(),addressTableLookups:A(f(dn))})}),pn=u({pubkey:N,signer:se(),writable:se(),source:A(H([K("transaction"),K("lookupTable")]))}),hn=u({accountKeys:f(pn),signatures:f(l())}),fn=u({parsed:Be(),program:l(),programId:N}),mn=u({accounts:f(N),data:l(),programId:N}),Do=H([mn,fn]),Oo=H([u({parsed:Be(),program:l(),programId:l()}),u({accounts:f(l()),data:l(),programId:l()})]),gn=Te(Do,Oo,t=>"accounts"in t?Me(t,mn):Me(t,fn)),yn=u({signatures:f(l()),message:u({accountKeys:f(pn),instructions:f(gn),recentBlockhash:l(),addressTableLookups:A(h(f(dn)))})}),Fe=u({accountIndex:i(),mint:l(),owner:A(l()),uiTokenAmount:Wo}),bn=u({writable:f(N),readonly:f(N)}),Ne=u({err:de,fee:i(),innerInstructions:A(h(f(u({index:i(),instructions:f(u({accounts:f(i()),data:l(),programIdIndex:i()}))})))),preBalances:f(i()),postBalances:f(i()),logMessages:A(h(f(l()))),preTokenBalances:A(h(f(Fe))),postTokenBalances:A(h(f(Fe))),loadedAddresses:A(bn),computeUnitsConsumed:A(i())}),Pt=u({err:de,fee:i(),innerInstructions:A(h(f(u({index:i(),instructions:f(gn)})))),preBalances:f(i()),postBalances:f(i()),logMessages:A(h(f(l()))),preTokenBalances:A(h(f(Fe))),postTokenBalances:A(h(f(Fe))),loadedAddresses:A(bn),computeUnitsConsumed:A(i())}),be=H([K(0),K("legacy")]),pe=u({pubkey:l(),lamports:i(),postBalance:h(i()),rewardType:h(l()),commission:A(h(i()))});W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),transactions:f(u({transaction:xt,meta:h(Ne),version:A(be)})),rewards:A(f(pe)),blockTime:h(i()),blockHeight:h(i())})));W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),rewards:A(f(pe)),blockTime:h(i()),blockHeight:h(i())})));W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),transactions:f(u({transaction:hn,meta:h(Ne),version:A(be)})),rewards:A(f(pe)),blockTime:h(i()),blockHeight:h(i())})));W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),transactions:f(u({transaction:yn,meta:h(Pt),version:A(be)})),rewards:A(f(pe)),blockTime:h(i()),blockHeight:h(i())})));W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),transactions:f(u({transaction:hn,meta:h(Pt),version:A(be)})),rewards:A(f(pe)),blockTime:h(i()),blockHeight:h(i())})));W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),rewards:A(f(pe)),blockTime:h(i()),blockHeight:h(i())})));W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),transactions:f(u({transaction:xt,meta:h(Ne)})),rewards:A(f(pe)),blockTime:h(i())})));W(h(u({blockhash:l(),previousBlockhash:l(),parentSlot:i(),signatures:f(l()),blockTime:h(i())})));W(h(u({slot:i(),meta:h(Ne),blockTime:A(h(i())),transaction:xt,version:A(be)})));W(h(u({slot:i(),transaction:yn,meta:h(Pt),blockTime:A(h(i())),version:A(be)})));X(u({blockhash:l(),feeCalculator:u({lamportsPerSignature:i()})}));X(u({blockhash:l(),lastValidBlockHeight:i()}));X(se());const Lo=u({slot:i(),numTransactions:i(),numSlots:i(),samplePeriodSecs:i()});W(f(Lo));X(h(u({feeCalculator:u({lamportsPerSignature:i()})})));W(l());W(l());const Uo=u({err:de,logs:f(l()),signature:l()});u({result:Ce(Uo),subscription:i()});class ve{constructor(e){this._keypair=void 0,this._keypair=e??Ht()}static generate(){return new ve(Ht())}static fromSecretKey(e,n){if(e.byteLength!==64)throw new Error("bad secret key size");const o=e.slice(32,64);if(!n||!n.skipValidation){const r=e.slice(0,32),s=mt(r);for(let c=0;c<32;c++)if(o[c]!==s[c])throw new Error("provided secretKey is invalid")}return new ve({publicKey:o,secretKey:e})}static fromSeed(e){const n=mt(e),o=new Uint8Array(64);return o.set(e),o.set(n,32),new ve({publicKey:n,secretKey:o})}get publicKey(){return new p(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:m([y("instruction"),ge("recentSlot"),P("bumpSeed")])},FreezeLookupTable:{index:1,layout:m([y("instruction")])},ExtendLookupTable:{index:2,layout:m([y("instruction"),ge(),ae(T(),me(y(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:m([y("instruction")])},CloseLookupTable:{index:4,layout:m([y("instruction")])}});new p("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:m([P("instruction"),y("units"),y("additionalFee")])},RequestHeapFrame:{index:1,layout:m([P("instruction"),y("bytes")])},SetComputeUnitLimit:{index:2,layout:m([P("instruction"),y("units")])},SetComputeUnitPrice:{index:3,layout:m([P("instruction"),ge("microLamports")])}});new p("ComputeBudget111111111111111111111111111111");m([P("numSignatures"),P("padding"),ee("signatureOffset"),ee("signatureInstructionIndex"),ee("publicKeyOffset"),ee("publicKeyInstructionIndex"),ee("messageDataOffset"),ee("messageDataSize"),ee("messageInstructionIndex")]);new p("Ed25519SigVerify111111111111111111111111111");rn.utils.isValidPrivateKey;rn.getPublicKey;m([P("numSignatures"),ee("signatureOffset"),P("signatureInstructionIndex"),ee("ethAddressOffset"),P("ethAddressInstructionIndex"),ee("messageDataOffset"),ee("messageDataSize"),P("messageInstructionIndex"),te(20,"ethAddress"),te(64,"signature"),P("recoveryId")]);new p("KeccakSecp256k11111111111111111111111111111");var kn;new p("StakeConfig11111111111111111111111111111111");class Sn{constructor(e,n,o){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=n,this.custodian=o}}kn=Sn;Sn.default=new kn(0,0,p.default);Object.freeze({Initialize:{index:0,layout:m([y("instruction"),po(),ho()])},Authorize:{index:1,layout:m([y("instruction"),T("newAuthorized"),y("stakeAuthorizationType")])},Delegate:{index:2,layout:m([y("instruction")])},Split:{index:3,layout:m([y("instruction"),Y("lamports")])},Withdraw:{index:4,layout:m([y("instruction"),Y("lamports")])},Deactivate:{index:5,layout:m([y("instruction")])},Merge:{index:7,layout:m([y("instruction")])},AuthorizeWithSeed:{index:8,layout:m([y("instruction"),T("newAuthorized"),y("stakeAuthorizationType"),fe("authoritySeed"),T("authorityOwner")])}});new p("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:m([y("instruction"),fo()])},Authorize:{index:1,layout:m([y("instruction"),T("newAuthorized"),y("voteAuthorizationType")])},Withdraw:{index:3,layout:m([y("instruction"),Y("lamports")])},AuthorizeWithSeed:{index:10,layout:m([y("instruction"),mo()])}});new p("Vote111111111111111111111111111111111111111");new p("Va1idator1nfo111111111111111111111111111111");u({name:l(),website:A(l()),details:A(l()),keybaseUsername:A(l())});new p("Vote111111111111111111111111111111111111111");m([T("nodePubkey"),T("authorizedWithdrawer"),P("commission"),D(),ae(m([D("slot"),y("confirmationCount")]),me(y(),-8),"votes"),P("rootSlotValid"),D("rootSlot"),D(),ae(m([D("epoch"),T("authorizedVoter")]),me(y(),-8),"authorizedVoters"),m([ae(m([T("authorizedPubkey"),D("epochOfLastAuthorizedSwitch"),D("targetEpoch")]),32,"buf"),D("idx"),P("isEmpty")],"priorVoters"),D(),ae(m([D("epoch"),D("credits"),D("prevCredits")]),me(y(),-8),"epochCredits"),m([D("slot"),D("timestamp")],"lastTimestamp")]);const Z=new p("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new p("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const wn=new p("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),Xt=new p("So11111111111111111111111111111111111111112");new p("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");class De extends Error{constructor(e){super(e)}}class kt extends De{constructor(){super(...arguments),this.name="TokenAccountNotFoundError"}}class qo extends De{constructor(){super(...arguments),this.name="TokenInvalidAccountError"}}class St extends De{constructor(){super(...arguments),this.name="TokenInvalidAccountOwnerError"}}class Zt extends De{constructor(){super(...arguments),this.name="TokenInvalidAccountSizeError"}}var Ke;(function(t){t[t.InitializeMint=0]="InitializeMint",t[t.InitializeAccount=1]="InitializeAccount",t[t.InitializeMultisig=2]="InitializeMultisig",t[t.Transfer=3]="Transfer",t[t.Approve=4]="Approve",t[t.Revoke=5]="Revoke",t[t.SetAuthority=6]="SetAuthority",t[t.MintTo=7]="MintTo",t[t.Burn=8]="Burn",t[t.CloseAccount=9]="CloseAccount",t[t.FreezeAccount=10]="FreezeAccount",t[t.ThawAccount=11]="ThawAccount",t[t.TransferChecked=12]="TransferChecked",t[t.ApproveChecked=13]="ApproveChecked",t[t.MintToChecked=14]="MintToChecked",t[t.BurnChecked=15]="BurnChecked",t[t.InitializeAccount2=16]="InitializeAccount2",t[t.SyncNative=17]="SyncNative",t[t.InitializeAccount3=18]="InitializeAccount3",t[t.InitializeMultisig2=19]="InitializeMultisig2",t[t.InitializeMint2=20]="InitializeMint2",t[t.GetAccountDataSize=21]="GetAccountDataSize",t[t.InitializeImmutableOwner=22]="InitializeImmutableOwner",t[t.AmountToUiAmount=23]="AmountToUiAmount",t[t.UiAmountToAmount=24]="UiAmountToAmount",t[t.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",t[t.TransferFeeExtension=26]="TransferFeeExtension",t[t.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",t[t.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",t[t.Reallocate=29]="Reallocate",t[t.MemoTransferExtension=30]="MemoTransferExtension",t[t.CreateNativeMint=31]="CreateNativeMint",t[t.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",t[t.InterestBearingMintExtension=33]="InterestBearingMintExtension",t[t.CpiGuardExtension=34]="CpiGuardExtension",t[t.InitializePermanentDelegate=35]="InitializePermanentDelegate",t[t.TransferHookExtension=36]="TransferHookExtension",t[t.MetadataPointerExtension=39]="MetadataPointerExtension"})(Ke||(Ke={}));function _o(t,e,n){if(n.length){t.push({pubkey:e,isSigner:!1,isWritable:!1});for(const o of n)t.push({pubkey:o instanceof p?o:o.publicKey,isSigner:!0,isWritable:!1})}else t.push({pubkey:e,isSigner:!0,isWritable:!1});return t}const Qt=m([P("instruction")]);function Ho(t,e,n,o=[],r=Z){const s=_o([{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0}],n,o),c=I.Buffer.alloc(Qt.span);return Qt.encode({instruction:Ke.CloseAccount},c),new C({keys:s,programId:r,data:c})}var wt;(function(t){t[t.Uninitialized=0]="Uninitialized",t[t.Mint=1]="Mint",t[t.Account=2]="Account"})(wt||(wt={}));const Vo=1,Go=m([P("m"),P("n"),Un("isInitialized"),U("signer1"),U("signer2"),U("signer3"),U("signer4"),U("signer5"),U("signer6"),U("signer7"),U("signer8"),U("signer9"),U("signer10"),U("signer11")]),Jo=Go.span;var Re;(function(t){t[t.Uninitialized=0]="Uninitialized",t[t.Initialized=1]="Initialized",t[t.Frozen=2]="Frozen"})(Re||(Re={}));const An=m([U("mint"),U("owner"),ht("amount"),y("delegateOption"),U("delegate"),P("state"),y("isNativeOption"),ht("isNative"),ht("delegatedAmount"),y("closeAuthorityOption"),U("closeAuthority")]),Se=An.span;async function en(t,e,n,o=Z){const r=await t.getAccountInfo(e,n);return jo(e,r,o)}function jo(t,e,n=Z){if(!e)throw new kt;if(!e.owner.equals(n))throw new St;if(e.data.length<Se)throw new Zt;const o=An.decode(e.data.slice(0,Se));let r=I.Buffer.alloc(0);if(e.data.length>Se){if(e.data.length===Jo)throw new Zt;if(e.data[Se]!=wt.Account)throw new qo;r=e.data.slice(Se+Vo)}return{address:t,mint:o.mint,owner:o.owner,amount:o.amount,delegate:o.delegateOption?o.delegate:null,delegatedAmount:o.delegatedAmount,isInitialized:o.state!==Re.Uninitialized,isFrozen:o.state===Re.Frozen,isNative:!!o.isNativeOption,rentExemptReserve:o.isNativeOption?o.isNative:null,closeAuthority:o.closeAuthorityOption?o.closeAuthority:null,tlvData:r}}function tn(t,e,n,o,r=Z,s=wn){return $o(t,e,n,o,I.Buffer.alloc(0),r,s)}function $o(t,e,n,o,r,s=Z,c=wn){const k=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:le.programId,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}];return new C({keys:k,programId:c,data:r})}const nn=m([P("instruction")]);function Yo(t,e=Z){const n=[{pubkey:t,isSigner:!1,isWritable:!0}],o=I.Buffer.alloc(nn.span);return nn.encode({instruction:Ke.SyncNative},o),new C({keys:n,programId:e,data:o})}var Xo=Object.defineProperty,Zo=(t,e,n)=>e in t?Xo(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,g=(t,e,n)=>(Zo(t,typeof e!="symbol"?e+"":e,n),n);const vn=new b.BeetArgsStruct([["tradeFeeNumerator",b.u64],["tradeFeeDenominator",b.u64],["ownerTradeFeeNumerator",b.u64],["ownerTradeFeeDenominator",b.u64],["ownerWithdrawFeeNumerator",b.u64],["ownerWithdrawFeeDenominator",b.u64],["hostFeeNumerator",b.u64],["hostFeeDenominator",b.u64]],"FeesInfo"),In=new b.BeetArgsStruct([["curveType",b.u8],["curveParameters",b.uniformFixedSizeArray(b.u8,32)]],"CurveInfo"),At=[135,144,215,161,140,125,41,96];class ne{constructor(e,n,o,r,s,c,k,d,w,O,z,a){this.isInitialized=e,this.bumpSeed=n,this.tokenProgramId=o,this.tokenA=r,this.tokenB=s,this.poolMint=c,this.tokenAMint=k,this.tokenBMint=d,this.poolFeeAccount=w,this.fees=O,this.curve=z,this.policy=a}static fromArgs(e){return new ne(e.isInitialized,e.bumpSeed,e.tokenProgramId,e.tokenA,e.tokenB,e.poolMint,e.tokenAMint,e.tokenBMint,e.poolFeeAccount,e.fees,e.curve,e.policy)}static fromAccountInfo(e,n=0){return ne.deserialize(e.data,n)}static async fromAccountAddress(e,n,o){const r=await e.getAccountInfo(n,o);if(r==null)throw new Error(`Unable to find TokenSwap account at ${n}`);return ne.fromAccountInfo(r,0)[0]}static gpaBuilder(e=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return re.GpaBuilder.fromStruct(e,We)}static deserialize(e,n=0){return We.deserialize(e,n)}serialize(){return We.serialize({accountDiscriminator:At,...this})}static byteSize(e){const n=ne.fromArgs(e);return We.toFixedFromValue({accountDiscriminator:At,...n}).byteSize}static async getMinimumBalanceForRentExemption(e,n,o){return n.getMinimumBalanceForRentExemption(ne.byteSize(e),o)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const We=new b.FixableBeetStruct([["accountDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["isInitialized",b.bool],["bumpSeed",b.u8],["tokenProgramId",re.publicKey],["tokenA",re.publicKey],["tokenB",re.publicKey],["poolMint",re.publicKey],["tokenAMint",re.publicKey],["tokenBMint",re.publicKey],["poolFeeAccount",re.publicKey],["fees",vn],["curve",In],["policy",b.coption(re.publicKey)]],ne.fromArgs,"TokenSwap"),E=new Map,x=new Map;class Oe extends Error{constructor(){super("Swap account already in use"),g(this,"code",6e3),g(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Oe)}}E.set(6e3,()=>new Oe);x.set("AlreadyInUse",()=>new Oe);class Le extends Error{constructor(){super("Invalid program address generated from bump seed and key"),g(this,"code",6001),g(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Le)}}E.set(6001,()=>new Le);x.set("InvalidProgramAddress",()=>new Le);class Ue extends Error{constructor(){super("Input account owner is not the program address"),g(this,"code",6002),g(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ue)}}E.set(6002,()=>new Ue);x.set("InvalidOwner",()=>new Ue);class qe extends Error{constructor(){super("Output pool account owner cannot be the program address"),g(this,"code",6003),g(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,qe)}}E.set(6003,()=>new qe);x.set("InvalidOutputOwner",()=>new qe);class _e extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),g(this,"code",6004),g(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_e)}}E.set(6004,()=>new _e);x.set("ExpectedMint",()=>new _e);class He extends Error{constructor(){super("Deserialized account is not an SPL Token account"),g(this,"code",6005),g(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,He)}}E.set(6005,()=>new He);x.set("ExpectedAccount",()=>new He);class Ve extends Error{constructor(){super("Input token account empty"),g(this,"code",6006),g(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ve)}}E.set(6006,()=>new Ve);x.set("EmptySupply",()=>new Ve);class Ge extends Error{constructor(){super("Pool token mint has a non-zero supply"),g(this,"code",6007),g(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ge)}}E.set(6007,()=>new Ge);x.set("InvalidSupply",()=>new Ge);class Je extends Error{constructor(){super("Token account has a delegate"),g(this,"code",6008),g(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Je)}}E.set(6008,()=>new Je);x.set("InvalidDelegate",()=>new Je);class je extends Error{constructor(){super("InvalidInput"),g(this,"code",6009),g(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,je)}}E.set(6009,()=>new je);x.set("InvalidInput",()=>new je);class $e extends Error{constructor(){super("Address of the provided swap token account is incorrect"),g(this,"code",6010),g(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$e)}}E.set(6010,()=>new $e);x.set("IncorrectSwapAccount",()=>new $e);class Ye extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),g(this,"code",6011),g(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ye)}}E.set(6011,()=>new Ye);x.set("IncorrectPoolMint",()=>new Ye);class Xe extends Error{constructor(){super("InvalidOutput"),g(this,"code",6012),g(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xe)}}E.set(6012,()=>new Xe);x.set("InvalidOutput",()=>new Xe);class Ze extends Error{constructor(){super("General calculation failure due to overflow or underflow"),g(this,"code",6013),g(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ze)}}E.set(6013,()=>new Ze);x.set("CalculationFailure",()=>new Ze);class Qe extends Error{constructor(){super("Invalid instruction"),g(this,"code",6014),g(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Qe)}}E.set(6014,()=>new Qe);x.set("InvalidInstruction",()=>new Qe);class et extends Error{constructor(){super("Swap input token accounts have the same mint"),g(this,"code",6015),g(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,et)}}E.set(6015,()=>new et);x.set("RepeatedMint",()=>new et);class tt extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),g(this,"code",6016),g(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,tt)}}E.set(6016,()=>new tt);x.set("ExceededSlippage",()=>new tt);class nt extends Error{constructor(){super("Token account has a close authority"),g(this,"code",6017),g(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,nt)}}E.set(6017,()=>new nt);x.set("InvalidCloseAuthority",()=>new nt);class ot extends Error{constructor(){super("Pool token mint has a freeze authority"),g(this,"code",6018),g(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ot)}}E.set(6018,()=>new ot);x.set("InvalidFreezeAuthority",()=>new ot);class rt extends Error{constructor(){super("Pool fee token account incorrect"),g(this,"code",6019),g(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,rt)}}E.set(6019,()=>new rt);x.set("IncorrectFeeAccount",()=>new rt);class it extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),g(this,"code",6020),g(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,it)}}E.set(6020,()=>new it);x.set("ZeroTradingTokens",()=>new it);class st extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),g(this,"code",6021),g(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,st)}}E.set(6021,()=>new st);x.set("FeeCalculationFailure",()=>new st);class at extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),g(this,"code",6022),g(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,at)}}E.set(6022,()=>new at);x.set("ConversionFailure",()=>new at);class ct extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),g(this,"code",6023),g(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ct)}}E.set(6023,()=>new ct);x.set("InvalidFee",()=>new ct);class ut extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),g(this,"code",6024),g(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ut)}}E.set(6024,()=>new ut);x.set("IncorrectTokenProgramId",()=>new ut);class lt extends Error{constructor(){super("The provided curve type is not supported by the program owner"),g(this,"code",6025),g(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,lt)}}E.set(6025,()=>new lt);x.set("UnsupportedCurveType",()=>new lt);class dt extends Error{constructor(){super("The provided curve parameters are invalid"),g(this,"code",6026),g(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,dt)}}E.set(6026,()=>new dt);x.set("InvalidCurve",()=>new dt);class pt extends Error{constructor(){super("The operation cannot be performed on the given curve"),g(this,"code",6027),g(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pt)}}E.set(6027,()=>new pt);x.set("UnsupportedCurveOperation",()=>new pt);const Qo=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["poolTokenAmount",b.u64],["maximumTokenAAmount",b.u64],["maximumTokenBAmount",b.u64]],"DepositAllTokenTypesInstructionArgs"),er=[32,95,69,60,75,79,205,238];function tr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=Qo.serialize({instructionDiscriminator:er,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userTokenA,isWritable:!0,isSigner:!1},{pubkey:t.userTokenB,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??Z,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new C({programId:n,keys:r,data:o})}const nr=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["sourceTokenAmount",b.u64],["minimumPoolTokenAmount",b.u64]],"DepositSingleTokenTypeInstructionArgs"),or=[175,0,152,41,199,0,148,43];function rr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=nr.serialize({instructionDiscriminator:or,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??Z,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new C({programId:n,keys:r,data:o})}const ir=new b.FixableBeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["feesInput",vn],["curveInput",In],["policy",b.coption(re.publicKey)]],"InitializeInstructionArgs"),sr=[175,175,109,31,13,152,155,237];function ar(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=ir.serialize({instructionDiscriminator:sr,...e}),r=[{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.tokenA,isWritable:!0,isSigner:!1},{pubkey:t.tokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??Z,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new C({programId:n,keys:r,data:o})}const cr=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["amountIn",b.u64],["minimumAmountOut",b.u64]],"SwapInstructionArgs"),ur=[248,198,158,145,225,117,135,200];function lr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=cr.serialize({instructionDiscriminator:ur,...e}),r=[{pubkey:t.proofRequest??n,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userSource,isWritable:!0,isSigner:!1},{pubkey:t.userDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolSource,isWritable:!0,isSigner:!1},{pubkey:t.poolDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.hostFeeAccount??n,isWritable:!1,isSigner:!1},{pubkey:t.tokenProgram??Z,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new C({programId:n,keys:r,data:o})}const dr=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["poolTokenAmount",b.u64],["minimumTokenAAmount",b.u64],["minimumTokenBAmount",b.u64]],"WithdrawAllTokenTypesInstructionArgs"),pr=[189,254,156,174,210,9,164,216];function hr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=dr.serialize({instructionDiscriminator:pr,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destTokenA,isWritable:!0,isSigner:!1},{pubkey:t.destTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??Z,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new C({programId:n,keys:r,data:o})}const fr=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["destinationTokenAmount",b.u64],["maximumPoolTokenAmount",b.u64]],"WithdrawSingleTokenTypeInstructionArgs"),mr=[111,171,21,77,237,181,241,56];function gr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=fr.serialize({instructionDiscriminator:mr,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??Z,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new C({programId:n,keys:r,data:o})}var Tn=(t=>(t[t.ConstantProduct=0]="ConstantProduct",t[t.ConstantPrice=1]="ConstantPrice",t[t.Offset=2]="Offset",t))(Tn||{});b.fixedScalarEnum(Tn);var Bn=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(Bn||{});b.fixedScalarEnum(Bn);var En=(t=>(t[t.AtoB=0]="AtoB",t[t.BtoA=1]="BtoA",t))(En||{});b.fixedScalarEnum(En);const yr="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",br=new p(yr);class kr{constructor(e){g(this,"programId",br),this.provider=e}get connection(){return this.provider.connection}swapAuthority(e){return p.findProgramAddressSync([e.toBuffer()],this.programId)[0]}async createTokenSwap(e,n){const o=new ie,r=e.tokenSwap??ve.generate(),s=Array.from({length:32}),c=Array.from(e.curveParameters??[]);for(let z=0;z<c.length;z++)s[z]=c[z];const k={curveType:e.curveType,curveParameters:s},d=ne.byteSize({bumpSeed:0,curve:k,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:p.default,poolFeeAccount:p.default,poolMint:p.default,tokenA:p.default,tokenAMint:p.default,tokenB:p.default,tokenBMint:p.default,tokenProgramId:p.default}),w=await this.connection.getMinimumBalanceForRentExemption(d);o.add(le.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:r.publicKey,programId:this.programId,lamports:w,space:d})),o.add(ar({authority:this.swapAuthority(r.publicKey),tokenSwap:r.publicKey,destination:e.destination,poolMint:e.poolMint,poolFee:e.poolFee,tokenA:e.tokenA,tokenB:e.tokenB},{feesInput:{tradeFeeNumerator:new R(e.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new R(e.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new R(e.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new R(e.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new R(e.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new R(e.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new R(e.fees.hostFeeNumerator.toString()),hostFeeDenominator:new R(e.fees.hostFeeDenominator.toString())},curveInput:k,policy:e.policy??null}));const O=await this.provider.sendAndConfirm(o,[r],n);return{tokenSwap:r.publicKey,signature:O}}async swap(e,n){var o,r;const s=new ie;try{await en(this.connection,e.userDestination)}catch(c){(c instanceof kt||c instanceof St)&&e.destinationTokenMint&&s.add(tn(this.provider.publicKey,e.userDestination,this.provider.publicKey,e.destinationTokenMint))}if(e.sourceTokenMint&&((o=e.sourceTokenMint)==null?void 0:o.toBase58())===Xt.toBase58()){let c=0;try{const d=await en(this.connection,e.userSource);c=Number(d.amount)}catch(d){(d instanceof kt||d instanceof St)&&s.add(tn(this.provider.publicKey,e.userSource,this.provider.publicKey,e.sourceTokenMint))}const k=Number(e.amountIn);e.amountIn>c&&s.add(le.transfer({fromPubkey:this.provider.publicKey,toPubkey:e.userSource,lamports:k-c}),Yo(e.userSource))}return s.add(lr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:e.userSource,userDestination:e.userDestination,tokenSwap:e.tokenSwap,poolFee:e.poolFee,poolMint:e.poolMint,poolSource:e.poolSource,poolDestination:e.poolDestination,proofRequest:e.proofRequest,hostFeeAccount:e.hostFeeAccount},{amountIn:new R(e.amountIn.toString()),minimumAmountOut:new R(e.minimumAmountOut.toString())})),e.destinationTokenMint&&((r=e.destinationTokenMint)==null?void 0:r.toBase58())===Xt.toBase58()&&s.add(Ho(e.userDestination,this.provider.publicKey,this.provider.publicKey)),this.provider.sendAndConfirm(s,[],n)}async depositAllTokenTypes(e,n){const o=tr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,destination:e.destination,userTokenA:e.userTokenA,userTokenB:e.userTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new R(e.poolTokenAmount.toString()),maximumTokenAAmount:new R(e.maximumTokenA.toString()),maximumTokenBAmount:new R(e.maximumTokenB.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async withdrawAllTokenTypes(e,n){const o=hr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destTokenA:e.destTokenA,destTokenB:e.destTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new R(e.poolTokenAmount.toString()),minimumTokenAAmount:new R(e.minimumTokenA.toString()),minimumTokenBAmount:new R(e.minimumTokenB.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async depositSingleTokenTypeExactAmountIn(e,n){const o=rr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{sourceTokenAmount:new R(e.sourceTokenAmount.toString()),minimumPoolTokenAmount:new R(e.minimumPoolTokenAmount.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async withdrawSingleTokenTypeExactAmountOut(e,n){const o=gr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{destinationTokenAmount:new R(e.destinationTokenAmount.toString()),maximumPoolTokenAmount:new R(e.maximumPoolTokenAmount.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async load(e,n){return ne.fromAccountAddress(this.provider.connection,new p(e),n)}async loadAll(e={}){const n=ne.gpaBuilder().addFilter("accountDiscriminator",At);return e.noData&&(n.config.dataSlice={offset:0,length:0}),e.tokenProgramId&&n.addFilter("tokenProgramId",new p(e.tokenProgramId)),e.poolMint&&n.addFilter("poolMint",new p(e.poolMint)),e.tokenAMint&&n.addFilter("tokenAMint",new p(e.tokenAMint)),e.tokenBMint&&n.addFilter("tokenBMint",new p(e.tokenBMint)),(await n.run(this.provider.connection)).map(({pubkey:o,account:r})=>({pubkey:o,data:e.noData?null:ne.fromAccountInfo(r)[0]}))}}const Ar=qn("swap",()=>{const t=_n(),e=Hn(),n=Vn(),{publicKey:o}=Gn(),{notify:r}=Jn(),s=jn(()=>new kr(new Ot(t.connection,n.value??{publicKey:$n.default},Ot.defaultOptions()))),c=ke([]),k=ke([]),d=ke([]),w=ke(),O=Lt("token-a",""),z=Lt("token-b",""),a=Yn({loading:!1,slippageDialog:!1,status:void 0,poolBalance:{},poolTokenSupply:0,from:Ut,to:Ut,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:V,tokens:L}=Xn();V(Zn),Q(L,()=>{L.value.length>=2&&(a.from=L.value.find(S=>S.mint===O.value)??L.value[0],a.to=L.value.find(S=>S.mint===z.value)??L.value[1])},{immediate:!0}),Q(()=>a.from,()=>{a.from&&(O.value=a.from.mint)}),Q(()=>a.to,()=>{a.to&&(z.value=a.to.mint)}),Q(n,async S=>{v().then(),S||xn()},{immediate:!0});async function v(){a.loading=!0;try{console.log("swapClient ================: ",s.value),c.value=await s.value.loadAll(),console.log("swaps ================: ",c.value)}catch(S){console.log(S),c.value=[]}finally{a.loading=!1}}const B=ke(!1),F=Qn(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!w.value){B.value=!0;try{const S=await eo(t.connection,s.value.swapAuthority(w.value.pubkey)),M={};for(const oe of S)M[`${oe.mint}`]=oe.amount;a.poolBalance=M;const q=await to(t.connection,w.value.data.poolMint);a.poolTokenSupply=Number(q.supply),console.log("[Pool Balance]",a.poolBalance),console.log("[Pool Balance] poolTokenSupply",a.poolTokenSupply)}catch(S){console.log("[Pool Balance] error",S)}finally{B.value=!1}}},500);setInterval(F,6e4);function ce(S){w.value=S,console.log("setTokenSwap: ",w.value)}Q([c,()=>e.servicePolicy],async()=>{k.value=c.value.filter(S=>!!e.servicePolicy.find(M=>M.pubkey.toBase58()===S.data.policy?.toBase58()))},{immediate:!0}),Q([k,()=>a.from?.mint,()=>a.to?.mint,()=>e.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",k.value),k.value&&a.from?.mint&&a.to?.mint&&a.from.mint!==a.to.mint&&e.servicePolicy.length)if(d.value=k.value.filter(S=>{const M=S.data?.tokenAMint.toBase58(),q=S.data?.tokenBMint.toBase58();return M===a.from.mint&&q===a.to.mint||M===a.to.mint&&q===a.from.mint}),d.value.length){if(d.value.length>1){const S=d.value.find(M=>e.state.certificates?.find(q=>q.data?.policy.toBase58()===M.data.policy?.toBase58()));S&&(w.value=S)}w.value=d.value[0]}else w.value=void 0;else d.value=[],w.value=void 0,e.setContractPolicy("","swap"),a.poolBalance={}},{immediate:!0}),Q([w],async()=>{console.log("Token SWAP: ",w.value),e.setContractPolicy(w.value?.data.policy?.toBase58()??"","swap"),w.value&&(F(),w.value.data.tokenAMint.toBase58()===a.from.mint?a.direction=0:a.direction=1)},{immediate:!0});function xn(){a.loading=!1,a.slippageDialog=!1,a.status=void 0,a.poolBalance={},a.poolTokenSupply=0}Q([()=>a.direction,()=>a.from.amount,()=>a.poolBalance],async()=>{const S=Number(a.from.amount??0),M=qt(Number(a.poolBalance[a.from.mint]??0),a.from.decimals),q=qt(Number(a.poolBalance[a.to.mint]??0),a.to.decimals);if(S===0||Number.isNaN(S)){a.to.amount=0,a.rate=Number(q)/Number(M),a.impact=0,a.minimumReceived=0;return}const oe=q-M*q/(M+S);a.rate=S?oe/S:q/M,a.to.amount=oe?Number(no(oe*(1-a.fees.ownerTrade-a.fees.trade),a.to.decimals)):0,a.impact=S?1-oe/S/(q/M):0,a.minimumReceived=xe(a.to.amount-a.to.amount*a.slippage,a.to.decimals)},{immediate:!0});async function Pn(){if(!e.certificateValid)return oo();if(!w.value||!o.value){console.log("TokenSwap is not initialized...");return}n.value.publicKey||r({type:"info",message:"Please connect your wallet first"});const M=Number(xe(a.from.amount??0,a.from.decimals)),q=Number(xe(e.tokenBalance(a.from.mint)??0,a.from.decimals)),oe=Number(xe(a.to.amount??0,a.to.decimals));if(M>q){r({type:"negative",message:"Insufficient balance."});return}try{a.swapping=!0;const he=a.direction===0?w.value.data.tokenAMint:w.value.data.tokenBMint,Ee=a.direction===0?w.value.data.tokenBMint:w.value.data.tokenAMint,Mt=a.direction===0?w.value.data.tokenA:w.value.data.tokenB,Ft=a.direction===0?w.value.data.tokenB:w.value.data.tokenA;console.log("userSourceMint = ",he.toBase58()),console.log("userDestinationMint = ",Ee.toBase58()),console.log("userSourceMint = ",he.toBase58()),console.log("userDestinationMint = ",Ee.toBase58());const Kt=await _t(he,n.value.publicKey),Rt=await _t(Ee,n.value.publicKey),Ct=M;console.log("toAmount = ",oe),console.log("slippage = ",a.slippage),console.log("slippage 2 = ",oe*a.slippage);const Nt=s.value.swapAuthority(w.value.pubkey);console.log("proofRequest = ",e.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",Nt),console.log("tokenSwap = ",w.value.pubkey.toBase58()),console.log("userSource = ",Kt.toBase58()),console.log("userDestination = ",Rt.toBase58()),console.log("poolSource = ",Mt.toBase58()),console.log("poolDestination = ",Ft.toBase58()),console.log("poolMint = ",w.value.data.poolMint.toBase58()),console.log("poolFee = ",w.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",Ct),console.log("minimumAmountOut = ",a.minimumReceived);const Kn=await s.value.swap({proofRequest:e.certificate?.pubkey,authority:Nt,tokenSwap:w.value.pubkey,userSource:Kt,userDestination:Rt,poolSource:Mt,poolDestination:Ft,poolMint:w.value.data.poolMint,poolFee:w.value.data.poolFeeAccount,amountIn:Ct,minimumAmountOut:a.minimumReceived,sourceTokenMint:he,destinationTokenMint:Ee},{commitment:"confirmed"});ro(`https://explorer.solana.com/tx/${Kn}?cluster=${t.cluster}`),Wt()}catch(he){console.log(he)}finally{a.swapping=!1}}function Wn(){const{from:S,to:M}=a;a.rate=0,a.to={...S,amount:void 0},a.from={...M,amount:void 0},a.direction=a.direction===0?1:0}function zn(){a.slippageDialog=!0}function Mn(){a.slippageDialog=!1}function Fn(S){a.from.amount=S}function Wt(){F(),a.from.amount=void 0,a.to.amount=void 0}Q(()=>n.value?.publicKey,S=>{S||Wt()}),Q(()=>a.to,S=>{S.amount&&(S.amount=void 0)});function zt(S){return{host:Pe(S.fees.hostFeeNumerator,S.fees.hostFeeDenominator),trade:Pe(S.fees.tradeFeeNumerator,S.fees.tradeFeeDenominator),ownerTrade:Pe(S.fees.ownerTradeFeeNumerator,S.fees.ownerTradeFeeDenominator),ownerWithdraw:Pe(S.fees.ownerWithdrawFeeNumerator,S.fees.ownerWithdrawFeeDenominator)}}return Q(w,S=>{if(!S)return;const M=zt(S.data);a.fees.host=M.host,a.fees.trade=M.trade,a.fees.ownerTrade=M.ownerTrade,a.fees.ownerWithdraw=M.ownerWithdraw,console.log("fees ==== ",a.fees)}),{state:a,tokenSwapsAllFiltered:k,tokenSwaps:d,tokenSwap:w,swapClient:s,loadingPoolTokens:B,loadPoolTokenAccounts:F,setTokenSwap:ce,setMax:Fn,closeSlippage:Mn,openSlippage:zn,changeDirection:Wn,swapSubmit:Pn,getPoolFee:zt}});export{Tn as s,Ar as u};
