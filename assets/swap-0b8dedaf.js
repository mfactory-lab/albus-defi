import{b7 as ye,a as v,b8 as O,s as m,q as y,b9 as $,u as x,ba as ae,bb as me,bc as Ie,bd as d,be as vt,bf as It,bg as z,bh as Te,bi as u,bj as i,bk as f,bl as h,bm as w,bn as se,bo as on,bp as H,bq as Me,br as Z,bs as rn,bt as Q,h as G,Y as M,bu as Dt,bv as Fn,bw as Kn,bx as Rn,by as Cn,bz as Nn,bA as Dn,k as On,m as U,n as ht,v as b,bB as re,x as Ln,y as Un,B as qn,C as _n,F as Hn,G as Vn,A as Gn,Q as Ot,P as Jn,L as Ee,H as Lt,I as jn,bC as Ut,a0 as $n,M as Yn,J as oe,bD as Xn,bE as Zn,bF as Qn,aB as qt,ab as eo,bG as xe,X as to,N as _t,bH as Pe}from"./index-0da35a6e.js";ye.utils.randomPrivateKey;const Ht=()=>{const t=ye.utils.randomPrivateKey(),e=mt(t),n=new Uint8Array(64);return n.set(t),n.set(e,32),{publicKey:e,secretKey:n}},mt=ye.getPublicKey;function Vt(t){try{return ye.ExtendedPoint.fromHex(t),!0}catch{return!1}}const no=(t,e)=>ye.sign(t,e.slice(0,32)),oo=ye.verify,_=t=>v.Buffer.isBuffer(t)?t:t instanceof Uint8Array?v.Buffer.from(t.buffer,t.byteOffset,t.byteLength):v.Buffer.from(t);class ro{constructor(e){Object.assign(this,e)}encode(){return v.Buffer.from(Kn(ze,this))}static decode(e){return Rn(ze,this,e)}static decodeUnchecked(e){return Cn(ze,this,e)}}const ze=new Map;var sn;let an;const io=32,ue=32;function so(t){return t._bn!==void 0}let Gt=1;an=Symbol.toStringTag;class p extends ro{constructor(e){if(super({}),this._bn=void 0,so(e))this._bn=e._bn;else{if(typeof e=="string"){const n=G.decode(e);if(n.length!=ue)throw new Error("Invalid public key input");this._bn=new M(n)}else this._bn=new M(e);if(this._bn.byteLength()>ue)throw new Error("Invalid public key input")}}static unique(){const e=new p(Gt);return Gt+=1,new p(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return G.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(v.Buffer);if(e.length===ue)return e;const n=v.Buffer.alloc(32);return e.copy(n,32-e.length),n}get[an](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,n,o){const r=v.Buffer.concat([e.toBuffer(),v.Buffer.from(n),o.toBuffer()]),s=Dt(r);return new p(s)}static createProgramAddressSync(e,n){let o=v.Buffer.alloc(0);e.forEach(function(s){if(s.length>io)throw new TypeError("Max seed length exceeded");o=v.Buffer.concat([o,_(s)])}),o=v.Buffer.concat([o,n.toBuffer(),v.Buffer.from("ProgramDerivedAddress")]);const r=Dt(o);if(Vt(r))throw new Error("Invalid seeds, address must fall off the curve");return new p(r)}static async createProgramAddress(e,n){return this.createProgramAddressSync(e,n)}static findProgramAddressSync(e,n){let o=255,r;for(;o!=0;){try{const s=e.concat(v.Buffer.from([o]));r=this.createProgramAddressSync(s,n)}catch(s){if(s instanceof TypeError)throw s;o--;continue}return[r,o]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,n){return this.findProgramAddressSync(e,n)}static isOnCurve(e){const n=new p(e);return Vt(n.toBytes())}}sn=p;p.default=new sn("11111111111111111111111111111111");ze.set(p,{kind:"struct",fields:[["_bn","u256"]]});new p("BPFLoader1111111111111111111111111111111111");const gt=1280-40-8,ao=127,yt=64;class Jt{constructor(e,n){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=n}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const n of this.keySegments()){if(e<n.length)return n[e];e-=n.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const o=new Map;this.keySegments().flat().forEach((s,c)=>{o.set(s.toBase58(),c)});const r=s=>{const c=o.get(s.toBase58());if(c===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return c};return e.map(s=>({programIdIndex:r(s.programId),accountKeyIndexes:s.keys.map(c=>r(c.pubkey)),data:s.data}))}}const I=(t="publicKey")=>Q(32,t),fe=(t="string")=>{const e=m([y("length"),y("lengthPadding"),Q(me(y(),-8),"chars")],t),n=e.decode.bind(e),o=e.encode.bind(e),r=e;return r.decode=(s,c)=>n(s,c).chars.toString(),r.encode=(s,c,k)=>{const l={chars:v.Buffer.from(s,"utf8")};return o(l,c,k)},r.alloc=s=>y().span+y().span+v.Buffer.from(s,"utf8").length,r},co=(t="authorized")=>m([I("staker"),I("withdrawer")],t),uo=(t="lockup")=>m([$("unixTimestamp"),$("epoch"),I("custodian")],t),lo=(t="voteInit")=>m([I("nodePubkey"),I("authorizedVoter"),I("authorizedWithdrawer"),x("commission")],t),po=(t="voteAuthorizeWithSeedArgs")=>m([y("voteAuthorizationType"),I("currentAuthorityDerivedKeyOwnerPubkey"),fe("currentAuthorityDerivedKeySeed"),I("newAuthorized")],t);function cn(t,e){const n=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){const s=e[r.property];if(Array.isArray(s))return s.length*n(r.elementLayout)}else if("fields"in r)return cn({layout:r},e[r.property]);return 0};let o=0;return t.layout.fields.forEach(r=>{o+=n(r)}),o}function Se(t){let e=0,n=0;for(;;){let o=t.shift();if(e|=(o&127)<<n*7,n+=1,!(o&128))break}return e}function we(t,e){let n=e;for(;;){let o=n&127;if(n>>=7,n==0){t.push(o);break}else o|=128,t.push(o)}}function V(t,e){if(!t)throw new Error(e||"Assertion failed")}class Tt{constructor(e,n){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=n}static compile(e,n){const o=new Map,r=c=>{const k=c.toBase58();let l=o.get(k);return l===void 0&&(l={isSigner:!1,isWritable:!1,isInvoked:!1},o.set(k,l)),l},s=r(n);s.isSigner=!0,s.isWritable=!0;for(const c of e){r(c.programId).isInvoked=!0;for(const k of c.keys){const l=r(k.pubkey);l.isSigner||(l.isSigner=k.isSigner),l.isWritable||(l.isWritable=k.isWritable)}}return new Tt(n,o)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];V(e.length<=256,"Max static account keys length exceeded");const n=e.filter(([,l])=>l.isSigner&&l.isWritable),o=e.filter(([,l])=>l.isSigner&&!l.isWritable),r=e.filter(([,l])=>!l.isSigner&&l.isWritable),s=e.filter(([,l])=>!l.isSigner&&!l.isWritable),c={numRequiredSignatures:n.length+o.length,numReadonlySignedAccounts:o.length,numReadonlyUnsignedAccounts:s.length};{V(n.length>0,"Expected at least one writable signer key");const[l]=n[0];V(l===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const k=[...n.map(([l])=>new p(l)),...o.map(([l])=>new p(l)),...r.map(([l])=>new p(l)),...s.map(([l])=>new p(l))];return[c,k]}extractTableLookup(e){const[n,o]=this.drainKeysFoundInLookupTable(e.state.addresses,c=>!c.isSigner&&!c.isInvoked&&c.isWritable),[r,s]=this.drainKeysFoundInLookupTable(e.state.addresses,c=>!c.isSigner&&!c.isInvoked&&!c.isWritable);if(!(n.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:n,readonlyIndexes:r},{writable:o,readonly:s}]}drainKeysFoundInLookupTable(e,n){const o=new Array,r=new Array;for(const[s,c]of this.keyMetaMap.entries())if(n(c)){const k=new p(s),l=e.findIndex(R=>R.equals(k));l>=0&&(V(l<256,"Max lookup table index exceeded"),o.push(l),r.push(k),this.keyMetaMap.delete(s))}return[o,r]}}class ve{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(n=>new p(n)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(n=>this.indexToProgramIds.set(n.programIdIndex,this.accountKeys[n.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:G.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Jt(this.staticAccountKeys)}static compile(e){const n=Tt.compile(e.instructions,e.payerKey),[o,r]=n.getMessageComponents(),c=new Jt(r).compileInstructions(e.instructions).map(k=>({programIdIndex:k.programIdIndex,accounts:k.accountKeyIndexes,data:G.encode(k.data)}));return new ve({header:o,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:c})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const n=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const o=e-n,s=this.accountKeys.length-n-this.header.numReadonlyUnsignedAccounts;return o<s}else{const o=n-this.header.numReadonlySignedAccounts;return e<o}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,n)=>!this.isProgramId(n))}serialize(){const e=this.accountKeys.length;let n=[];we(n,e);const o=this.instructions.map(a=>{const{accounts:D,programIdIndex:N}=a,te=Array.from(G.decode(a.data));let A=[];we(A,D.length);let T=[];return we(T,te.length),{programIdIndex:N,keyIndicesCount:v.Buffer.from(A),keyIndices:D,dataLength:v.Buffer.from(T),data:te}});let r=[];we(r,o.length);let s=v.Buffer.alloc(gt);v.Buffer.from(r).copy(s);let c=r.length;o.forEach(a=>{const N=m([x("programIdIndex"),Q(a.keyIndicesCount.length,"keyIndicesCount"),ae(x("keyIndex"),a.keyIndices.length,"keyIndices"),Q(a.dataLength.length,"dataLength"),ae(x("userdatum"),a.data.length,"data")]).encode(a,s,c);c+=N}),s=s.slice(0,c);const k=m([Q(1,"numRequiredSignatures"),Q(1,"numReadonlySignedAccounts"),Q(1,"numReadonlyUnsignedAccounts"),Q(n.length,"keyCount"),ae(I("key"),e,"keys"),I("recentBlockhash")]),l={numRequiredSignatures:v.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:v.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:v.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:v.Buffer.from(n),keys:this.accountKeys.map(a=>_(a.toBytes())),recentBlockhash:G.decode(this.recentBlockhash)};let R=v.Buffer.alloc(2048);const L=k.encode(l,R);return s.copy(R,L),R.slice(0,L+s.length)}static from(e){let n=[...e];const o=n.shift();if(o!==(o&ao))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const r=n.shift(),s=n.shift(),c=Se(n);let k=[];for(let D=0;D<c;D++){const N=n.slice(0,ue);n=n.slice(ue),k.push(new p(v.Buffer.from(N)))}const l=n.slice(0,ue);n=n.slice(ue);const R=Se(n);let L=[];for(let D=0;D<R;D++){const N=n.shift(),te=Se(n),A=n.slice(0,te);n=n.slice(te);const T=Se(n),F=n.slice(0,T),ce=G.encode(v.Buffer.from(F));n=n.slice(T),L.push({programIdIndex:N,accounts:A,data:ce})}const a={header:{numRequiredSignatures:o,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:s},recentBlockhash:G.encode(v.Buffer.from(l)),accountKeys:k,instructions:L};return new ve(a)}}const ho=v.Buffer.alloc(yt).fill(0);class K{constructor(e){this.keys=void 0,this.programId=void 0,this.data=v.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:n,isWritable:o})=>({pubkey:e.toJSON(),isSigner:n,isWritable:o})),programId:this.programId.toJSON(),data:[...this.data]}}}class ie{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:n,nonceInfo:o}=e;this.minNonceContextSlot=n,this.nonceInfo=o}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:n,lastValidBlockHeight:o}=e;this.recentBlockhash=n,this.lastValidBlockHeight=o}else{const{recentBlockhash:n,nonceInfo:o}=e;o&&(this.nonceInfo=o),this.recentBlockhash=n}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(n=>{"instructions"in n?this.instructions=this.instructions.concat(n.instructions):"data"in n&&"programId"in n&&"keys"in n?this.instructions.push(n):this.instructions.push(new K(n))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,n;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?n=[this.nonceInfo.nonceInstruction,...this.instructions]:n=this.instructions):(e=this.recentBlockhash,n=this.instructions),!e)throw new Error("Transaction recentBlockhash required");n.length<1&&console.warn("No instructions provided");let o;if(this.feePayer)o=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)o=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let A=0;A<n.length;A++)if(n[A].programId===void 0)throw new Error(`Transaction instruction index ${A} has undefined program id`);const r=[],s=[];n.forEach(A=>{A.keys.forEach(F=>{s.push({...F})});const T=A.programId.toString();r.includes(T)||r.push(T)}),r.forEach(A=>{s.push({pubkey:new p(A),isSigner:!1,isWritable:!1})});const c=[];s.forEach(A=>{const T=A.pubkey.toString(),F=c.findIndex(ce=>ce.pubkey.toString()===T);F>-1?(c[F].isWritable=c[F].isWritable||A.isWritable,c[F].isSigner=c[F].isSigner||A.isSigner):c.push(A)}),c.sort(function(A,T){if(A.isSigner!==T.isSigner)return A.isSigner?-1:1;if(A.isWritable!==T.isWritable)return A.isWritable?-1:1;const F={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return A.pubkey.toBase58().localeCompare(T.pubkey.toBase58(),"en",F)});const k=c.findIndex(A=>A.pubkey.equals(o));if(k>-1){const[A]=c.splice(k,1);A.isSigner=!0,A.isWritable=!0,c.unshift(A)}else c.unshift({pubkey:o,isSigner:!0,isWritable:!0});for(const A of this.signatures){const T=c.findIndex(F=>F.pubkey.equals(A.publicKey));if(T>-1)c[T].isSigner||(c[T].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${A.publicKey.toString()}`)}let l=0,R=0,L=0;const a=[],D=[];c.forEach(({pubkey:A,isSigner:T,isWritable:F})=>{T?(a.push(A.toString()),l+=1,F||(R+=1)):(D.push(A.toString()),F||(L+=1))});const N=a.concat(D),te=n.map(A=>{const{data:T,programId:F}=A;return{programIdIndex:N.indexOf(F.toString()),accounts:A.keys.map(ce=>N.indexOf(ce.pubkey.toString())),data:G.encode(T)}});return te.forEach(A=>{V(A.programIdIndex>=0),A.accounts.forEach(T=>V(T>=0))}),new ve({header:{numRequiredSignatures:l,numReadonlySignedAccounts:R,numReadonlyUnsignedAccounts:L},accountKeys:N,recentBlockhash:e,instructions:te})}_compile(){const e=this.compileMessage(),n=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===n.length&&this.signatures.every((r,s)=>n[s].equals(r.publicKey))||(this.signatures=n.map(o=>({signature:null,publicKey:o}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const n=new Set;this.signatures=e.filter(o=>{const r=o.toString();return n.has(r)?!1:(n.add(r),!0)}).map(o=>({signature:null,publicKey:o}))}sign(...e){if(e.length===0)throw new Error("No signers");const n=new Set,o=[];for(const s of e){const c=s.publicKey.toString();n.has(c)||(n.add(c),o.push(s))}this.signatures=o.map(s=>({signature:null,publicKey:s.publicKey}));const r=this._compile();this._partialSign(r,...o)}partialSign(...e){if(e.length===0)throw new Error("No signers");const n=new Set,o=[];for(const s of e){const c=s.publicKey.toString();n.has(c)||(n.add(c),o.push(s))}const r=this._compile();this._partialSign(r,...o)}_partialSign(e,...n){const o=e.serialize();n.forEach(r=>{const s=no(o,r.secretKey);this._addSignature(r.publicKey,_(s))})}addSignature(e,n){this._compile(),this._addSignature(e,n)}_addSignature(e,n){V(n.length===64);const o=this.signatures.findIndex(r=>e.equals(r.publicKey));if(o<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[o].signature=v.Buffer.from(n)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,n){for(const{signature:o,publicKey:r}of this.signatures)if(o===null){if(n)return!1}else if(!oo(o,e,r.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:n,verifySignatures:o}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(o&&!this._verifySignatures(r,n))throw new Error("Signature verification failed");return this._serialize(r)}_serialize(e){const{signatures:n}=this,o=[];we(o,n.length);const r=o.length+n.length*64+e.length,s=v.Buffer.alloc(r);return V(n.length<256),v.Buffer.from(o).copy(s,0),n.forEach(({signature:c},k)=>{c!==null&&(V(c.length===64,"signature has invalid length"),v.Buffer.from(c).copy(s,o.length+k*64))}),e.copy(s,o.length+n.length*64),V(s.length<=gt,`Transaction too large: ${s.length} > ${gt}`),s}get keys(){return V(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return V(this.instructions.length===1),this.instructions[0].programId}get data(){return V(this.instructions.length===1),this.instructions[0].data}static from(e){let n=[...e];const o=Se(n);let r=[];for(let s=0;s<o;s++){const c=n.slice(0,yt);n=n.slice(yt),r.push(G.encode(v.Buffer.from(c)))}return ie.populate(ve.from(n),r)}static populate(e,n=[]){const o=new ie;return o.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(o.feePayer=e.accountKeys[0]),n.forEach((r,s)=>{const c={signature:r==G.encode(ho)?null:G.decode(r),publicKey:e.accountKeys[s]};o.signatures.push(c)}),e.instructions.forEach(r=>{const s=r.accounts.map(c=>{const k=e.accountKeys[c];return{pubkey:k,isSigner:o.signatures.some(l=>l.publicKey.toString()===k.toString())||e.isAccountSigner(c),isWritable:e.isAccountWritable(c)}});o.instructions.push(new K({keys:s,programId:e.accountKeys[r.programIdIndex],data:G.decode(r.data)}))}),o._message=e,o._json=o.toJSON(),o}}new p("SysvarC1ock11111111111111111111111111111111");new p("SysvarEpochSchedu1e111111111111111111111111");new p("Sysvar1nstructions1111111111111111111111111");const ft=new p("SysvarRecentB1ockHashes11111111111111111111"),jt=new p("SysvarRent111111111111111111111111111111111");new p("SysvarRewards111111111111111111111111111111");new p("SysvarS1otHashes111111111111111111111111111");new p("SysvarS1otHistory11111111111111111111111111");new p("SysvarStakeHistory1111111111111111111111111");function J(t,e){const n=t.layout.span>=0?t.layout.span:cn(t,e),o=v.Buffer.alloc(n),r=Object.assign({instruction:t.index},e);return t.layout.encode(r,o),o}const fo=O("lamportsPerSignature"),mo=m([y("version"),y("state"),I("authorizedPubkey"),I("nonce"),m([fo],"feeCalculator")]),$t=mo.span,go=t=>{const e=t.decode.bind(t),n=t.encode.bind(t);return{decode:e,encode:n}},yo=t=>e=>{const n=Q(t,e),{encode:o,decode:r}=go(n),s=n;return s.decode=(c,k)=>{const l=r(c,k);return Nn(v.Buffer.from(l))},s.encode=(c,k,l)=>{const R=Dn(c,t);return o(R,k,l)},s},ge=yo(8),j=Object.freeze({Create:{index:0,layout:m([y("instruction"),$("lamports"),$("space"),I("programId")])},Assign:{index:1,layout:m([y("instruction"),I("programId")])},Transfer:{index:2,layout:m([y("instruction"),ge("lamports")])},CreateWithSeed:{index:3,layout:m([y("instruction"),I("base"),fe("seed"),$("lamports"),$("space"),I("programId")])},AdvanceNonceAccount:{index:4,layout:m([y("instruction")])},WithdrawNonceAccount:{index:5,layout:m([y("instruction"),$("lamports")])},InitializeNonceAccount:{index:6,layout:m([y("instruction"),I("authorized")])},AuthorizeNonceAccount:{index:7,layout:m([y("instruction"),I("authorized")])},Allocate:{index:8,layout:m([y("instruction"),$("space")])},AllocateWithSeed:{index:9,layout:m([y("instruction"),I("base"),fe("seed"),$("space"),I("programId")])},AssignWithSeed:{index:10,layout:m([y("instruction"),I("base"),fe("seed"),I("programId")])},TransferWithSeed:{index:11,layout:m([y("instruction"),ge("lamports"),fe("seed"),I("programId")])},UpgradeNonceAccount:{index:12,layout:m([y("instruction")])}});class le{constructor(){}static createAccount(e){const n=j.Create,o=J(n,{lamports:e.lamports,space:e.space,programId:_(e.programId.toBuffer())});return new K({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:o})}static transfer(e){let n,o;if("basePubkey"in e){const r=j.TransferWithSeed;n=J(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:_(e.programId.toBuffer())}),o=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const r=j.Transfer;n=J(r,{lamports:BigInt(e.lamports)}),o=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new K({keys:o,programId:this.programId,data:n})}static assign(e){let n,o;if("basePubkey"in e){const r=j.AssignWithSeed;n=J(r,{base:_(e.basePubkey.toBuffer()),seed:e.seed,programId:_(e.programId.toBuffer())}),o=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=j.Assign;n=J(r,{programId:_(e.programId.toBuffer())}),o=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new K({keys:o,programId:this.programId,data:n})}static createAccountWithSeed(e){const n=j.CreateWithSeed,o=J(n,{base:_(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:_(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new K({keys:r,programId:this.programId,data:o})}static createNonceAccount(e){const n=new ie;"basePubkey"in e&&"seed"in e?n.add(le.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:$t,programId:this.programId})):n.add(le.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:$t,programId:this.programId}));const o={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return n.add(this.nonceInitialize(o)),n}static nonceInitialize(e){const n=j.InitializeNonceAccount,o=J(n,{authorized:_(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1}],programId:this.programId,data:o};return new K(r)}static nonceAdvance(e){const n=j.AdvanceNonceAccount,o=J(n),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new K(r)}static nonceWithdraw(e){const n=j.WithdrawNonceAccount,o=J(n,{lamports:e.lamports});return new K({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static nonceAuthorize(e){const n=j.AuthorizeNonceAccount,o=J(n,{authorized:_(e.newAuthorizedPubkey.toBuffer())});return new K({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static allocate(e){let n,o;if("basePubkey"in e){const r=j.AllocateWithSeed;n=J(r,{base:_(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:_(e.programId.toBuffer())}),o=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=j.Allocate;n=J(r,{space:e.space}),o=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new K({keys:o,programId:this.programId,data:n})}}le.programId=new p("11111111111111111111111111111111");new p("BPFLoader2111111111111111111111111111111111");m([y("typeIndex"),ge("deactivationSlot"),O("lastExtendedSlot"),x("lastExtendedStartIndex"),x(),ae(I(),me(x(),-1),"authority")]);const C=Ie(vt(p),d(),t=>new p(t)),un=It([d(),z("base64")]),Bt=Ie(vt(v.Buffer),un,t=>v.Buffer.from(t[0],"base64"));function ln(t){return H([u({jsonrpc:z("2.0"),id:d(),result:t}),u({jsonrpc:z("2.0"),id:d(),error:u({code:Te(),message:d(),data:w(Fn())})})])}const bo=ln(Te());function P(t){return Ie(ln(t),bo,e=>"error"in e?e:{...e,result:Me(e.result,t)})}function Y(t){return P(u({context:u({slot:i()}),value:t}))}function Ce(t){return u({context:u({slot:i()}),value:t})}const ko=u({foundation:i(),foundationTerm:i(),initial:i(),taper:i(),terminal:i()});P(f(h(u({epoch:i(),effectiveSlot:i(),amount:i(),postBalance:i(),commission:w(h(i()))}))));const So=f(u({slot:i(),prioritizationFee:i()})),wo=u({total:i(),validator:i(),foundation:i(),epoch:i()}),Ao=u({epoch:i(),slotIndex:i(),slotsInEpoch:i(),absoluteSlot:i(),blockHeight:w(i()),transactionCount:w(i())}),vo=u({slotsPerEpoch:i(),leaderScheduleSlotOffset:i(),warmup:se(),firstNormalEpoch:i(),firstNormalSlot:i()}),Io=on(d(),f(i())),de=h(H([u({}),d()])),To=u({err:de}),Bo=z("receivedSignature");u({"solana-core":d(),"feature-set":w(i())});Y(u({err:h(H([u({}),d()])),logs:h(f(d())),accounts:w(h(f(h(u({executable:se(),owner:d(),lamports:i(),data:f(d()),rentEpoch:w(i())}))))),unitsConsumed:w(i()),returnData:w(h(u({programId:d(),data:It([d(),z("base64")])})))}));Y(u({byIdentity:on(d(),f(i())),range:u({firstSlot:i(),lastSlot:i()})}));P(ko);P(wo);P(So);P(Ao);P(vo);P(Io);P(i());Y(u({total:i(),circulating:i(),nonCirculating:i(),nonCirculatingAccounts:f(C)}));const Eo=u({amount:d(),uiAmount:h(i()),decimals:i(),uiAmountString:w(d())});Y(f(u({address:C,amount:d(),uiAmount:h(i()),decimals:i(),uiAmountString:w(d())})));Y(f(u({pubkey:C,account:u({executable:se(),owner:C,lamports:i(),data:Bt,rentEpoch:i()})})));const bt=u({program:d(),parsed:Te(),space:i()});Y(f(u({pubkey:C,account:u({executable:se(),owner:C,lamports:i(),data:bt,rentEpoch:i()})})));Y(f(u({lamports:i(),address:C})));const Et=u({executable:se(),owner:C,lamports:i(),data:Bt,rentEpoch:i()});u({pubkey:C,account:Et});const xo=Ie(H([vt(v.Buffer),bt]),H([un,bt]),t=>Array.isArray(t)?Me(t,Bt):t),Po=u({executable:se(),owner:C,lamports:i(),data:xo,rentEpoch:i()});u({pubkey:C,account:Po});u({state:H([z("active"),z("inactive"),z("activating"),z("deactivating")]),active:i(),inactive:i()});P(f(u({signature:d(),slot:i(),err:de,memo:h(d()),blockTime:w(h(i()))})));P(f(u({signature:d(),slot:i(),err:de,memo:h(d()),blockTime:w(h(i()))})));u({subscription:i(),result:Ce(Et)});const Wo=u({pubkey:C,account:Et});u({subscription:i(),result:Ce(Wo)});const zo=u({parent:i(),slot:i(),root:i()});u({subscription:i(),result:zo});const Mo=H([u({type:H([z("firstShredReceived"),z("completed"),z("optimisticConfirmation"),z("root")]),slot:i(),timestamp:i()}),u({type:z("createdBank"),parent:i(),slot:i(),timestamp:i()}),u({type:z("frozen"),slot:i(),timestamp:i(),stats:u({numTransactionEntries:i(),numSuccessfulTransactions:i(),numFailedTransactions:i(),maxTransactionsPerEntry:i()})}),u({type:z("dead"),slot:i(),timestamp:i(),err:d()})]);u({subscription:i(),result:Mo});u({subscription:i(),result:Ce(H([To,Bo]))});u({subscription:i(),result:i()});u({pubkey:d(),gossip:h(d()),tpu:h(d()),rpc:h(d()),version:h(d())});const Yt=u({votePubkey:d(),nodePubkey:d(),activatedStake:i(),epochVoteAccount:se(),epochCredits:f(It([i(),i(),i()])),commission:i(),lastVote:i(),rootSlot:h(i())});P(u({current:f(Yt),delinquent:f(Yt)}));const Fo=H([z("processed"),z("confirmed"),z("finalized")]),Ko=u({slot:i(),confirmations:h(i()),err:de,confirmationStatus:w(Fo)});Y(f(h(Ko)));P(i());const dn=u({accountKey:C,writableIndexes:f(i()),readonlyIndexes:f(i())}),xt=u({signatures:f(d()),message:u({accountKeys:f(d()),header:u({numRequiredSignatures:i(),numReadonlySignedAccounts:i(),numReadonlyUnsignedAccounts:i()}),instructions:f(u({accounts:f(i()),data:d(),programIdIndex:i()})),recentBlockhash:d(),addressTableLookups:w(f(dn))})}),pn=u({pubkey:C,signer:se(),writable:se(),source:w(H([z("transaction"),z("lookupTable")]))}),hn=u({accountKeys:f(pn),signatures:f(d())}),fn=u({parsed:Te(),program:d(),programId:C}),mn=u({accounts:f(C),data:d(),programId:C}),Ro=H([mn,fn]),Co=H([u({parsed:Te(),program:d(),programId:d()}),u({accounts:f(d()),data:d(),programId:d()})]),gn=Ie(Ro,Co,t=>"accounts"in t?Me(t,mn):Me(t,fn)),yn=u({signatures:f(d()),message:u({accountKeys:f(pn),instructions:f(gn),recentBlockhash:d(),addressTableLookups:w(h(f(dn)))})}),Fe=u({accountIndex:i(),mint:d(),owner:w(d()),uiTokenAmount:Eo}),bn=u({writable:f(C),readonly:f(C)}),Ne=u({err:de,fee:i(),innerInstructions:w(h(f(u({index:i(),instructions:f(u({accounts:f(i()),data:d(),programIdIndex:i()}))})))),preBalances:f(i()),postBalances:f(i()),logMessages:w(h(f(d()))),preTokenBalances:w(h(f(Fe))),postTokenBalances:w(h(f(Fe))),loadedAddresses:w(bn),computeUnitsConsumed:w(i())}),Pt=u({err:de,fee:i(),innerInstructions:w(h(f(u({index:i(),instructions:f(gn)})))),preBalances:f(i()),postBalances:f(i()),logMessages:w(h(f(d()))),preTokenBalances:w(h(f(Fe))),postTokenBalances:w(h(f(Fe))),loadedAddresses:w(bn),computeUnitsConsumed:w(i())}),be=H([z(0),z("legacy")]),pe=u({pubkey:d(),lamports:i(),postBalance:h(i()),rewardType:h(d()),commission:w(h(i()))});P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),transactions:f(u({transaction:xt,meta:h(Ne),version:w(be)})),rewards:w(f(pe)),blockTime:h(i()),blockHeight:h(i())})));P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),rewards:w(f(pe)),blockTime:h(i()),blockHeight:h(i())})));P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),transactions:f(u({transaction:hn,meta:h(Ne),version:w(be)})),rewards:w(f(pe)),blockTime:h(i()),blockHeight:h(i())})));P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),transactions:f(u({transaction:yn,meta:h(Pt),version:w(be)})),rewards:w(f(pe)),blockTime:h(i()),blockHeight:h(i())})));P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),transactions:f(u({transaction:hn,meta:h(Pt),version:w(be)})),rewards:w(f(pe)),blockTime:h(i()),blockHeight:h(i())})));P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),rewards:w(f(pe)),blockTime:h(i()),blockHeight:h(i())})));P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),transactions:f(u({transaction:xt,meta:h(Ne)})),rewards:w(f(pe)),blockTime:h(i())})));P(h(u({blockhash:d(),previousBlockhash:d(),parentSlot:i(),signatures:f(d()),blockTime:h(i())})));P(h(u({slot:i(),meta:h(Ne),blockTime:w(h(i())),transaction:xt,version:w(be)})));P(h(u({slot:i(),transaction:yn,meta:h(Pt),blockTime:w(h(i())),version:w(be)})));Y(u({blockhash:d(),feeCalculator:u({lamportsPerSignature:i()})}));Y(u({blockhash:d(),lastValidBlockHeight:i()}));Y(se());const No=u({slot:i(),numTransactions:i(),numSlots:i(),samplePeriodSecs:i()});P(f(No));Y(h(u({feeCalculator:u({lamportsPerSignature:i()})})));P(d());P(d());const Do=u({err:de,logs:f(d()),signature:d()});u({result:Ce(Do),subscription:i()});class Ae{constructor(e){this._keypair=void 0,this._keypair=e??Ht()}static generate(){return new Ae(Ht())}static fromSecretKey(e,n){if(e.byteLength!==64)throw new Error("bad secret key size");const o=e.slice(32,64);if(!n||!n.skipValidation){const r=e.slice(0,32),s=mt(r);for(let c=0;c<32;c++)if(o[c]!==s[c])throw new Error("provided secretKey is invalid")}return new Ae({publicKey:o,secretKey:e})}static fromSeed(e){const n=mt(e),o=new Uint8Array(64);return o.set(e),o.set(n,32),new Ae({publicKey:n,secretKey:o})}get publicKey(){return new p(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:m([y("instruction"),ge("recentSlot"),x("bumpSeed")])},FreezeLookupTable:{index:1,layout:m([y("instruction")])},ExtendLookupTable:{index:2,layout:m([y("instruction"),ge(),ae(I(),me(y(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:m([y("instruction")])},CloseLookupTable:{index:4,layout:m([y("instruction")])}});new p("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:m([x("instruction"),y("units"),y("additionalFee")])},RequestHeapFrame:{index:1,layout:m([x("instruction"),y("bytes")])},SetComputeUnitLimit:{index:2,layout:m([x("instruction"),y("units")])},SetComputeUnitPrice:{index:3,layout:m([x("instruction"),ge("microLamports")])}});new p("ComputeBudget111111111111111111111111111111");m([x("numSignatures"),x("padding"),Z("signatureOffset"),Z("signatureInstructionIndex"),Z("publicKeyOffset"),Z("publicKeyInstructionIndex"),Z("messageDataOffset"),Z("messageDataSize"),Z("messageInstructionIndex")]);new p("Ed25519SigVerify111111111111111111111111111");rn.utils.isValidPrivateKey;rn.getPublicKey;m([x("numSignatures"),Z("signatureOffset"),x("signatureInstructionIndex"),Z("ethAddressOffset"),x("ethAddressInstructionIndex"),Z("messageDataOffset"),Z("messageDataSize"),x("messageInstructionIndex"),Q(20,"ethAddress"),Q(64,"signature"),x("recoveryId")]);new p("KeccakSecp256k11111111111111111111111111111");var kn;new p("StakeConfig11111111111111111111111111111111");class Sn{constructor(e,n,o){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=n,this.custodian=o}}kn=Sn;Sn.default=new kn(0,0,p.default);Object.freeze({Initialize:{index:0,layout:m([y("instruction"),co(),uo()])},Authorize:{index:1,layout:m([y("instruction"),I("newAuthorized"),y("stakeAuthorizationType")])},Delegate:{index:2,layout:m([y("instruction")])},Split:{index:3,layout:m([y("instruction"),$("lamports")])},Withdraw:{index:4,layout:m([y("instruction"),$("lamports")])},Deactivate:{index:5,layout:m([y("instruction")])},Merge:{index:7,layout:m([y("instruction")])},AuthorizeWithSeed:{index:8,layout:m([y("instruction"),I("newAuthorized"),y("stakeAuthorizationType"),fe("authoritySeed"),I("authorityOwner")])}});new p("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:m([y("instruction"),lo()])},Authorize:{index:1,layout:m([y("instruction"),I("newAuthorized"),y("voteAuthorizationType")])},Withdraw:{index:3,layout:m([y("instruction"),$("lamports")])},AuthorizeWithSeed:{index:10,layout:m([y("instruction"),po()])}});new p("Vote111111111111111111111111111111111111111");new p("Va1idator1nfo111111111111111111111111111111");u({name:d(),website:w(d()),details:w(d()),keybaseUsername:w(d())});new p("Vote111111111111111111111111111111111111111");m([I("nodePubkey"),I("authorizedWithdrawer"),x("commission"),O(),ae(m([O("slot"),y("confirmationCount")]),me(y(),-8),"votes"),x("rootSlotValid"),O("rootSlot"),O(),ae(m([O("epoch"),I("authorizedVoter")]),me(y(),-8),"authorizedVoters"),m([ae(m([I("authorizedPubkey"),O("epochOfLastAuthorizedSwitch"),O("targetEpoch")]),32,"buf"),O("idx"),x("isEmpty")],"priorVoters"),O(),ae(m([O("epoch"),O("credits"),O("prevCredits")]),me(y(),-8),"epochCredits"),m([O("slot"),O("timestamp")],"lastTimestamp")]);const X=new p("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new p("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const wn=new p("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),Xt=new p("So11111111111111111111111111111111111111112");new p("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");class De extends Error{constructor(e){super(e)}}class kt extends De{constructor(){super(...arguments),this.name="TokenAccountNotFoundError"}}class Oo extends De{constructor(){super(...arguments),this.name="TokenInvalidAccountError"}}class St extends De{constructor(){super(...arguments),this.name="TokenInvalidAccountOwnerError"}}class Zt extends De{constructor(){super(...arguments),this.name="TokenInvalidAccountSizeError"}}var Ke;(function(t){t[t.InitializeMint=0]="InitializeMint",t[t.InitializeAccount=1]="InitializeAccount",t[t.InitializeMultisig=2]="InitializeMultisig",t[t.Transfer=3]="Transfer",t[t.Approve=4]="Approve",t[t.Revoke=5]="Revoke",t[t.SetAuthority=6]="SetAuthority",t[t.MintTo=7]="MintTo",t[t.Burn=8]="Burn",t[t.CloseAccount=9]="CloseAccount",t[t.FreezeAccount=10]="FreezeAccount",t[t.ThawAccount=11]="ThawAccount",t[t.TransferChecked=12]="TransferChecked",t[t.ApproveChecked=13]="ApproveChecked",t[t.MintToChecked=14]="MintToChecked",t[t.BurnChecked=15]="BurnChecked",t[t.InitializeAccount2=16]="InitializeAccount2",t[t.SyncNative=17]="SyncNative",t[t.InitializeAccount3=18]="InitializeAccount3",t[t.InitializeMultisig2=19]="InitializeMultisig2",t[t.InitializeMint2=20]="InitializeMint2",t[t.GetAccountDataSize=21]="GetAccountDataSize",t[t.InitializeImmutableOwner=22]="InitializeImmutableOwner",t[t.AmountToUiAmount=23]="AmountToUiAmount",t[t.UiAmountToAmount=24]="UiAmountToAmount",t[t.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",t[t.TransferFeeExtension=26]="TransferFeeExtension",t[t.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",t[t.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",t[t.Reallocate=29]="Reallocate",t[t.MemoTransferExtension=30]="MemoTransferExtension",t[t.CreateNativeMint=31]="CreateNativeMint",t[t.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",t[t.InterestBearingMintExtension=33]="InterestBearingMintExtension",t[t.CpiGuardExtension=34]="CpiGuardExtension",t[t.InitializePermanentDelegate=35]="InitializePermanentDelegate",t[t.TransferHookExtension=36]="TransferHookExtension",t[t.MetadataPointerExtension=39]="MetadataPointerExtension"})(Ke||(Ke={}));function Lo(t,e,n){if(n.length){t.push({pubkey:e,isSigner:!1,isWritable:!1});for(const o of n)t.push({pubkey:o instanceof p?o:o.publicKey,isSigner:!0,isWritable:!1})}else t.push({pubkey:e,isSigner:!0,isWritable:!1});return t}const Qt=m([x("instruction")]);function Uo(t,e,n,o=[],r=X){const s=Lo([{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0}],n,o),c=v.Buffer.alloc(Qt.span);return Qt.encode({instruction:Ke.CloseAccount},c),new K({keys:s,programId:r,data:c})}var wt;(function(t){t[t.Uninitialized=0]="Uninitialized",t[t.Mint=1]="Mint",t[t.Account=2]="Account"})(wt||(wt={}));const qo=1,_o=m([x("m"),x("n"),On("isInitialized"),U("signer1"),U("signer2"),U("signer3"),U("signer4"),U("signer5"),U("signer6"),U("signer7"),U("signer8"),U("signer9"),U("signer10"),U("signer11")]),Ho=_o.span;var Re;(function(t){t[t.Uninitialized=0]="Uninitialized",t[t.Initialized=1]="Initialized",t[t.Frozen=2]="Frozen"})(Re||(Re={}));const An=m([U("mint"),U("owner"),ht("amount"),y("delegateOption"),U("delegate"),x("state"),y("isNativeOption"),ht("isNative"),ht("delegatedAmount"),y("closeAuthorityOption"),U("closeAuthority")]),ke=An.span;async function en(t,e,n,o=X){const r=await t.getAccountInfo(e,n);return Vo(e,r,o)}function Vo(t,e,n=X){if(!e)throw new kt;if(!e.owner.equals(n))throw new St;if(e.data.length<ke)throw new Zt;const o=An.decode(e.data.slice(0,ke));let r=v.Buffer.alloc(0);if(e.data.length>ke){if(e.data.length===Ho)throw new Zt;if(e.data[ke]!=wt.Account)throw new Oo;r=e.data.slice(ke+qo)}return{address:t,mint:o.mint,owner:o.owner,amount:o.amount,delegate:o.delegateOption?o.delegate:null,delegatedAmount:o.delegatedAmount,isInitialized:o.state!==Re.Uninitialized,isFrozen:o.state===Re.Frozen,isNative:!!o.isNativeOption,rentExemptReserve:o.isNativeOption?o.isNative:null,closeAuthority:o.closeAuthorityOption?o.closeAuthority:null,tlvData:r}}function tn(t,e,n,o,r=X,s=wn){return Go(t,e,n,o,v.Buffer.alloc(0),r,s)}function Go(t,e,n,o,r,s=X,c=wn){const k=[{pubkey:t,isSigner:!0,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:le.programId,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1}];return new K({keys:k,programId:c,data:r})}const nn=m([x("instruction")]);function Jo(t,e=X){const n=[{pubkey:t,isSigner:!1,isWritable:!0}],o=v.Buffer.alloc(nn.span);return nn.encode({instruction:Ke.SyncNative},o),new K({keys:n,programId:e,data:o})}var jo=Object.defineProperty,$o=(t,e,n)=>e in t?jo(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,g=(t,e,n)=>($o(t,typeof e!="symbol"?e+"":e,n),n);const vn=new b.BeetArgsStruct([["tradeFeeNumerator",b.u64],["tradeFeeDenominator",b.u64],["ownerTradeFeeNumerator",b.u64],["ownerTradeFeeDenominator",b.u64],["ownerWithdrawFeeNumerator",b.u64],["ownerWithdrawFeeDenominator",b.u64],["hostFeeNumerator",b.u64],["hostFeeDenominator",b.u64]],"FeesInfo"),In=new b.BeetArgsStruct([["curveType",b.u8],["curveParameters",b.uniformFixedSizeArray(b.u8,32)]],"CurveInfo"),At=[135,144,215,161,140,125,41,96];class ee{constructor(e,n,o,r,s,c,k,l,R,L,a,D){this.isInitialized=e,this.bumpSeed=n,this.tokenProgramId=o,this.tokenA=r,this.tokenB=s,this.poolMint=c,this.tokenAMint=k,this.tokenBMint=l,this.poolFeeAccount=R,this.fees=L,this.curve=a,this.policy=D}static fromArgs(e){return new ee(e.isInitialized,e.bumpSeed,e.tokenProgramId,e.tokenA,e.tokenB,e.poolMint,e.tokenAMint,e.tokenBMint,e.poolFeeAccount,e.fees,e.curve,e.policy)}static fromAccountInfo(e,n=0){return ee.deserialize(e.data,n)}static async fromAccountAddress(e,n,o){const r=await e.getAccountInfo(n,o);if(r==null)throw new Error(`Unable to find TokenSwap account at ${n}`);return ee.fromAccountInfo(r,0)[0]}static gpaBuilder(e=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return re.GpaBuilder.fromStruct(e,We)}static deserialize(e,n=0){return We.deserialize(e,n)}serialize(){return We.serialize({accountDiscriminator:At,...this})}static byteSize(e){const n=ee.fromArgs(e);return We.toFixedFromValue({accountDiscriminator:At,...n}).byteSize}static async getMinimumBalanceForRentExemption(e,n,o){return n.getMinimumBalanceForRentExemption(ee.byteSize(e),o)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const We=new b.FixableBeetStruct([["accountDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["isInitialized",b.bool],["bumpSeed",b.u8],["tokenProgramId",re.publicKey],["tokenA",re.publicKey],["tokenB",re.publicKey],["poolMint",re.publicKey],["tokenAMint",re.publicKey],["tokenBMint",re.publicKey],["poolFeeAccount",re.publicKey],["fees",vn],["curve",In],["policy",b.coption(re.publicKey)]],ee.fromArgs,"TokenSwap"),B=new Map,E=new Map;class Oe extends Error{constructor(){super("Swap account already in use"),g(this,"code",6e3),g(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Oe)}}B.set(6e3,()=>new Oe);E.set("AlreadyInUse",()=>new Oe);class Le extends Error{constructor(){super("Invalid program address generated from bump seed and key"),g(this,"code",6001),g(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Le)}}B.set(6001,()=>new Le);E.set("InvalidProgramAddress",()=>new Le);class Ue extends Error{constructor(){super("Input account owner is not the program address"),g(this,"code",6002),g(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ue)}}B.set(6002,()=>new Ue);E.set("InvalidOwner",()=>new Ue);class qe extends Error{constructor(){super("Output pool account owner cannot be the program address"),g(this,"code",6003),g(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,qe)}}B.set(6003,()=>new qe);E.set("InvalidOutputOwner",()=>new qe);class _e extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),g(this,"code",6004),g(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_e)}}B.set(6004,()=>new _e);E.set("ExpectedMint",()=>new _e);class He extends Error{constructor(){super("Deserialized account is not an SPL Token account"),g(this,"code",6005),g(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,He)}}B.set(6005,()=>new He);E.set("ExpectedAccount",()=>new He);class Ve extends Error{constructor(){super("Input token account empty"),g(this,"code",6006),g(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ve)}}B.set(6006,()=>new Ve);E.set("EmptySupply",()=>new Ve);class Ge extends Error{constructor(){super("Pool token mint has a non-zero supply"),g(this,"code",6007),g(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ge)}}B.set(6007,()=>new Ge);E.set("InvalidSupply",()=>new Ge);class Je extends Error{constructor(){super("Token account has a delegate"),g(this,"code",6008),g(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Je)}}B.set(6008,()=>new Je);E.set("InvalidDelegate",()=>new Je);class je extends Error{constructor(){super("InvalidInput"),g(this,"code",6009),g(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,je)}}B.set(6009,()=>new je);E.set("InvalidInput",()=>new je);class $e extends Error{constructor(){super("Address of the provided swap token account is incorrect"),g(this,"code",6010),g(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$e)}}B.set(6010,()=>new $e);E.set("IncorrectSwapAccount",()=>new $e);class Ye extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),g(this,"code",6011),g(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ye)}}B.set(6011,()=>new Ye);E.set("IncorrectPoolMint",()=>new Ye);class Xe extends Error{constructor(){super("InvalidOutput"),g(this,"code",6012),g(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xe)}}B.set(6012,()=>new Xe);E.set("InvalidOutput",()=>new Xe);class Ze extends Error{constructor(){super("General calculation failure due to overflow or underflow"),g(this,"code",6013),g(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ze)}}B.set(6013,()=>new Ze);E.set("CalculationFailure",()=>new Ze);class Qe extends Error{constructor(){super("Invalid instruction"),g(this,"code",6014),g(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Qe)}}B.set(6014,()=>new Qe);E.set("InvalidInstruction",()=>new Qe);class et extends Error{constructor(){super("Swap input token accounts have the same mint"),g(this,"code",6015),g(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,et)}}B.set(6015,()=>new et);E.set("RepeatedMint",()=>new et);class tt extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),g(this,"code",6016),g(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,tt)}}B.set(6016,()=>new tt);E.set("ExceededSlippage",()=>new tt);class nt extends Error{constructor(){super("Token account has a close authority"),g(this,"code",6017),g(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,nt)}}B.set(6017,()=>new nt);E.set("InvalidCloseAuthority",()=>new nt);class ot extends Error{constructor(){super("Pool token mint has a freeze authority"),g(this,"code",6018),g(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ot)}}B.set(6018,()=>new ot);E.set("InvalidFreezeAuthority",()=>new ot);class rt extends Error{constructor(){super("Pool fee token account incorrect"),g(this,"code",6019),g(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,rt)}}B.set(6019,()=>new rt);E.set("IncorrectFeeAccount",()=>new rt);class it extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),g(this,"code",6020),g(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,it)}}B.set(6020,()=>new it);E.set("ZeroTradingTokens",()=>new it);class st extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),g(this,"code",6021),g(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,st)}}B.set(6021,()=>new st);E.set("FeeCalculationFailure",()=>new st);class at extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),g(this,"code",6022),g(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,at)}}B.set(6022,()=>new at);E.set("ConversionFailure",()=>new at);class ct extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),g(this,"code",6023),g(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ct)}}B.set(6023,()=>new ct);E.set("InvalidFee",()=>new ct);class ut extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),g(this,"code",6024),g(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ut)}}B.set(6024,()=>new ut);E.set("IncorrectTokenProgramId",()=>new ut);class lt extends Error{constructor(){super("The provided curve type is not supported by the program owner"),g(this,"code",6025),g(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,lt)}}B.set(6025,()=>new lt);E.set("UnsupportedCurveType",()=>new lt);class dt extends Error{constructor(){super("The provided curve parameters are invalid"),g(this,"code",6026),g(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,dt)}}B.set(6026,()=>new dt);E.set("InvalidCurve",()=>new dt);class pt extends Error{constructor(){super("The operation cannot be performed on the given curve"),g(this,"code",6027),g(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pt)}}B.set(6027,()=>new pt);E.set("UnsupportedCurveOperation",()=>new pt);const Yo=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["poolTokenAmount",b.u64],["maximumTokenAAmount",b.u64],["maximumTokenBAmount",b.u64]],"DepositAllTokenTypesInstructionArgs"),Xo=[32,95,69,60,75,79,205,238];function Zo(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=Yo.serialize({instructionDiscriminator:Xo,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userTokenA,isWritable:!0,isSigner:!1},{pubkey:t.userTokenB,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??X,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new K({programId:n,keys:r,data:o})}const Qo=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["sourceTokenAmount",b.u64],["minimumPoolTokenAmount",b.u64]],"DepositSingleTokenTypeInstructionArgs"),er=[175,0,152,41,199,0,148,43];function tr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=Qo.serialize({instructionDiscriminator:er,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??X,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new K({programId:n,keys:r,data:o})}const nr=new b.FixableBeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["feesInput",vn],["curveInput",In],["policy",b.coption(re.publicKey)]],"InitializeInstructionArgs"),or=[175,175,109,31,13,152,155,237];function rr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=nr.serialize({instructionDiscriminator:or,...e}),r=[{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.tokenA,isWritable:!0,isSigner:!1},{pubkey:t.tokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??X,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new K({programId:n,keys:r,data:o})}const ir=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["amountIn",b.u64],["minimumAmountOut",b.u64]],"SwapInstructionArgs"),sr=[248,198,158,145,225,117,135,200];function ar(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=ir.serialize({instructionDiscriminator:sr,...e}),r=[{pubkey:t.proofRequest??n,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userSource,isWritable:!0,isSigner:!1},{pubkey:t.userDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolSource,isWritable:!0,isSigner:!1},{pubkey:t.poolDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.hostFeeAccount??n,isWritable:!1,isSigner:!1},{pubkey:t.tokenProgram??X,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new K({programId:n,keys:r,data:o})}const cr=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["poolTokenAmount",b.u64],["minimumTokenAAmount",b.u64],["minimumTokenBAmount",b.u64]],"WithdrawAllTokenTypesInstructionArgs"),ur=[189,254,156,174,210,9,164,216];function lr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=cr.serialize({instructionDiscriminator:ur,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destTokenA,isWritable:!0,isSigner:!1},{pubkey:t.destTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??X,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new K({programId:n,keys:r,data:o})}const dr=new b.BeetArgsStruct([["instructionDiscriminator",b.uniformFixedSizeArray(b.u8,8)],["destinationTokenAmount",b.u64],["maximumPoolTokenAmount",b.u64]],"WithdrawSingleTokenTypeInstructionArgs"),pr=[111,171,21,77,237,181,241,56];function hr(t,e,n=new p("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[o]=dr.serialize({instructionDiscriminator:pr,...e}),r=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??X,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const s of t.anchorRemainingAccounts)r.push(s);return new K({programId:n,keys:r,data:o})}var Tn=(t=>(t[t.ConstantProduct=0]="ConstantProduct",t[t.ConstantPrice=1]="ConstantPrice",t[t.Offset=2]="Offset",t))(Tn||{});b.fixedScalarEnum(Tn);var Bn=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(Bn||{});b.fixedScalarEnum(Bn);var En=(t=>(t[t.AtoB=0]="AtoB",t[t.BtoA=1]="BtoA",t))(En||{});b.fixedScalarEnum(En);const fr="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",mr=new p(fr);class gr{constructor(e){g(this,"programId",mr),this.provider=e}get connection(){return this.provider.connection}swapAuthority(e){return p.findProgramAddressSync([e.toBuffer()],this.programId)[0]}async createTokenSwap(e,n){const o=new ie,r=e.tokenSwap??Ae.generate(),s=Array.from({length:32}),c=Array.from(e.curveParameters??[]);for(let a=0;a<c.length;a++)s[a]=c[a];const k={curveType:e.curveType,curveParameters:s},l=ee.byteSize({bumpSeed:0,curve:k,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:p.default,poolFeeAccount:p.default,poolMint:p.default,tokenA:p.default,tokenAMint:p.default,tokenB:p.default,tokenBMint:p.default,tokenProgramId:p.default}),R=await this.connection.getMinimumBalanceForRentExemption(l);o.add(le.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:r.publicKey,programId:this.programId,lamports:R,space:l})),o.add(rr({authority:this.swapAuthority(r.publicKey),tokenSwap:r.publicKey,destination:e.destination,poolMint:e.poolMint,poolFee:e.poolFee,tokenA:e.tokenA,tokenB:e.tokenB},{feesInput:{tradeFeeNumerator:new M(e.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new M(e.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new M(e.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new M(e.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new M(e.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new M(e.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new M(e.fees.hostFeeNumerator.toString()),hostFeeDenominator:new M(e.fees.hostFeeDenominator.toString())},curveInput:k,policy:e.policy??null}));const L=await this.provider.sendAndConfirm(o,[r],n);return{tokenSwap:r.publicKey,signature:L}}async swap(e,n){var o,r;const s=new ie;try{await en(this.connection,e.userDestination)}catch(c){(c instanceof kt||c instanceof St)&&e.destinationTokenMint&&s.add(tn(this.provider.publicKey,e.userDestination,this.provider.publicKey,e.destinationTokenMint))}if(e.sourceTokenMint&&((o=e.sourceTokenMint)==null?void 0:o.toBase58())===Xt.toBase58()){let c=0;try{const l=await en(this.connection,e.userSource);c=Number(l.amount)}catch(l){(l instanceof kt||l instanceof St)&&s.add(tn(this.provider.publicKey,e.userSource,this.provider.publicKey,e.sourceTokenMint))}const k=Number(e.amountIn);e.amountIn>c&&s.add(le.transfer({fromPubkey:this.provider.publicKey,toPubkey:e.userSource,lamports:k-c}),Jo(e.userSource))}return s.add(ar({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:e.userSource,userDestination:e.userDestination,tokenSwap:e.tokenSwap,poolFee:e.poolFee,poolMint:e.poolMint,poolSource:e.poolSource,poolDestination:e.poolDestination,proofRequest:e.proofRequest,hostFeeAccount:e.hostFeeAccount},{amountIn:new M(e.amountIn.toString()),minimumAmountOut:new M(e.minimumAmountOut.toString())})),e.destinationTokenMint&&((r=e.destinationTokenMint)==null?void 0:r.toBase58())===Xt.toBase58()&&s.add(Uo(e.userDestination,this.provider.publicKey,this.provider.publicKey)),this.provider.sendAndConfirm(s,[],n)}async depositAllTokenTypes(e,n){const o=Zo({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,destination:e.destination,userTokenA:e.userTokenA,userTokenB:e.userTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new M(e.poolTokenAmount.toString()),maximumTokenAAmount:new M(e.maximumTokenA.toString()),maximumTokenBAmount:new M(e.maximumTokenB.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async withdrawAllTokenTypes(e,n){const o=lr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destTokenA:e.destTokenA,destTokenB:e.destTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new M(e.poolTokenAmount.toString()),minimumTokenAAmount:new M(e.minimumTokenA.toString()),minimumTokenBAmount:new M(e.minimumTokenB.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async depositSingleTokenTypeExactAmountIn(e,n){const o=tr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{sourceTokenAmount:new M(e.sourceTokenAmount.toString()),minimumPoolTokenAmount:new M(e.minimumPoolTokenAmount.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async withdrawSingleTokenTypeExactAmountOut(e,n){const o=hr({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{destinationTokenAmount:new M(e.destinationTokenAmount.toString()),maximumPoolTokenAmount:new M(e.maximumPoolTokenAmount.toString())}),r=new ie().add(o);return this.provider.sendAndConfirm(r,[],n)}async load(e,n){return ee.fromAccountAddress(this.provider.connection,new p(e),n)}async loadAll(e={}){const n=ee.gpaBuilder().addFilter("accountDiscriminator",At);return e.noData&&(n.config.dataSlice={offset:0,length:0}),e.tokenProgramId&&n.addFilter("tokenProgramId",new p(e.tokenProgramId)),e.poolMint&&n.addFilter("poolMint",new p(e.poolMint)),e.tokenAMint&&n.addFilter("tokenAMint",new p(e.tokenAMint)),e.tokenBMint&&n.addFilter("tokenBMint",new p(e.tokenBMint)),(await n.run(this.provider.connection)).map(({pubkey:o,account:r})=>({pubkey:o,data:e.noData?null:ee.fromAccountInfo(r)[0]}))}}const kr=Ln("swap",()=>{const t=Un(),e=qn(),n=_n(),{publicKey:o}=Hn(),{notify:r}=Vn(),s=Gn(()=>new gr(new Ot(t.connection,n.value??{publicKey:Jn.default},Ot.defaultOptions()))),c=Ee([]),k=Ee([]),l=Ee(),R=Lt("token-a",""),L=Lt("token-b",""),a=jn({loading:!1,slippageDialog:!1,status:void 0,poolBalance:{},poolTokenSupply:0,from:Ut,to:Ut,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:D,tokens:N}=$n();D(Yn),oe(N,()=>{N.value.length>=2&&(a.from=N.value.find(S=>S.mint===R.value)??N.value[0],a.to=N.value.find(S=>S.mint===L.value)??N.value[1])},{immediate:!0}),oe(()=>a.from,()=>{a.from&&(R.value=a.from.mint)}),oe(()=>a.to,()=>{a.to&&(L.value=a.to.mint)}),oe(n,async S=>{te().then(),S||ce()},{immediate:!0});async function te(){a.loading=!0;try{console.log("swapClient ================: ",s.value),c.value=await s.value.loadAll(),console.log("swaps ================: ",c.value)}catch(S){console.log(S),c.value=[]}finally{a.loading=!1}}const A=Ee(!1),T=Xn(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!l.value){A.value=!0;try{const S=await Zn(t.connection,s.value.swapAuthority(l.value.pubkey)),W={};for(const ne of S)W[`${ne.mint}`]=ne.amount;a.poolBalance=W;const q=await Qn(t.connection,l.value.data.poolMint);a.poolTokenSupply=Number(q.supply),console.log("[Pool Balance]",a.poolBalance),console.log("[Pool Balance] poolTokenSupply",a.poolTokenSupply)}catch(S){console.log("[Pool Balance] error",S)}finally{A.value=!1}}},500);setInterval(T,6e4);function F(S){l.value=S,console.log("setTokenSwap: ",l.value)}oe([c,()=>a.from?.mint,()=>a.to?.mint],async()=>{if(console.log("tokenSwapsAll: ",c.value),c.value&&a.from?.mint&&a.to?.mint&&a.from.mint!==a.to.mint)if(k.value=c.value.filter(S=>{const W=S.data?.tokenAMint.toBase58(),q=S.data?.tokenBMint.toBase58();return W===a.from.mint&&q===a.to.mint||W===a.to.mint&&q===a.from.mint}),k.value.length){if(k.value.length>1){const S=k.value.find(W=>e.state.certificates?.find(q=>q.data?.policy.toBase58()===W.data.policy?.toBase58()));S&&(l.value=S)}l.value=k.value[0]}else l.value=void 0;else k.value=[],l.value=void 0,e.setContractPolicy("","swap"),a.poolBalance={}},{immediate:!0}),oe([l],async()=>{console.log("Token SWAP: ",l.value),e.setContractPolicy(l.value?.data.policy?.toBase58()??"","swap"),l.value&&(T(),l.value.data.tokenAMint.toBase58()===a.from.mint?a.direction=0:a.direction=1)},{immediate:!0});function ce(){a.loading=!1,a.slippageDialog=!1,a.status=void 0,a.poolBalance={},a.poolTokenSupply=0}oe([()=>a.direction,()=>a.from.amount,()=>a.poolBalance],async()=>{const S=Number(a.from.amount??0),W=qt(Number(a.poolBalance[a.from.mint]??0),a.from.decimals),q=qt(Number(a.poolBalance[a.to.mint]??0),a.to.decimals);if(S===0||Number.isNaN(S)){a.to.amount=0,a.rate=Number(q)/Number(W),a.impact=0,a.minimumReceived=0;return}const ne=q-W*q/(W+S);a.rate=S?ne/S:q/W,a.to.amount=ne?Number(eo(ne*(1-a.fees.ownerTrade-a.fees.trade),a.to.decimals)):0,a.impact=S?1-ne/S/(q/W):0,a.minimumReceived=xe(a.to.amount-a.to.amount*a.slippage,a.to.decimals)},{immediate:!0});async function xn(){if(!e.certificateValid)return to();if(!l.value||!o.value){console.log("TokenSwap is not initialized...");return}n.value.publicKey||r({type:"info",message:"Please connect your wallet first"});const W=Number(xe(a.from.amount??0,a.from.decimals)),q=Number(xe(e.tokenBalance(a.from.mint)??0,a.from.decimals)),ne=Number(xe(a.to.amount??0,a.to.decimals));if(W>q){r({type:"negative",message:"Insufficient balance."});return}try{a.swapping=!0;const he=a.direction===0?l.value.data.tokenAMint:l.value.data.tokenBMint,Be=a.direction===0?l.value.data.tokenBMint:l.value.data.tokenAMint,Mt=a.direction===0?l.value.data.tokenA:l.value.data.tokenB,Ft=a.direction===0?l.value.data.tokenB:l.value.data.tokenA;console.log("userSourceMint = ",he.toBase58()),console.log("userDestinationMint = ",Be.toBase58()),console.log("userSourceMint = ",he.toBase58()),console.log("userDestinationMint = ",Be.toBase58());const Kt=await _t(he,n.value.publicKey),Rt=await _t(Be,n.value.publicKey),Ct=W;console.log("toAmount = ",ne),console.log("slippage = ",a.slippage),console.log("slippage 2 = ",ne*a.slippage);const Nt=s.value.swapAuthority(l.value.pubkey);console.log("proofRequest = ",e.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",Nt),console.log("tokenSwap = ",l.value.pubkey.toBase58()),console.log("userSource = ",Kt.toBase58()),console.log("userDestination = ",Rt.toBase58()),console.log("poolSource = ",Mt.toBase58()),console.log("poolDestination = ",Ft.toBase58()),console.log("poolMint = ",l.value.data.poolMint.toBase58()),console.log("poolFee = ",l.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",Ct),console.log("minimumAmountOut = ",a.minimumReceived),await s.value.swap({proofRequest:e.certificate?.pubkey,authority:Nt,tokenSwap:l.value.pubkey,userSource:Kt,userDestination:Rt,poolSource:Mt,poolDestination:Ft,poolMint:l.value.data.poolMint,poolFee:l.value.data.poolFeeAccount,amountIn:Ct,minimumAmountOut:a.minimumReceived,sourceTokenMint:he,destinationTokenMint:Be},{commitment:"confirmed"}),Wt()}catch(he){console.log(he)}finally{a.swapping=!1}}function Pn(){const{from:S,to:W}=a;a.rate=0,a.to={...S,amount:void 0},a.from={...W,amount:void 0},a.direction=a.direction===0?1:0}function Wn(){a.slippageDialog=!0}function zn(){a.slippageDialog=!1}function Mn(S){a.from.amount=S}function Wt(){T(),a.from.amount=void 0,a.to.amount=void 0}oe(()=>n.value?.publicKey,S=>{S||Wt()}),oe(()=>a.to,S=>{S.amount&&(S.amount=void 0)});function zt(S){return{host:Pe(S.fees.hostFeeNumerator,S.fees.hostFeeDenominator),trade:Pe(S.fees.tradeFeeNumerator,S.fees.tradeFeeDenominator),ownerTrade:Pe(S.fees.ownerTradeFeeNumerator,S.fees.ownerTradeFeeDenominator),ownerWithdraw:Pe(S.fees.ownerWithdrawFeeNumerator,S.fees.ownerWithdrawFeeDenominator)}}return oe(l,S=>{if(!S)return;const W=zt(S.data);a.fees.host=W.host,a.fees.trade=W.trade,a.fees.ownerTrade=W.ownerTrade,a.fees.ownerWithdraw=W.ownerWithdraw,console.log("fees ==== ",a.fees)}),{state:a,tokenSwapsAll:c,tokenSwaps:k,tokenSwap:l,swapClient:s,loadingPoolTokens:A,loadPoolTokenAccounts:T,setTokenSwap:F,setMax:Mn,closeSlippage:zn,openSlippage:Wn,changeDirection:Pn,swapSubmit:xn,getPoolFee:zt}});export{Tn as s,kr as u};
