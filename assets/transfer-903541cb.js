import{_ as Q,o as R,i as E,k as oe,m as _,P as m,n as Y,q as $,s as re,t as ce,u as le,v as ue,S as j,w as J,x as de,y as fe,z as pe,A as I,B as l,C as ve,F as Z,G as me,H as D,I as A,J as M,K as B,L as W,M as q,N as ye,O as he,Q as G,R as _e,U as ge,V as z,W as be,X as we,Y as ke,Z as Te,$ as Ce,a0 as k,a1 as Se,j as d,a2 as x,a3 as P,a4 as r,a5 as i,a6 as Ke,a7 as V,a8 as L,a9 as U,aa as Ae,ab as Fe,ac as Ne,ad as xe,ae as Me}from"./index-3053357b.js";import{Q as O,o as Re,_ as Ie}from"./SelectToken.vue_vue_type_script_setup_true_lang-7810c907.js";const Ee={},Ye={class:"swap-content"},De=oe('<div class="row"><div class="swap-content__title"> Compliant DeFi with KYC </div><div class="swap-content__details"><p> Compliant DeFi with KYC (Know Your Customer) and AML (Anti-Money Laundering) refers to a type of decentralized finance (DeFi) that incorporates customer identification and anti-money laundering measures to ensure compliance with regulatory requirements. </p><p> KYC refers to the process of verifying the identity of a customer to assess their risk profile and prevent illegal activities such as money laundering and financing of terrorism. In Compliant DeFi with KYC, users are required to provide personal information and undergo identity verification procedures before they can participate in DeFi activities. </p><p> AML refers to the set of policies, procedures, and regulations aimed at detecting and preventing money laundering. In Compliant DeFi with AML, transactions are monitored and analyzed to identify any suspicious or illegal activities. </p><p> By incorporating KYC and AML measures, Compliant DeFi aims to enhance the transparency and security of DeFi transactions while ensuring regulatory compliance. This helps to mitigate the risk of illegal activities in the DeFi ecosystem and enhance the trust and confidence of users, regulators, and other stakeholders. In conclusion, Compliant DeFi with KYC and AML is a new and evolving segment of the DeFi ecosystem that seeks to balance the benefits of decentralized finance with the need for regulatory compliance and security. </p></div></div><div class="row"><div class="swap-content__title"> What zKKYC? What are the benefits? </div><div class="swap-content__details"><p> zKKYC (Zero-Knowledge KYC) is a privacy-preserving technology that enables users to prove their identity without revealing their personal information. It is based on zero-knowledge proofs, a cryptographic technique that allows users to prove the validity of information without revealing the actual data. zKKYC provides a number of benefits over traditional KYC (Know Your Customer) methods that rely on sharing personal information with the platform or a third party: </p><ul class="swap-details"><li> Privacy: zKKYC allows users to prove their identity without revealing their personal information, providing greater privacy and control over their data. </li><li> Security: zKKYC eliminates the risk of personal information being stolen or misused, as the information is not stored or transmitted. </li><li> Convenience: zKKYC enables users to complete the KYC process quickly and easily, without having to provide personal information or wait for manual verification. </li><li> Compliance: zKKYC enables DeFi platforms to comply with regulatory requirements while still preserving user privacy and security. In conclusion, zKKYC is a cutting-edge technology that provides a solution to the challenges posed by traditional KYC methods and offers numerous benefits to both users and platforms in the DeFi ecosystem. </li></ul></div></div>',2),Be=[De];function We(t,e){return R(),E("div",Ye,Be)}const qe=Q(Ee,[["render",We]]);var ze=Object.defineProperty,Pe=(t,e,a)=>e in t?ze(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,Ve=(t,e,a)=>(Pe(t,typeof e!="symbol"?e+"":e,a),a);const Le=new _.BeetArgsStruct([["instructionDiscriminator",_.uniformFixedSizeArray(_.u8,8)],["amount",_.u64]],"SplTransferInstructionArgs"),Ue=[67,186,237,99,235,243,166,198];function Oe(t,e,a=new m("J4pyN7p9dAovEQKoZJV1jUbM3FrCBPLCS2dyiRUnwi5c")){const[o]=Le.serialize({instructionDiscriminator:Ue,...e}),f=[{pubkey:t.sender,isWritable:!0,isSigner:!0},{pubkey:t.receiver,isWritable:!0,isSigner:!1},{pubkey:t.tokenMint,isWritable:!1,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.policy,isWritable:!1,isSigner:!1},{pubkey:t.proofRequest,isWritable:!1,isSigner:!1},{pubkey:t.tokenProgram??ue,isWritable:!1,isSigner:!1},{pubkey:t.systemProgram??j.programId,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const u of t.anchorRemainingAccounts)f.push(u);return new J({programId:a,keys:f,data:o})}const Qe=new _.BeetArgsStruct([["instructionDiscriminator",_.uniformFixedSizeArray(_.u8,8)],["amount",_.u64]],"TransferInstructionArgs"),$e=[163,52,200,231,140,3,69,186];function je(t,e,a=new m("J4pyN7p9dAovEQKoZJV1jUbM3FrCBPLCS2dyiRUnwi5c")){const[o]=Qe.serialize({instructionDiscriminator:$e,...e}),f=[{pubkey:t.sender,isWritable:!0,isSigner:!0},{pubkey:t.receiver,isWritable:!0,isSigner:!1},{pubkey:t.policy,isWritable:!1,isSigner:!1},{pubkey:t.proofRequest,isWritable:!1,isSigner:!1},{pubkey:t.systemProgram??j.programId,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const u of t.anchorRemainingAccounts)f.push(u);return new J({programId:a,keys:f,data:o})}const Je="J4pyN7p9dAovEQKoZJV1jUbM3FrCBPLCS2dyiRUnwi5c",Ze=new m(Je);class Ge{constructor(e){Ve(this,"programId",Ze),this.provider=e}get connection(){return this.provider.connection}async transfer(e,a){const o=this.createTransferTx(e);return this.provider.sendAndConfirm(o,[],a)}createTransferTx(e){const a=je({proofRequest:e.proofRequest,policy:e.policy,sender:this.provider.publicKey,receiver:e.receiver},{amount:e.amount});return new Y().add(a)}async getTransferFee(e){const a=this.createTransferTx(e);return this.transactionFee(a)}async transferToken(e,a){const o=await this.createTransferTokenTx(e);return this.provider.sendAndConfirm(o,[],a)}async createTransferTokenTx(e){const a=new Y;try{await $(this.connection,e.destination)}catch(o){(o instanceof re||o instanceof ce)&&a.add(le(this.provider.publicKey,e.destination,e.receiver,e.tokenMint))}return a.add(Oe({proofRequest:e.proofRequest,policy:e.policy,sender:this.provider.publicKey,receiver:e.receiver,source:e.source,destination:e.destination,tokenMint:e.tokenMint},{amount:e.amount})),a}async getTransferTokenFee(e){const a=await this.createTransferTokenTx(e);return this.transactionFee(a)}async transactionFee(e){e.recentBlockhash=(await this.connection.getLatestBlockhash("finalized")).blockhash,e.feePayer=this.provider.publicKey;const{value:a}=await this.connection.getFeeForMessage(e.compileMessage(),"confirmed");return Number(a)}}const Xe=de("transfer",()=>{const t=fe(),{tokens:e}=pe(),a=I(),{state:o,getUserTokens:f}=I(),u=l(()=>a.certificate),F=l(()=>a.requiredPolicy),T=l(()=>a.certificateValid),C=0,g=ve(),{publicKey:y}=Z(),{notify:N}=me(),S=D(e[0]),n=D({address:"",value:void 0,loading:!1,token:S,fee:C,valid:!1});function K(){n.value=void 0,n.fee=C}A(()=>n.token,()=>{K(),a.policySpec=n.token.name}),A(()=>g.value?.publicKey,s=>{s||(K(),n.address="")}),A(()=>n.address,async()=>{n.valid=M(n.address)});const h=l(()=>{const s=n.token.mint??"";return M(s)?new m(s):""}),p=l(()=>M(n.address)?new m(n.address):""),c=B(),v=B(!1);A([h,p,()=>n.valid],async()=>{if(n.token.label==="sol")return v.value=!0;if(h.value&&p.value&&n.valid)try{return c.value=await W(h.value,p.value),await $(t.connection,c.value),v.value=!0}catch{v.value=!1}v.value=!1}),A([()=>n.valid,()=>n.value,c],()=>{n.valid&&Number(n.value)>0?X():n.fee=C});const b=l(()=>new Ge(new q(t.connection,g.value??{publicKey:m.default},q.defaultOptions())));async function X(){const s=await ye(g.value?.publicKey,n.address,Number(n.value),t.connection),w=await he(s,t.connection)+G;return n.fee=v.value?w:w+_e}async function H(){try{if(n.loading=!0,console.log("[debug] on transfer certificate === ",u.value),T.value){let s;n.token.label==="sol"?s=await ee():s=await te(),N({type:"positive",message:"Transaction confirmed",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${s}?cluster=${t.cluster}`,onClick:()=>!1}]}),K(),await f()}else ge()}catch(s){console.error("verifyTransfer error: ",s)}finally{n.loading=!1}}async function ee(){const s=new z(Number(n.value)*be),w=new m(n.address);return await b.value.transfer({amount:s,receiver:w,proofRequest:u.value.pubkey,policy:new m(F.value)})}async function te(){if(!y.value||!n.token.mint)return;const s=o.tokens.find(ie=>ie.mint===n.token.mint);if(!s||!h.value||!p.value||!g.value)return;const w=await W(h.value,y.value),se=new z(Number(n.value)*10**s.decimals);return await b.value.transferToken({destination:c.value,source:w,tokenMint:h.value,amount:se,receiver:p.value,proofRequest:u.value.pubkey,policy:new m(F.value)})}function ne(s){n.value=s}function ae(s){n.token=s}return{state:n,setMax:ne,setToken:ae,verifyTransfer:H}}),He={class:"swap-form"},et={class:"swap-field"},tt={class:"swap-field__info"},nt={class:"row"},at=r("div",{class:"col-2 swap-field__label"}," AMOUNT ",-1),st={class:"col row justify-end swap-field__balance q-pr-sm"},it={key:0,class:"insufficient-error"},ot=r("div",{class:"col-3 swap-field__label q-pl-sm"}," ASSET ",-1),rt={class:"row justify-between",style:{gap:"10px"}},ct={class:"transfer-address"},lt=r("div",{class:"col transfer-address__label"}," Address ",-1),ut={class:"swap-info"},dt=r("dt",null,"Transfer fee:",-1),ft={class:"swap-submit transfer-submit"},pt=we({__name:"TransferCard",setup(t){const{state:e,setMax:a,setToken:o,verifyTransfer:f}=Xe(),{state:u,tokenBalance:F}=I(),{tokens:T}=ke(),C=l(()=>T.value.filter(c=>u.tokens.find(v=>c.name===Te(v.symbol))).length!==0?T.value:[T.value.find(c=>c.symbol==="sol")]),{connected:g}=Z(),y=l(()=>F(e.token.label)),N=l(()=>y.value===0),S=l(()=>Number(e.value)>y.value);async function n(){const p=S.value?"Insufficient funds":"Not valid address";if(!e.valid||S.value)return Fe.create({type:"negative",timeout:2e3,message:p});f()}function K(){a(y.value),e.token.value==="sol"&&(e.value=y.value-Ne-3*xe-G)}const h=l(()=>Number(e.value)>0&&M(e.address));return(p,c)=>{const v=Ie;return R(),Ce(Se,{class:"swap-card transfer-card"},{default:k(()=>[d(P,{class:"swap-card__header"},{default:k(()=>[x(" Transfer ")]),_:1}),d(P,{class:"swap-card__body"},{default:k(()=>[r("div",He,[r("div",et,[r("div",tt,[r("div",nt,[at,r("div",st,[i(S)?(R(),E("div",it," Insufficient funds ")):Ke("",!0),x(" Balance: "+V(i(L)(i(y))),1)]),ot])]),r("div",rt,[d(O,{modelValue:i(e).value,"onUpdate:modelValue":c[0]||(c[0]=b=>i(e).value=b),disable:i(N),maxlength:14,outlined:"",placeholder:"0.0",class:"swap-input col",onKeypress:i(Re)},{append:k(()=>[d(U,{dense:"",unelevated:"",ripple:!1,class:"swap-input__max",onClick:K},{default:k(()=>[x(" MAX ")]),_:1})]),_:1},8,["modelValue","disable","onKeypress"]),d(v,{disable:!i(g),options:i(C),onSetToken:i(o)},null,8,["disable","options","onSetToken"])])])]),r("div",ct,[lt,d(O,{modelValue:i(e).address,"onUpdate:modelValue":c[1]||(c[1]=b=>i(e).address=b),disable:i(N),maxlength:50,outlined:"",class:"swap-input col"},null,8,["modelValue","disable"])]),r("div",ut,[r("dl",null,[dt,r("dd",null,V(i(L)(i(e).fee,6)),1)])]),r("div",ft,[d(U,{loading:i(e)?.loading,disable:!i(h),rounded:"",ripple:!1,onClick:n},{default:k(()=>[x(" Send ")]),_:1},8,["loading","disable"])])]),_:1}),d(Ae,{showing:i(u)?.loading,class:"swap-loading",color:"grey"},null,8,["showing"])]),_:1})}}}),vt={},mt={class:"main-block row justify-center"};function yt(t,e){const a=pt,o=qe;return R(),E(Me,null,[r("div",mt,[d(a)]),d(o)],64)}const gt=Q(vt,[["render",yt]]);export{gt as default};
