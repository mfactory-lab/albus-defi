import{m as h,ao as we,ap as ye,a as Ge,q as W,bk as We,b2 as xe,aq as nt,bl as rt,k as a,bm as E,n as P,bn as it,S as Pe,R as k,s as at,u as st,w as ct,x as ut,y as lt,z as pt,v as dt,K as ze,P as mt,G as z,A as De,B as ft,bo as Ie,W as ht,H as kt,C as A,bp as fe,I as he,J as wt,bq as yt,br as St,ax as Ce,a6 as At,aN as C,Q as gt,bs as N}from"./index-46b5a8e8.js";import{b as F,d as bt,A as vt,N as Ne,g as Ke,T as Re,a as Oe,c as qe}from"./associatedTokenAccount-ba359049.js";var R;(function(t){t[t.InitializeMint=0]="InitializeMint",t[t.InitializeAccount=1]="InitializeAccount",t[t.InitializeMultisig=2]="InitializeMultisig",t[t.Transfer=3]="Transfer",t[t.Approve=4]="Approve",t[t.Revoke=5]="Revoke",t[t.SetAuthority=6]="SetAuthority",t[t.MintTo=7]="MintTo",t[t.Burn=8]="Burn",t[t.CloseAccount=9]="CloseAccount",t[t.FreezeAccount=10]="FreezeAccount",t[t.ThawAccount=11]="ThawAccount",t[t.TransferChecked=12]="TransferChecked",t[t.ApproveChecked=13]="ApproveChecked",t[t.MintToChecked=14]="MintToChecked",t[t.BurnChecked=15]="BurnChecked",t[t.InitializeAccount2=16]="InitializeAccount2",t[t.SyncNative=17]="SyncNative",t[t.InitializeAccount3=18]="InitializeAccount3",t[t.InitializeMultisig2=19]="InitializeMultisig2",t[t.InitializeMint2=20]="InitializeMint2",t[t.GetAccountDataSize=21]="GetAccountDataSize",t[t.InitializeImmutableOwner=22]="InitializeImmutableOwner",t[t.AmountToUiAmount=23]="AmountToUiAmount",t[t.UiAmountToAmount=24]="UiAmountToAmount",t[t.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",t[t.TransferFeeExtension=26]="TransferFeeExtension",t[t.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",t[t.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",t[t.Reallocate=29]="Reallocate",t[t.MemoTransferExtension=30]="MemoTransferExtension",t[t.CreateNativeMint=31]="CreateNativeMint",t[t.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",t[t.InterestBearingMintExtension=33]="InterestBearingMintExtension",t[t.CpiGuardExtension=34]="CpiGuardExtension",t[t.InitializePermanentDelegate=35]="InitializePermanentDelegate",t[t.TransferHookExtension=36]="TransferHookExtension",t[t.MetadataPointerExtension=39]="MetadataPointerExtension"})(R||(R={}));function Tt(t,e,r){if(r.length){t.push({pubkey:e,isSigner:!1,isWritable:!1});for(const n of r)t.push({pubkey:n instanceof h?n:n.publicKey,isSigner:!0,isWritable:!1})}else t.push({pubkey:e,isSigner:!0,isWritable:!1});return t}const Le=we([ye("instruction")]);function Bt(t,e,r,n=[],c=F){const l=Tt([{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0}],r,n),M=Ge.Buffer.alloc(Le.span);return Le.encode({instruction:R.CloseAccount},M),new W({keys:l,programId:c,data:M})}const Mt=we([We("mintAuthorityOption"),xe("mintAuthority"),nt("supply"),ye("decimals"),rt("isInitialized"),We("freezeAuthorityOption"),xe("freezeAuthority")]);Mt.span;async function Et(t,e,r=!1,n=F,c=vt){if(!r&&!h.isOnCurve(e.toBuffer()))throw new bt;const[l]=await h.findProgramAddress([e.toBuffer(),n.toBuffer(),t.toBuffer()],c);return l}const Ue=we([ye("instruction")]);function Ft(t,e=F){const r=[{pubkey:t,isSigner:!1,isWritable:!0}],n=Ge.Buffer.alloc(Ue.span);return Ue.encode({instruction:R.SyncNative},n),new W({keys:r,programId:e,data:n})}var Wt=Object.defineProperty,xt=(t,e,r)=>e in t?Wt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,i=(t,e,r)=>(xt(t,typeof e!="symbol"?e+"":e,r),r);const Je=new a.BeetArgsStruct([["tradeFeeNumerator",a.u64],["tradeFeeDenominator",a.u64],["ownerTradeFeeNumerator",a.u64],["ownerTradeFeeDenominator",a.u64],["ownerWithdrawFeeNumerator",a.u64],["ownerWithdrawFeeDenominator",a.u64],["hostFeeNumerator",a.u64],["hostFeeDenominator",a.u64]],"FeesInfo"),$e=new a.BeetArgsStruct([["curveType",a.u8],["curveParameters",a.uniformFixedSizeArray(a.u8,32)]],"CurveInfo"),ke=[135,144,215,161,140,125,41,96];class B{constructor(e,r,n,c,l,M,g,w,b,u,v,x){this.isInitialized=e,this.bumpSeed=r,this.tokenProgramId=n,this.tokenA=c,this.tokenB=l,this.poolMint=M,this.tokenAMint=g,this.tokenBMint=w,this.poolFeeAccount=b,this.fees=u,this.curve=v,this.policy=x}static fromArgs(e){return new B(e.isInitialized,e.bumpSeed,e.tokenProgramId,e.tokenA,e.tokenB,e.poolMint,e.tokenAMint,e.tokenBMint,e.poolFeeAccount,e.fees,e.curve,e.policy)}static fromAccountInfo(e,r=0){return B.deserialize(e.data,r)}static async fromAccountAddress(e,r,n){const c=await e.getAccountInfo(r,n);if(c==null)throw new Error(`Unable to find TokenSwap account at ${r}`);return B.fromAccountInfo(c,0)[0]}static gpaBuilder(e=new h("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return E.GpaBuilder.fromStruct(e,K)}static deserialize(e,r=0){return K.deserialize(e,r)}serialize(){return K.serialize({accountDiscriminator:ke,...this})}static byteSize(e){const r=B.fromArgs(e);return K.toFixedFromValue({accountDiscriminator:ke,...r}).byteSize}static async getMinimumBalanceForRentExemption(e,r,n){return r.getMinimumBalanceForRentExemption(B.byteSize(e),n)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const K=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["isInitialized",a.bool],["bumpSeed",a.u8],["tokenProgramId",E.publicKey],["tokenA",E.publicKey],["tokenB",E.publicKey],["poolMint",E.publicKey],["tokenAMint",E.publicKey],["tokenBMint",E.publicKey],["poolFeeAccount",E.publicKey],["fees",Je],["curve",$e],["policy",a.coption(E.publicKey)]],B.fromArgs,"TokenSwap"),m=new Map,f=new Map;class O extends Error{constructor(){super("Swap account already in use"),i(this,"code",6e3),i(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,O)}}m.set(6e3,()=>new O);f.set("AlreadyInUse",()=>new O);class q extends Error{constructor(){super("Invalid program address generated from bump seed and key"),i(this,"code",6001),i(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,q)}}m.set(6001,()=>new q);f.set("InvalidProgramAddress",()=>new q);class L extends Error{constructor(){super("Input account owner is not the program address"),i(this,"code",6002),i(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,L)}}m.set(6002,()=>new L);f.set("InvalidOwner",()=>new L);class U extends Error{constructor(){super("Output pool account owner cannot be the program address"),i(this,"code",6003),i(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,U)}}m.set(6003,()=>new U);f.set("InvalidOutputOwner",()=>new U);class G extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),i(this,"code",6004),i(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G)}}m.set(6004,()=>new G);f.set("ExpectedMint",()=>new G);class J extends Error{constructor(){super("Deserialized account is not an SPL Token account"),i(this,"code",6005),i(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,J)}}m.set(6005,()=>new J);f.set("ExpectedAccount",()=>new J);class $ extends Error{constructor(){super("Input token account empty"),i(this,"code",6006),i(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$)}}m.set(6006,()=>new $);f.set("EmptySupply",()=>new $);class H extends Error{constructor(){super("Pool token mint has a non-zero supply"),i(this,"code",6007),i(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,H)}}m.set(6007,()=>new H);f.set("InvalidSupply",()=>new H);class Q extends Error{constructor(){super("Token account has a delegate"),i(this,"code",6008),i(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Q)}}m.set(6008,()=>new Q);f.set("InvalidDelegate",()=>new Q);class V extends Error{constructor(){super("InvalidInput"),i(this,"code",6009),i(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,V)}}m.set(6009,()=>new V);f.set("InvalidInput",()=>new V);class j extends Error{constructor(){super("Address of the provided swap token account is incorrect"),i(this,"code",6010),i(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,j)}}m.set(6010,()=>new j);f.set("IncorrectSwapAccount",()=>new j);class Z extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),i(this,"code",6011),i(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Z)}}m.set(6011,()=>new Z);f.set("IncorrectPoolMint",()=>new Z);class X extends Error{constructor(){super("InvalidOutput"),i(this,"code",6012),i(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,X)}}m.set(6012,()=>new X);f.set("InvalidOutput",()=>new X);class Y extends Error{constructor(){super("General calculation failure due to overflow or underflow"),i(this,"code",6013),i(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Y)}}m.set(6013,()=>new Y);f.set("CalculationFailure",()=>new Y);class _ extends Error{constructor(){super("Invalid instruction"),i(this,"code",6014),i(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_)}}m.set(6014,()=>new _);f.set("InvalidInstruction",()=>new _);class ee extends Error{constructor(){super("Swap input token accounts have the same mint"),i(this,"code",6015),i(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ee)}}m.set(6015,()=>new ee);f.set("RepeatedMint",()=>new ee);class te extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),i(this,"code",6016),i(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,te)}}m.set(6016,()=>new te);f.set("ExceededSlippage",()=>new te);class oe extends Error{constructor(){super("Token account has a close authority"),i(this,"code",6017),i(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,oe)}}m.set(6017,()=>new oe);f.set("InvalidCloseAuthority",()=>new oe);class ne extends Error{constructor(){super("Pool token mint has a freeze authority"),i(this,"code",6018),i(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ne)}}m.set(6018,()=>new ne);f.set("InvalidFreezeAuthority",()=>new ne);class re extends Error{constructor(){super("Pool fee token account incorrect"),i(this,"code",6019),i(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,re)}}m.set(6019,()=>new re);f.set("IncorrectFeeAccount",()=>new re);class ie extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),i(this,"code",6020),i(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ie)}}m.set(6020,()=>new ie);f.set("ZeroTradingTokens",()=>new ie);class ae extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),i(this,"code",6021),i(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ae)}}m.set(6021,()=>new ae);f.set("FeeCalculationFailure",()=>new ae);class se extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),i(this,"code",6022),i(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,se)}}m.set(6022,()=>new se);f.set("ConversionFailure",()=>new se);class ce extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),i(this,"code",6023),i(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ce)}}m.set(6023,()=>new ce);f.set("InvalidFee",()=>new ce);class ue extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),i(this,"code",6024),i(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ue)}}m.set(6024,()=>new ue);f.set("IncorrectTokenProgramId",()=>new ue);class le extends Error{constructor(){super("The provided curve type is not supported by the program owner"),i(this,"code",6025),i(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,le)}}m.set(6025,()=>new le);f.set("UnsupportedCurveType",()=>new le);class pe extends Error{constructor(){super("The provided curve parameters are invalid"),i(this,"code",6026),i(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pe)}}m.set(6026,()=>new pe);f.set("InvalidCurve",()=>new pe);class de extends Error{constructor(){super("The operation cannot be performed on the given curve"),i(this,"code",6027),i(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,de)}}m.set(6027,()=>new de);f.set("UnsupportedCurveOperation",()=>new de);new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"CloseAccountInstructionArgs");const Pt=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["poolTokenAmount",a.u64],["maximumTokenAAmount",a.u64],["maximumTokenBAmount",a.u64]],"DepositAllTokenTypesInstructionArgs"),zt=[32,95,69,60,75,79,205,238];function Dt(t,e,r=new h("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=Pt.serialize({instructionDiscriminator:zt,...e}),c=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userTokenA,isWritable:!0,isSigner:!1},{pubkey:t.userTokenB,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??F,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)c.push(l);return new W({programId:r,keys:c,data:n})}const It=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["sourceTokenAmount",a.u64],["minimumPoolTokenAmount",a.u64]],"DepositSingleTokenTypeInstructionArgs"),Ct=[175,0,152,41,199,0,148,43];function Nt(t,e,r=new h("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=It.serialize({instructionDiscriminator:Ct,...e}),c=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??F,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)c.push(l);return new W({programId:r,keys:c,data:n})}const Kt=new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["feesInput",Je],["curveInput",$e],["policy",a.coption(E.publicKey)]],"InitializeInstructionArgs"),Rt=[175,175,109,31,13,152,155,237];function Ot(t,e,r=new h("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=Kt.serialize({instructionDiscriminator:Rt,...e}),c=[{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.tokenA,isWritable:!0,isSigner:!1},{pubkey:t.tokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??F,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)c.push(l);return new W({programId:r,keys:c,data:n})}const qt=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["amountIn",a.u64],["minimumAmountOut",a.u64]],"SwapInstructionArgs"),Lt=[248,198,158,145,225,117,135,200];function Ut(t,e,r=new h("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=qt.serialize({instructionDiscriminator:Lt,...e}),c=[{pubkey:t.proofRequest??r,isWritable:!1,isSigner:!1},{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.userSource,isWritable:!0,isSigner:!1},{pubkey:t.userDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolSource,isWritable:!0,isSigner:!1},{pubkey:t.poolDestination,isWritable:!0,isSigner:!1},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.hostFeeAccount??r,isWritable:!1,isSigner:!1},{pubkey:t.tokenProgram??F,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)c.push(l);return new W({programId:r,keys:c,data:n})}const Gt=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["poolTokenAmount",a.u64],["minimumTokenAAmount",a.u64],["minimumTokenBAmount",a.u64]],"WithdrawAllTokenTypesInstructionArgs"),Jt=[189,254,156,174,210,9,164,216];function $t(t,e,r=new h("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=Gt.serialize({instructionDiscriminator:Jt,...e}),c=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destTokenA,isWritable:!0,isSigner:!1},{pubkey:t.destTokenB,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??F,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)c.push(l);return new W({programId:r,keys:c,data:n})}const Ht=new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["destinationTokenAmount",a.u64],["maximumPoolTokenAmount",a.u64]],"WithdrawSingleTokenTypeInstructionArgs"),Qt=[111,171,21,77,237,181,241,56];function Vt(t,e,r=new h("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[n]=Ht.serialize({instructionDiscriminator:Qt,...e}),c=[{pubkey:t.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:t.authority,isWritable:!1,isSigner:!1},{pubkey:t.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:t.poolMint,isWritable:!0,isSigner:!1},{pubkey:t.source,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:t.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:t.destination,isWritable:!0,isSigner:!1},{pubkey:t.poolFee,isWritable:!0,isSigner:!1},{pubkey:t.tokenProgram??F,isWritable:!1,isSigner:!1}];if(t.anchorRemainingAccounts!=null)for(const l of t.anchorRemainingAccounts)c.push(l);return new W({programId:r,keys:c,data:n})}var He=(t=>(t[t.ConstantProduct=0]="ConstantProduct",t[t.ConstantPrice=1]="ConstantPrice",t[t.Offset=2]="Offset",t))(He||{});a.fixedScalarEnum(He);var Qe=(t=>(t[t.Floor=0]="Floor",t[t.Ceiling=1]="Ceiling",t))(Qe||{});a.fixedScalarEnum(Qe);var Ve=(t=>(t[t.AtoB=0]="AtoB",t[t.BtoA=1]="BtoA",t))(Ve||{});a.fixedScalarEnum(Ve);const jt="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",Zt=new h(jt);class Xt{constructor(e){i(this,"programId",Zt),this.provider=e}get connection(){return this.provider.connection}swapAuthority(e){return h.findProgramAddressSync([e.toBuffer()],this.programId)[0]}async createTokenSwap(e,r){const n=new P,c=e.tokenSwap??it.generate(),l=Array.from({length:32}),M=Array.from(e.curveParameters??[]);for(let v=0;v<M.length;v++)l[v]=M[v];const g={curveType:e.curveType,curveParameters:l},w=B.byteSize({bumpSeed:0,curve:g,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:h.default,poolFeeAccount:h.default,poolMint:h.default,tokenA:h.default,tokenAMint:h.default,tokenB:h.default,tokenBMint:h.default,tokenProgramId:h.default}),b=await this.connection.getMinimumBalanceForRentExemption(w);n.add(Pe.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:c.publicKey,programId:this.programId,lamports:b,space:w})),n.add(Ot({authority:this.swapAuthority(c.publicKey),tokenSwap:c.publicKey,destination:e.destination,poolMint:e.poolMint,poolFee:e.poolFee,tokenA:e.tokenA,tokenB:e.tokenB},{feesInput:{tradeFeeNumerator:new k(e.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new k(e.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new k(e.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new k(e.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new k(e.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new k(e.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new k(e.fees.hostFeeNumerator.toString()),hostFeeDenominator:new k(e.fees.hostFeeDenominator.toString())},curveInput:g,policy:e.policy??null}));const u=await this.provider.sendAndConfirm(n,[c],r);return{tokenSwap:c.publicKey,signature:u}}async swap(e,r){const n=new P;return await this.handleAccount(n,e.userDestination,e.destinationTokenMint),await this.handleWrappedSol({tx:n,amount:e.amountIn,userSource:e.userSource,sourceTokenMint:e.sourceTokenMint}),n.add(Ut({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:e.userSource,userDestination:e.userDestination,tokenSwap:e.tokenSwap,poolFee:e.poolFee,poolMint:e.poolMint,poolSource:e.poolSource,poolDestination:e.poolDestination,proofRequest:e.proofRequest,hostFeeAccount:e.hostFeeAccount},{amountIn:new k(e.amountIn.toString()),minimumAmountOut:new k(e.minimumAmountOut.toString())})),this.unwrapSol(n,e.userDestination,e.destinationTokenMint),this.provider.sendAndConfirm(n,[],r)}async depositAllTokenTypes(e,r){const n=new P;return await this.handleAccount(n,e.destination,e.poolMint),await this.handleWrappedSol({tx:n,amount:e.maximumTokenA,userSource:e.userTokenA,sourceTokenMint:e.tokenAMint}),await this.handleWrappedSol({tx:n,amount:e.maximumTokenB,userSource:e.userTokenB,sourceTokenMint:e.tokenBMint}),n.add(Dt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,destination:e.destination,userTokenA:e.userTokenA,userTokenB:e.userTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new k(e.poolTokenAmount.toString()),maximumTokenAAmount:new k(e.maximumTokenA.toString()),maximumTokenBAmount:new k(e.maximumTokenB.toString())})),this.provider.sendAndConfirm(n,[],r)}async withdrawAllTokenTypes(e,r){const n=new P;return await this.handleAccount(n,e.destTokenA,e.tokenAMint),await this.handleAccount(n,e.destTokenB,e.tokenBMint),n.add($t({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destTokenA:e.destTokenA,destTokenB:e.destTokenB,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{poolTokenAmount:new k(e.poolTokenAmount.toString()),minimumTokenAAmount:new k(e.minimumTokenA.toString()),minimumTokenBAmount:new k(e.minimumTokenB.toString())})),this.unwrapSol(n,e.destTokenA,e.tokenAMint),this.unwrapSol(n,e.destTokenB,e.tokenBMint),this.provider.sendAndConfirm(n,[],r)}async depositSingleTokenTypeExactAmountIn(e,r){const n=new P;return await this.handleAccount(n,e.destination,e.poolMint),await this.handleWrappedSol({tx:n,amount:e.sourceTokenAmount,userSource:e.source,sourceTokenMint:e.sourceTokenMint}),n.add(Nt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{sourceTokenAmount:new k(e.sourceTokenAmount.toString()),minimumPoolTokenAmount:new k(e.minimumPoolTokenAmount.toString())})),this.provider.sendAndConfirm(n,[],r)}async withdrawSingleTokenTypeExactAmountOut(e,r){const n=new P;return await this.handleAccount(n,e.destination,e.destinationTokenMint),n.add(Vt({authority:this.swapAuthority(e.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:e.tokenSwap,poolMint:e.poolMint,poolFee:e.poolFee,source:e.source,destination:e.destination,swapTokenA:e.swapTokenA,swapTokenB:e.swapTokenB},{destinationTokenAmount:new k(e.destinationTokenAmount.toString()),maximumPoolTokenAmount:new k(e.maximumPoolTokenAmount.toString())})),this.unwrapSol(n,e.destination,e.destinationTokenMint),this.provider.sendAndConfirm(n,[],r)}async load(e,r){return B.fromAccountAddress(this.provider.connection,new h(e),r)}async loadAll(e={}){const r=B.gpaBuilder().addFilter("accountDiscriminator",ke);return e.noData&&(r.config.dataSlice={offset:0,length:0}),e.tokenProgramId&&r.addFilter("tokenProgramId",new h(e.tokenProgramId)),e.poolMint&&r.addFilter("poolMint",new h(e.poolMint)),e.tokenAMint&&r.addFilter("tokenAMint",new h(e.tokenAMint)),e.tokenBMint&&r.addFilter("tokenBMint",new h(e.tokenBMint)),(await r.run(this.provider.connection)).map(({pubkey:n,account:c})=>({pubkey:n,data:e.noData?null:B.fromAccountInfo(c)[0]}))}unwrapSol(e,r,n){n&&n.toBase58()===Ne.toBase58()&&e.add(Bt(r,this.provider.publicKey,this.provider.publicKey))}async handleAccount(e,r,n){try{await Ke(this.connection,r)}catch(c){(c instanceof Re||c instanceof Oe)&&n&&e.add(qe(this.provider.publicKey,r,this.provider.publicKey,n))}}async handleWrappedSol(e){var r;if(e.sourceTokenMint&&((r=e.sourceTokenMint)==null?void 0:r.toBase58())===Ne.toBase58()){let n=0;try{if((await Et(e.sourceTokenMint,this.provider.publicKey)).toBase58()!==e.userSource.toBase58())return;const l=await Ke(this.connection,e.userSource);n=Number(l.amount)}catch(l){(l instanceof Re||l instanceof Oe)&&e.tx.add(qe(this.provider.publicKey,e.userSource,this.provider.publicKey,e.sourceTokenMint))}const c=Number(e.amount);e.amount>n&&e.tx.add(Pe.transfer({fromPubkey:this.provider.publicKey,toPubkey:e.userSource,lamports:c-n}),Ft(e.userSource))}}}var Yt=(t=>(t[t.ASC=0]="ASC",t[t.DESC=1]="DESC",t))(Yt||{});const oo=at("swap",()=>{const t=st(),e=ct(),r=ut(),{publicKey:n}=lt(),{notify:c}=pt(),l=dt(()=>new Xt(new ze(t.connection,r.value??{publicKey:mt.default},ze.defaultOptions()))),M=z({}),g=z([]),w=z([]),b=z([]),u=z(),v=De("token-a",""),x=De("token-b",""),o=ft({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:Ie,to:Ie,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:je,tokens:T}=ht();je(kt),A(T,()=>{if(T.value.length>=2){const s=T.value.find(d=>d.mint===v.value)??T.value[0];let p=T.value.find(d=>d.mint===x.value)??T.value[1];if(o.from=T.value.find(d=>d.mint===v.value)??T.value[0],o.to=T.value.find(d=>d.mint===x.value)??T.value[1],s===p){const d=T.value.find(y=>y.mint!==s.mint);d&&(p=d)}o.from=s,o.to=p}},{immediate:!0}),A(()=>o.from,()=>{o.from&&(v.value=o.from.mint)}),A(()=>o.to,()=>{o.to&&(x.value=o.to.mint)});const Se=fe(async()=>{o.loading=!0;try{console.log("swapClient ================: ",l.value),g.value=await l.value.loadAll(),console.log("swaps ================: ",g.value)}catch(s){console.log(s),g.value=[]}finally{o.loading=!1}},400);A([r,()=>t.cluster],async s=>{Se()?.then(),s||Xe()},{immediate:!0});const Ae=fe(async()=>{if(n.value&&w.value.length>0){const s={};for(const p of w.value)try{const d=await he(p.data.poolMint,n.value),y=await wt(t.connection,d);s[p.data.poolMint.toBase58()]=Number(y.amount),console.log("userAcc === ",y)}catch{}M.value=s}},500);A([n,w],Ae,{immediate:!0});const me=z(!1),D=fe(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!u.value){me.value=!0;try{const s=await yt(t.connection,l.value.swapAuthority(u.value.pubkey)),p={};for(const y of s)p[`${y.mint}`]=y.amount;o.poolBalance=p;const d=await St(t.connection,u.value.data.poolMint);o.poolTokenSupply=Number(d.supply),console.log("[Pool Balance] poolMint",d),console.log("[Pool Balance]",o.poolBalance),console.log("[Pool Balance] poolTokenSupply",o.poolTokenSupply)}catch(s){console.log("[Pool Balance] error",s)}finally{me.value=!1}}},500);setInterval(D,6e4);function Ze(s){u.value=s,console.log("setTokenSwap: ",u.value)}A([g,()=>e.servicePolicy],async()=>{console.log("tokenSwapsAll: ",g.value),w.value=g.value.filter(s=>!!e.servicePolicy.find(p=>p.pubkey.toBase58()===s.data.policy?.toBase58()))},{immediate:!0}),A([w,()=>o.from?.mint,()=>o.to?.mint,()=>e.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",w.value),w.value&&o.from?.mint&&o.to?.mint&&o.from.mint!==o.to.mint&&e.servicePolicy.length)if(b.value=w.value.filter(s=>{const p=s.data?.tokenAMint.toBase58(),d=s.data?.tokenBMint.toBase58();return p===o.from.mint&&d===o.to.mint||p===o.to.mint&&d===o.from.mint}),b.value.length){if(b.value.length>1){const s=b.value.find(p=>e.state.certificates?.find(d=>d.data?.policy.toBase58()===p.data.policy?.toBase58()));s&&(u.value=s)}u.value=b.value[0]}else u.value=void 0;else b.value=[],u.value=void 0,e.setContractPolicy("","swap"),o.poolBalance={}},{immediate:!0}),A([u],async()=>{console.log("Token SWAP: ",u.value),e.setContractPolicy(u.value?.data.policy?.toBase58()??"","swap"),u.value&&(D(),u.value.data.tokenAMint.toBase58()===o.from.mint?o.direction=0:o.direction=1)},{immediate:!0});function Xe(){o.loading=!1,o.slippageDialog=!1,o.poolBalance={},o.poolTokenSupply=0}A([()=>o.direction,()=>o.from.amount,()=>o.poolBalance],async()=>{const s=Number(o.from.amount??0),p=Ce(Number(o.poolBalance[o.from.mint]??0),o.from.decimals),d=Ce(Number(o.poolBalance[o.to.mint]??0),o.to.decimals),y=1-o.fees.ownerTrade-o.fees.trade;if(s===0||Number.isNaN(s)){o.to.amount=0,o.rate=Number(d)/Number(p)*y,o.impact=0,o.minimumReceived=0;return}const S=d-p*d/(p+s*y);o.rate=s?S/s:d/p,o.to.amount=S?Number(At(S,o.to.decimals)):0,o.impact=s?1-S/s/y/(d/p):0,o.minimumReceived=C(o.to.amount-o.to.amount*o.slippage,o.to.decimals)},{immediate:!0});async function Ye(){if(!e.certificateValid)return gt();if(!u.value||!n.value){console.log("Pool is not selected...");return}r.value.publicKey||c({type:"info",message:"Please connect your wallet first"});const p=Number(C(o.from.amount??0,o.from.decimals)),d=Number(C(e.tokenBalance(o.from.mint)??0,o.from.decimals)),y=Number(C(o.to.amount??0,o.to.decimals));if(p>d){c({type:"negative",message:"Insufficient balance."});return}try{o.swapping=!0;const S=o.direction===0?u.value.data.tokenAMint:u.value.data.tokenBMint,I=o.direction===0?u.value.data.tokenBMint:u.value.data.tokenAMint,ve=o.direction===0?u.value.data.tokenA:u.value.data.tokenB,Te=o.direction===0?u.value.data.tokenB:u.value.data.tokenA;console.log("userSourceMint = ",S.toBase58()),console.log("userDestinationMint = ",I.toBase58()),console.log("userSourceMint = ",S.toBase58()),console.log("userDestinationMint = ",I.toBase58());const Be=await he(S,r.value.publicKey),Me=await he(I,r.value.publicKey),Ee=p;console.log("toAmount = ",y),console.log("slippage = ",o.slippage),console.log("slippage 2 = ",y*o.slippage);const Fe=l.value.swapAuthority(u.value.pubkey);console.log("proofRequest = ",e.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",Fe),console.log("tokenSwap = ",u.value.pubkey.toBase58()),console.log("userSource = ",Be.toBase58()),console.log("userDestination = ",Me.toBase58()),console.log("poolSource = ",ve.toBase58()),console.log("poolDestination = ",Te.toBase58()),console.log("poolMint = ",u.value.data.poolMint.toBase58()),console.log("poolFee = ",u.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",Ee),console.log("minimumAmountOut = ",o.minimumReceived);const ot=await l.value.swap({proofRequest:e.certificate?.pubkey,authority:Fe,tokenSwap:u.value.pubkey,userSource:Be,userDestination:Me,poolSource:ve,poolDestination:Te,poolMint:u.value.data.poolMint,poolFee:u.value.data.poolFeeAccount,amountIn:Ee,minimumAmountOut:o.minimumReceived,sourceTokenMint:S,destinationTokenMint:I},{commitment:"confirmed"});c({message:"Transaction confirmed",type:"positive",actions:[{label:"Explore",color:"white",target:"_blank",href:`https://explorer.solana.com/tx/${ot}?cluster=${t.cluster}`,onClick:()=>!1}]}),ge()}catch(S){console.log(S),`${S}`.includes("User rejected the request")||c({type:"negative",message:`${S}`})}finally{o.swapping=!1}}function _e(){const{from:s,to:p}=o;o.rate=0,o.to={...s,amount:void 0},o.from={...p,amount:void 0},o.direction=o.direction===0?1:0}function et(){o.slippageDialog=!0}function tt(){o.slippageDialog=!1}function ge(){D(),o.from.amount=void 0,o.to.amount=void 0}A(()=>r.value?.publicKey,s=>{s||ge()}),A(()=>o.to,s=>{s.amount&&(s.amount=void 0)});function be(s){return{host:N(s.fees.hostFeeNumerator,s.fees.hostFeeDenominator),trade:N(s.fees.tradeFeeNumerator,s.fees.tradeFeeDenominator),ownerTrade:N(s.fees.ownerTradeFeeNumerator,s.fees.ownerTradeFeeDenominator),ownerWithdraw:N(s.fees.ownerWithdrawFeeNumerator,s.fees.ownerWithdrawFeeDenominator)}}return A(u,s=>{if(!s)return;const p=be(s.data);o.fees.host=p.host,o.fees.trade=p.trade,o.fees.ownerTrade=p.ownerTrade,o.fees.ownerWithdraw=p.ownerWithdraw,console.log("fees ==== ",o.fees)}),{state:o,tokenSwapsAllFiltered:w,tokenSwaps:b,tokenSwap:u,swapClient:l,loadingPoolTokens:me,loadPoolTokenAccounts:D,setTokenSwap:Ze,closeSlippage:tt,openSlippage:et,changeDirection:_e,swapSubmit:Ye,getPoolFee:be,init:Se,tokenAMint:v,tokenBMint:x,userPoolsTokens:M,reloadUserLP:Ae}});export{Yt as S,He as s,oo as u};
