import{m as f,ap as Ne,aq as Ce,a as Ke,q as B,k as i,b9 as T,n as x,ba as _e,S as be,U as w,s as et,u as tt,w as ot,x as nt,y as rt,z as it,v as at,K as ve,P as st,G as z,A as Te,B as ct,bb as Be,X as ut,H as lt,C as g,bc as pt,bd as dt,be as mt,ay as Ee,a7 as ft,aG as I,R as yt,I as Me,Q as wt,bf as N}from"./index-ca95064e.js";import{b as E,g as Fe,T as We,a as xe,c as ze,N as Pe}from"./associatedTokenAccount-bf362adb.js";var K;(function(e){e[e.InitializeMint=0]="InitializeMint",e[e.InitializeAccount=1]="InitializeAccount",e[e.InitializeMultisig=2]="InitializeMultisig",e[e.Transfer=3]="Transfer",e[e.Approve=4]="Approve",e[e.Revoke=5]="Revoke",e[e.SetAuthority=6]="SetAuthority",e[e.MintTo=7]="MintTo",e[e.Burn=8]="Burn",e[e.CloseAccount=9]="CloseAccount",e[e.FreezeAccount=10]="FreezeAccount",e[e.ThawAccount=11]="ThawAccount",e[e.TransferChecked=12]="TransferChecked",e[e.ApproveChecked=13]="ApproveChecked",e[e.MintToChecked=14]="MintToChecked",e[e.BurnChecked=15]="BurnChecked",e[e.InitializeAccount2=16]="InitializeAccount2",e[e.SyncNative=17]="SyncNative",e[e.InitializeAccount3=18]="InitializeAccount3",e[e.InitializeMultisig2=19]="InitializeMultisig2",e[e.InitializeMint2=20]="InitializeMint2",e[e.GetAccountDataSize=21]="GetAccountDataSize",e[e.InitializeImmutableOwner=22]="InitializeImmutableOwner",e[e.AmountToUiAmount=23]="AmountToUiAmount",e[e.UiAmountToAmount=24]="UiAmountToAmount",e[e.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",e[e.TransferFeeExtension=26]="TransferFeeExtension",e[e.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",e[e.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",e[e.Reallocate=29]="Reallocate",e[e.MemoTransferExtension=30]="MemoTransferExtension",e[e.CreateNativeMint=31]="CreateNativeMint",e[e.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",e[e.InterestBearingMintExtension=33]="InterestBearingMintExtension",e[e.CpiGuardExtension=34]="CpiGuardExtension",e[e.InitializePermanentDelegate=35]="InitializePermanentDelegate",e[e.TransferHookExtension=36]="TransferHookExtension",e[e.MetadataPointerExtension=39]="MetadataPointerExtension"})(K||(K={}));function kt(e,t,n){if(n.length){e.push({pubkey:t,isSigner:!1,isWritable:!1});for(const c of n)e.push({pubkey:c instanceof f?c:c.publicKey,isSigner:!0,isWritable:!1})}else e.push({pubkey:t,isSigner:!0,isWritable:!1});return e}const De=Ne([Ce("instruction")]);function ht(e,t,n,c=[],s=E){const l=kt([{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0}],n,c),y=Ke.Buffer.alloc(De.span);return De.encode({instruction:K.CloseAccount},y),new B({keys:l,programId:s,data:y})}const Ie=Ne([Ce("instruction")]);function St(e,t=E){const n=[{pubkey:e,isSigner:!1,isWritable:!0}],c=Ke.Buffer.alloc(Ie.span);return Ie.encode({instruction:K.SyncNative},c),new B({keys:n,programId:t,data:c})}var gt=Object.defineProperty,At=(e,t,n)=>t in e?gt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,r=(e,t,n)=>(At(e,typeof t!="symbol"?t+"":t,n),n);const Re=new i.BeetArgsStruct([["tradeFeeNumerator",i.u64],["tradeFeeDenominator",i.u64],["ownerTradeFeeNumerator",i.u64],["ownerTradeFeeDenominator",i.u64],["ownerWithdrawFeeNumerator",i.u64],["ownerWithdrawFeeDenominator",i.u64],["hostFeeNumerator",i.u64],["hostFeeDenominator",i.u64]],"FeesInfo"),Oe=new i.BeetArgsStruct([["curveType",i.u8],["curveParameters",i.uniformFixedSizeArray(i.u8,32)]],"CurveInfo"),me=[135,144,215,161,140,125,41,96];class A{constructor(t,n,c,s,l,y,S,k,u,M,b,o){this.isInitialized=t,this.bumpSeed=n,this.tokenProgramId=c,this.tokenA=s,this.tokenB=l,this.poolMint=y,this.tokenAMint=S,this.tokenBMint=k,this.poolFeeAccount=u,this.fees=M,this.curve=b,this.policy=o}static fromArgs(t){return new A(t.isInitialized,t.bumpSeed,t.tokenProgramId,t.tokenA,t.tokenB,t.poolMint,t.tokenAMint,t.tokenBMint,t.poolFeeAccount,t.fees,t.curve,t.policy)}static fromAccountInfo(t,n=0){return A.deserialize(t.data,n)}static async fromAccountAddress(t,n,c){const s=await t.getAccountInfo(n,c);if(s==null)throw new Error(`Unable to find TokenSwap account at ${n}`);return A.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){return T.GpaBuilder.fromStruct(t,C)}static deserialize(t,n=0){return C.deserialize(t,n)}serialize(){return C.serialize({accountDiscriminator:me,...this})}static byteSize(t){const n=A.fromArgs(t);return C.toFixedFromValue({accountDiscriminator:me,...n}).byteSize}static async getMinimumBalanceForRentExemption(t,n,c){return n.getMinimumBalanceForRentExemption(A.byteSize(t),c)}pretty(){return{isInitialized:this.isInitialized,bumpSeed:this.bumpSeed,tokenProgramId:this.tokenProgramId.toBase58(),tokenA:this.tokenA.toBase58(),tokenB:this.tokenB.toBase58(),poolMint:this.poolMint.toBase58(),tokenAMint:this.tokenAMint.toBase58(),tokenBMint:this.tokenBMint.toBase58(),poolFeeAccount:this.poolFeeAccount.toBase58(),fees:this.fees,curve:this.curve,policy:this.policy}}}const C=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["isInitialized",i.bool],["bumpSeed",i.u8],["tokenProgramId",T.publicKey],["tokenA",T.publicKey],["tokenB",T.publicKey],["poolMint",T.publicKey],["tokenAMint",T.publicKey],["tokenBMint",T.publicKey],["poolFeeAccount",T.publicKey],["fees",Re],["curve",Oe],["policy",i.coption(T.publicKey)]],A.fromArgs,"TokenSwap"),p=new Map,d=new Map;class R extends Error{constructor(){super("Swap account already in use"),r(this,"code",6e3),r(this,"name","AlreadyInUse"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,R)}}p.set(6e3,()=>new R);d.set("AlreadyInUse",()=>new R);class O extends Error{constructor(){super("Invalid program address generated from bump seed and key"),r(this,"code",6001),r(this,"name","InvalidProgramAddress"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,O)}}p.set(6001,()=>new O);d.set("InvalidProgramAddress",()=>new O);class q extends Error{constructor(){super("Input account owner is not the program address"),r(this,"code",6002),r(this,"name","InvalidOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,q)}}p.set(6002,()=>new q);d.set("InvalidOwner",()=>new q);class L extends Error{constructor(){super("Output pool account owner cannot be the program address"),r(this,"code",6003),r(this,"name","InvalidOutputOwner"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,L)}}p.set(6003,()=>new L);d.set("InvalidOutputOwner",()=>new L);class U extends Error{constructor(){super("Deserialized account is not an SPL Token mint"),r(this,"code",6004),r(this,"name","ExpectedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,U)}}p.set(6004,()=>new U);d.set("ExpectedMint",()=>new U);class G extends Error{constructor(){super("Deserialized account is not an SPL Token account"),r(this,"code",6005),r(this,"name","ExpectedAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,G)}}p.set(6005,()=>new G);d.set("ExpectedAccount",()=>new G);class J extends Error{constructor(){super("Input token account empty"),r(this,"code",6006),r(this,"name","EmptySupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,J)}}p.set(6006,()=>new J);d.set("EmptySupply",()=>new J);class H extends Error{constructor(){super("Pool token mint has a non-zero supply"),r(this,"code",6007),r(this,"name","InvalidSupply"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,H)}}p.set(6007,()=>new H);d.set("InvalidSupply",()=>new H);class $ extends Error{constructor(){super("Token account has a delegate"),r(this,"code",6008),r(this,"name","InvalidDelegate"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$)}}p.set(6008,()=>new $);d.set("InvalidDelegate",()=>new $);class Q extends Error{constructor(){super("InvalidInput"),r(this,"code",6009),r(this,"name","InvalidInput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Q)}}p.set(6009,()=>new Q);d.set("InvalidInput",()=>new Q);class V extends Error{constructor(){super("Address of the provided swap token account is incorrect"),r(this,"code",6010),r(this,"name","IncorrectSwapAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,V)}}p.set(6010,()=>new V);d.set("IncorrectSwapAccount",()=>new V);class X extends Error{constructor(){super("Address of the provided pool token mint is incorrect"),r(this,"code",6011),r(this,"name","IncorrectPoolMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,X)}}p.set(6011,()=>new X);d.set("IncorrectPoolMint",()=>new X);class Z extends Error{constructor(){super("InvalidOutput"),r(this,"code",6012),r(this,"name","InvalidOutput"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Z)}}p.set(6012,()=>new Z);d.set("InvalidOutput",()=>new Z);class j extends Error{constructor(){super("General calculation failure due to overflow or underflow"),r(this,"code",6013),r(this,"name","CalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,j)}}p.set(6013,()=>new j);d.set("CalculationFailure",()=>new j);class Y extends Error{constructor(){super("Invalid instruction"),r(this,"code",6014),r(this,"name","InvalidInstruction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Y)}}p.set(6014,()=>new Y);d.set("InvalidInstruction",()=>new Y);class _ extends Error{constructor(){super("Swap input token accounts have the same mint"),r(this,"code",6015),r(this,"name","RepeatedMint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_)}}p.set(6015,()=>new _);d.set("RepeatedMint",()=>new _);class ee extends Error{constructor(){super("Swap instruction exceeds desired slippage limit"),r(this,"code",6016),r(this,"name","ExceededSlippage"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ee)}}p.set(6016,()=>new ee);d.set("ExceededSlippage",()=>new ee);class te extends Error{constructor(){super("Token account has a close authority"),r(this,"code",6017),r(this,"name","InvalidCloseAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,te)}}p.set(6017,()=>new te);d.set("InvalidCloseAuthority",()=>new te);class oe extends Error{constructor(){super("Pool token mint has a freeze authority"),r(this,"code",6018),r(this,"name","InvalidFreezeAuthority"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,oe)}}p.set(6018,()=>new oe);d.set("InvalidFreezeAuthority",()=>new oe);class ne extends Error{constructor(){super("Pool fee token account incorrect"),r(this,"code",6019),r(this,"name","IncorrectFeeAccount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ne)}}p.set(6019,()=>new ne);d.set("IncorrectFeeAccount",()=>new ne);class re extends Error{constructor(){super("Given pool token amount results in zero trading tokens"),r(this,"code",6020),r(this,"name","ZeroTradingTokens"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,re)}}p.set(6020,()=>new re);d.set("ZeroTradingTokens",()=>new re);class ie extends Error{constructor(){super("Fee calculation failed due to overflow, underflow, or unexpected 0"),r(this,"code",6021),r(this,"name","FeeCalculationFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ie)}}p.set(6021,()=>new ie);d.set("FeeCalculationFailure",()=>new ie);class ae extends Error{constructor(){super("Conversion to u64/u128 failed with an overflow or underflow"),r(this,"code",6022),r(this,"name","ConversionFailure"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ae)}}p.set(6022,()=>new ae);d.set("ConversionFailure",()=>new ae);class se extends Error{constructor(){super("The provided fee does not match the program owner's constraints"),r(this,"code",6023),r(this,"name","InvalidFee"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,se)}}p.set(6023,()=>new se);d.set("InvalidFee",()=>new se);class ce extends Error{constructor(){super("The provided token program does not match the token program expected by the swap"),r(this,"code",6024),r(this,"name","IncorrectTokenProgramId"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ce)}}p.set(6024,()=>new ce);d.set("IncorrectTokenProgramId",()=>new ce);class ue extends Error{constructor(){super("The provided curve type is not supported by the program owner"),r(this,"code",6025),r(this,"name","UnsupportedCurveType"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ue)}}p.set(6025,()=>new ue);d.set("UnsupportedCurveType",()=>new ue);class le extends Error{constructor(){super("The provided curve parameters are invalid"),r(this,"code",6026),r(this,"name","InvalidCurve"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,le)}}p.set(6026,()=>new le);d.set("InvalidCurve",()=>new le);class pe extends Error{constructor(){super("The operation cannot be performed on the given curve"),r(this,"code",6027),r(this,"name","UnsupportedCurveOperation"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pe)}}p.set(6027,()=>new pe);d.set("UnsupportedCurveOperation",()=>new pe);new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"CloseAccountInstructionArgs");const bt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["maximumTokenAAmount",i.u64],["maximumTokenBAmount",i.u64]],"DepositAllTokenTypesInstructionArgs"),vt=[32,95,69,60,75,79,205,238];function Tt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[c]=bt.serialize({instructionDiscriminator:vt,...t}),s=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userTokenA,isWritable:!0,isSigner:!1},{pubkey:e.userTokenB,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)s.push(l);return new B({programId:n,keys:s,data:c})}const Bt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["sourceTokenAmount",i.u64],["minimumPoolTokenAmount",i.u64]],"DepositSingleTokenTypeInstructionArgs"),Et=[175,0,152,41,199,0,148,43];function Mt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[c]=Bt.serialize({instructionDiscriminator:Et,...t}),s=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)s.push(l);return new B({programId:n,keys:s,data:c})}const Ft=new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["feesInput",Re],["curveInput",Oe],["policy",i.coption(T.publicKey)]],"InitializeInstructionArgs"),Wt=[175,175,109,31,13,152,155,237];function xt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[c]=Ft.serialize({instructionDiscriminator:Wt,...t}),s=[{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!0,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.tokenA,isWritable:!0,isSigner:!1},{pubkey:e.tokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)s.push(l);return new B({programId:n,keys:s,data:c})}const zt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["amountIn",i.u64],["minimumAmountOut",i.u64]],"SwapInstructionArgs"),Pt=[248,198,158,145,225,117,135,200];function Dt(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[c]=zt.serialize({instructionDiscriminator:Pt,...t}),s=[{pubkey:e.proofRequest??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.userSource,isWritable:!0,isSigner:!1},{pubkey:e.userDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolSource,isWritable:!0,isSigner:!1},{pubkey:e.poolDestination,isWritable:!0,isSigner:!1},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.hostFeeAccount??n,isWritable:!1,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)s.push(l);return new B({programId:n,keys:s,data:c})}const It=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["poolTokenAmount",i.u64],["minimumTokenAAmount",i.u64],["minimumTokenBAmount",i.u64]],"WithdrawAllTokenTypesInstructionArgs"),Nt=[189,254,156,174,210,9,164,216];function Ct(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[c]=It.serialize({instructionDiscriminator:Nt,...t}),s=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destTokenA,isWritable:!0,isSigner:!1},{pubkey:e.destTokenB,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)s.push(l);return new B({programId:n,keys:s,data:c})}const Kt=new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["destinationTokenAmount",i.u64],["maximumPoolTokenAmount",i.u64]],"WithdrawSingleTokenTypeInstructionArgs"),Rt=[111,171,21,77,237,181,241,56];function Ot(e,t,n=new f("ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq")){const[c]=Kt.serialize({instructionDiscriminator:Rt,...t}),s=[{pubkey:e.tokenSwap,isWritable:!1,isSigner:!1},{pubkey:e.authority,isWritable:!1,isSigner:!1},{pubkey:e.userTransferAuthority,isWritable:!1,isSigner:!0},{pubkey:e.poolMint,isWritable:!0,isSigner:!1},{pubkey:e.source,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenA,isWritable:!0,isSigner:!1},{pubkey:e.swapTokenB,isWritable:!0,isSigner:!1},{pubkey:e.destination,isWritable:!0,isSigner:!1},{pubkey:e.poolFee,isWritable:!0,isSigner:!1},{pubkey:e.tokenProgram??E,isWritable:!1,isSigner:!1}];if(e.anchorRemainingAccounts!=null)for(const l of e.anchorRemainingAccounts)s.push(l);return new B({programId:n,keys:s,data:c})}var qe=(e=>(e[e.ConstantProduct=0]="ConstantProduct",e[e.ConstantPrice=1]="ConstantPrice",e[e.Offset=2]="Offset",e))(qe||{});i.fixedScalarEnum(qe);var Le=(e=>(e[e.Floor=0]="Floor",e[e.Ceiling=1]="Ceiling",e))(Le||{});i.fixedScalarEnum(Le);var Ue=(e=>(e[e.AtoB=0]="AtoB",e[e.BtoA=1]="BtoA",e))(Ue||{});i.fixedScalarEnum(Ue);const qt="ASWfaoztykN8Lz1P2uwuvwWR61SvFrvn6acM1sJpxKtq",Lt=new f(qt);class Ut{constructor(t){r(this,"programId",Lt),this.provider=t}get connection(){return this.provider.connection}swapAuthority(t){return f.findProgramAddressSync([t.toBuffer()],this.programId)[0]}async createTokenSwap(t,n){const c=new x,s=t.tokenSwap??_e.generate(),l=Array.from({length:32}),y=Array.from(t.curveParameters??[]);for(let b=0;b<y.length;b++)l[b]=y[b];const S={curveType:t.curveType,curveParameters:l},k=A.byteSize({bumpSeed:0,curve:S,fees:{tradeFeeNumerator:0,tradeFeeDenominator:0,ownerTradeFeeNumerator:0,ownerTradeFeeDenominator:0,ownerWithdrawFeeNumerator:0,ownerWithdrawFeeDenominator:0,hostFeeNumerator:0,hostFeeDenominator:0},isInitialized:!1,policy:f.default,poolFeeAccount:f.default,poolMint:f.default,tokenA:f.default,tokenAMint:f.default,tokenB:f.default,tokenBMint:f.default,tokenProgramId:f.default}),u=await this.connection.getMinimumBalanceForRentExemption(k);c.add(be.createAccount({fromPubkey:this.provider.publicKey,newAccountPubkey:s.publicKey,programId:this.programId,lamports:u,space:k})),c.add(xt({authority:this.swapAuthority(s.publicKey),tokenSwap:s.publicKey,destination:t.destination,poolMint:t.poolMint,poolFee:t.poolFee,tokenA:t.tokenA,tokenB:t.tokenB},{feesInput:{tradeFeeNumerator:new w(t.fees.tradeFeeNumerator.toString()),tradeFeeDenominator:new w(t.fees.tradeFeeDenominator.toString()),ownerTradeFeeNumerator:new w(t.fees.ownerTradeFeeNumerator.toString()),ownerTradeFeeDenominator:new w(t.fees.ownerTradeFeeDenominator.toString()),ownerWithdrawFeeNumerator:new w(t.fees.ownerWithdrawFeeNumerator.toString()),ownerWithdrawFeeDenominator:new w(t.fees.ownerWithdrawFeeDenominator.toString()),hostFeeNumerator:new w(t.fees.hostFeeNumerator.toString()),hostFeeDenominator:new w(t.fees.hostFeeDenominator.toString())},curveInput:S,policy:t.policy??null}));const M=await this.provider.sendAndConfirm(c,[s],n);return{tokenSwap:s.publicKey,signature:M}}async swap(t,n){var c,s;const l=new x;try{await Fe(this.connection,t.userDestination)}catch(y){(y instanceof We||y instanceof xe)&&t.destinationTokenMint&&l.add(ze(this.provider.publicKey,t.userDestination,this.provider.publicKey,t.destinationTokenMint))}if(t.sourceTokenMint&&((c=t.sourceTokenMint)==null?void 0:c.toBase58())===Pe.toBase58()){let y=0;try{const k=await Fe(this.connection,t.userSource);y=Number(k.amount)}catch(k){(k instanceof We||k instanceof xe)&&l.add(ze(this.provider.publicKey,t.userSource,this.provider.publicKey,t.sourceTokenMint))}const S=Number(t.amountIn);t.amountIn>y&&l.add(be.transfer({fromPubkey:this.provider.publicKey,toPubkey:t.userSource,lamports:S-y}),St(t.userSource))}return l.add(Dt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,userSource:t.userSource,userDestination:t.userDestination,tokenSwap:t.tokenSwap,poolFee:t.poolFee,poolMint:t.poolMint,poolSource:t.poolSource,poolDestination:t.poolDestination,proofRequest:t.proofRequest,hostFeeAccount:t.hostFeeAccount},{amountIn:new w(t.amountIn.toString()),minimumAmountOut:new w(t.minimumAmountOut.toString())})),t.destinationTokenMint&&((s=t.destinationTokenMint)==null?void 0:s.toBase58())===Pe.toBase58()&&l.add(ht(t.userDestination,this.provider.publicKey,this.provider.publicKey)),this.provider.sendAndConfirm(l,[],n)}async depositAllTokenTypes(t,n){const c=Tt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,destination:t.destination,userTokenA:t.userTokenA,userTokenB:t.userTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new w(t.poolTokenAmount.toString()),maximumTokenAAmount:new w(t.maximumTokenA.toString()),maximumTokenBAmount:new w(t.maximumTokenB.toString())}),s=new x().add(c);return this.provider.sendAndConfirm(s,[],n)}async withdrawAllTokenTypes(t,n){const c=Ct({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destTokenA:t.destTokenA,destTokenB:t.destTokenB,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{poolTokenAmount:new w(t.poolTokenAmount.toString()),minimumTokenAAmount:new w(t.minimumTokenA.toString()),minimumTokenBAmount:new w(t.minimumTokenB.toString())}),s=new x().add(c);return this.provider.sendAndConfirm(s,[],n)}async depositSingleTokenTypeExactAmountIn(t,n){const c=Mt({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{sourceTokenAmount:new w(t.sourceTokenAmount.toString()),minimumPoolTokenAmount:new w(t.minimumPoolTokenAmount.toString())}),s=new x().add(c);return this.provider.sendAndConfirm(s,[],n)}async withdrawSingleTokenTypeExactAmountOut(t,n){const c=Ot({authority:this.swapAuthority(t.tokenSwap),userTransferAuthority:this.provider.publicKey,tokenSwap:t.tokenSwap,poolMint:t.poolMint,poolFee:t.poolFee,source:t.source,destination:t.destination,swapTokenA:t.swapTokenA,swapTokenB:t.swapTokenB},{destinationTokenAmount:new w(t.destinationTokenAmount.toString()),maximumPoolTokenAmount:new w(t.maximumPoolTokenAmount.toString())}),s=new x().add(c);return this.provider.sendAndConfirm(s,[],n)}async load(t,n){return A.fromAccountAddress(this.provider.connection,new f(t),n)}async loadAll(t={}){const n=A.gpaBuilder().addFilter("accountDiscriminator",me);return t.noData&&(n.config.dataSlice={offset:0,length:0}),t.tokenProgramId&&n.addFilter("tokenProgramId",new f(t.tokenProgramId)),t.poolMint&&n.addFilter("poolMint",new f(t.poolMint)),t.tokenAMint&&n.addFilter("tokenAMint",new f(t.tokenAMint)),t.tokenBMint&&n.addFilter("tokenBMint",new f(t.tokenBMint)),(await n.run(this.provider.connection)).map(({pubkey:c,account:s})=>({pubkey:c,data:t.noData?null:A.fromAccountInfo(s)[0]}))}}const $t=et("swap",()=>{const e=tt(),t=ot(),n=nt(),{publicKey:c}=rt(),{notify:s}=it(),l=at(()=>new Ut(new ve(e.connection,n.value??{publicKey:st.default},ve.defaultOptions()))),y=z([]),S=z([]),k=z([]),u=z(),M=Te("token-a",""),b=Te("token-b",""),o=ct({loading:!1,slippageDialog:!1,poolBalance:{},poolTokenSupply:0,from:Be,to:Be,swapping:!1,active:!1,slippage:.01,rate:0,minimumReceived:0,impact:0,fees:{host:0,trade:0,ownerTrade:0,ownerWithdraw:0},direction:0}),{handleFilterToken:Ge,tokens:F}=ut();Ge(lt),g(F,()=>{F.value.length>=2&&(o.from=F.value.find(a=>a.mint===M.value)??F.value[0],o.to=F.value.find(a=>a.mint===b.value)??F.value[1])},{immediate:!0}),g(()=>o.from,()=>{o.from&&(M.value=o.from.mint)}),g(()=>o.to,()=>{o.to&&(b.value=o.to.mint)}),g(n,async a=>{Je().then(),a||$e()},{immediate:!0});async function Je(){o.loading=!0;try{console.log("swapClient ================: ",l.value),y.value=await l.value.loadAll(),console.log("swaps ================: ",y.value)}catch(a){console.log(a),y.value=[]}finally{o.loading=!1}}const de=z(!1),P=pt(async()=>{if(console.log("loadPoolTokenAccounts ========= "),!!u.value){de.value=!0;try{const a=await dt(e.connection,l.value.swapAuthority(u.value.pubkey)),m={};for(const v of a)m[`${v.mint}`]=v.amount;o.poolBalance=m;const h=await mt(e.connection,u.value.data.poolMint);o.poolTokenSupply=Number(h.supply),console.log("[Pool Balance]",o.poolBalance),console.log("[Pool Balance] poolTokenSupply",o.poolTokenSupply)}catch(a){console.log("[Pool Balance] error",a)}finally{de.value=!1}}},500);setInterval(P,6e4);function He(a){u.value=a,console.log("setTokenSwap: ",u.value)}g([y,()=>t.servicePolicy],async()=>{console.log("tokenSwapsAll: ",y.value),S.value=y.value.filter(a=>!!t.servicePolicy.find(m=>m.pubkey.toBase58()===a.data.policy?.toBase58()))},{immediate:!0}),g([S,()=>o.from?.mint,()=>o.to?.mint,()=>t.servicePolicy],async()=>{if(console.log("tokenSwapsAllFiltered: ",S.value),S.value&&o.from?.mint&&o.to?.mint&&o.from.mint!==o.to.mint&&t.servicePolicy.length)if(k.value=S.value.filter(a=>{const m=a.data?.tokenAMint.toBase58(),h=a.data?.tokenBMint.toBase58();return m===o.from.mint&&h===o.to.mint||m===o.to.mint&&h===o.from.mint}),k.value.length){if(k.value.length>1){const a=k.value.find(m=>t.state.certificates?.find(h=>h.data?.policy.toBase58()===m.data.policy?.toBase58()));a&&(u.value=a)}u.value=k.value[0]}else u.value=void 0;else k.value=[],u.value=void 0,t.setContractPolicy("","swap"),o.poolBalance={}},{immediate:!0}),g([u],async()=>{console.log("Token SWAP: ",u.value),t.setContractPolicy(u.value?.data.policy?.toBase58()??"","swap"),u.value&&(P(),u.value.data.tokenAMint.toBase58()===o.from.mint?o.direction=0:o.direction=1)},{immediate:!0});function $e(){o.loading=!1,o.slippageDialog=!1,o.poolBalance={},o.poolTokenSupply=0}g([()=>o.direction,()=>o.from.amount,()=>o.poolBalance],async()=>{const a=Number(o.from.amount??0),m=Ee(Number(o.poolBalance[o.from.mint]??0),o.from.decimals),h=Ee(Number(o.poolBalance[o.to.mint]??0),o.to.decimals);if(a===0||Number.isNaN(a)){o.to.amount=0,o.rate=Number(h)/Number(m),o.impact=0,o.minimumReceived=0;return}const v=h-m*h/(m+a);o.rate=a?v/a:h/m,o.to.amount=v?Number(ft(v*(1-o.fees.ownerTrade-o.fees.trade),o.to.decimals)):0,o.impact=a?1-v/a/(h/m):0,o.minimumReceived=I(o.to.amount-o.to.amount*o.slippage,o.to.decimals)},{immediate:!0});async function Qe(){if(!t.certificateValid)return yt();if(!u.value||!c.value){console.log("TokenSwap is not initialized...");return}n.value.publicKey||s({type:"info",message:"Please connect your wallet first"});const m=Number(I(o.from.amount??0,o.from.decimals)),h=Number(I(t.tokenBalance(o.from.mint)??0,o.from.decimals)),v=Number(I(o.to.amount??0,o.to.decimals));if(m>h){s({type:"negative",message:"Insufficient balance."});return}try{o.swapping=!0;const W=o.direction===0?u.value.data.tokenAMint:u.value.data.tokenBMint,D=o.direction===0?u.value.data.tokenBMint:u.value.data.tokenAMint,we=o.direction===0?u.value.data.tokenA:u.value.data.tokenB,ke=o.direction===0?u.value.data.tokenB:u.value.data.tokenA;console.log("userSourceMint = ",W.toBase58()),console.log("userDestinationMint = ",D.toBase58()),console.log("userSourceMint = ",W.toBase58()),console.log("userDestinationMint = ",D.toBase58());const he=await Me(W,n.value.publicKey),Se=await Me(D,n.value.publicKey),ge=m;console.log("toAmount = ",v),console.log("slippage = ",o.slippage),console.log("slippage 2 = ",v*o.slippage);const Ae=l.value.swapAuthority(u.value.pubkey);console.log("proofRequest = ",t.certificate?.pubkey.toBase58()),console.log("swapAuthority = ",Ae),console.log("tokenSwap = ",u.value.pubkey.toBase58()),console.log("userSource = ",he.toBase58()),console.log("userDestination = ",Se.toBase58()),console.log("poolSource = ",we.toBase58()),console.log("poolDestination = ",ke.toBase58()),console.log("poolMint = ",u.value.data.poolMint.toBase58()),console.log("poolFee = ",u.value.data.poolFeeAccount.toBase58()),console.log("amountIn = ",ge),console.log("minimumAmountOut = ",o.minimumReceived);const Ye=await l.value.swap({proofRequest:t.certificate?.pubkey,authority:Ae,tokenSwap:u.value.pubkey,userSource:he,userDestination:Se,poolSource:we,poolDestination:ke,poolMint:u.value.data.poolMint,poolFee:u.value.data.poolFeeAccount,amountIn:ge,minimumAmountOut:o.minimumReceived,sourceTokenMint:W,destinationTokenMint:D},{commitment:"confirmed"});wt(`https://explorer.solana.com/tx/${Ye}?cluster=${e.cluster}`),fe()}catch(W){console.log(W)}finally{o.swapping=!1}}function Ve(){const{from:a,to:m}=o;o.rate=0,o.to={...a,amount:void 0},o.from={...m,amount:void 0},o.direction=o.direction===0?1:0}function Xe(){o.slippageDialog=!0}function Ze(){o.slippageDialog=!1}function je(a){o.from.amount=a}function fe(){P(),o.from.amount=void 0,o.to.amount=void 0}g(()=>n.value?.publicKey,a=>{a||fe()}),g(()=>o.to,a=>{a.amount&&(a.amount=void 0)});function ye(a){return{host:N(a.fees.hostFeeNumerator,a.fees.hostFeeDenominator),trade:N(a.fees.tradeFeeNumerator,a.fees.tradeFeeDenominator),ownerTrade:N(a.fees.ownerTradeFeeNumerator,a.fees.ownerTradeFeeDenominator),ownerWithdraw:N(a.fees.ownerWithdrawFeeNumerator,a.fees.ownerWithdrawFeeDenominator)}}return g(u,a=>{if(!a)return;const m=ye(a.data);o.fees.host=m.host,o.fees.trade=m.trade,o.fees.ownerTrade=m.ownerTrade,o.fees.ownerWithdraw=m.ownerWithdraw,console.log("fees ==== ",o.fees)}),{state:o,tokenSwapsAllFiltered:S,tokenSwaps:k,tokenSwap:u,swapClient:l,loadingPoolTokens:de,loadPoolTokenAccounts:P,setTokenSwap:He,setMax:je,closeSlippage:Ze,openSlippage:Xe,changeDirection:Ve,swapSubmit:Qe,getPoolFee:ye,tokenAMint:M,tokenBMint:b}});export{qe as s,$t as u};
